[{"categories":["C/C++"],"content":"C++打印虚函数表地址 ","date":"2023-04-14","objectID":"/posts/c++%E5%A6%82%E4%BD%95%E6%89%93%E5%8D%B0%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E7%9A%84%E5%9C%B0%E5%9D%80/:1:0","tags":["C/C++"],"title":"C++如何打印虚函数表的地址","uri":"/posts/c++%E5%A6%82%E4%BD%95%E6%89%93%E5%8D%B0%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E7%9A%84%E5%9C%B0%E5%9D%80/"},{"categories":["C/C++"],"content":"引入 今天遇到了一个问题，非常有意思，在这做一下记录： 对于存在虚函数的类，如何打印虚函数表的地址，并利用这个虚函数表的地址来执行该类中的虚函数 ","date":"2023-04-14","objectID":"/posts/c++%E5%A6%82%E4%BD%95%E6%89%93%E5%8D%B0%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E7%9A%84%E5%9C%B0%E5%9D%80/:1:1","tags":["C/C++"],"title":"C++如何打印虚函数表的地址","uri":"/posts/c++%E5%A6%82%E4%BD%95%E6%89%93%E5%8D%B0%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E7%9A%84%E5%9C%B0%E5%9D%80/"},{"categories":["C/C++"],"content":"虚函数介绍 先简单来讲一下虚函数的概念。 要理解虚函数的概念，先要明确什么是静态类型，什么是动态类型，静态类型可以直观理解为声明时使用的类型，其在编译期间就已经确定，所谓动态类型则在程序运行时才具体表现其类型，在编译期间是不能确定的。 C++中的多态通过虚函数实现，而虚函数通过虚函数表和虚函数表指针实现，利用基类的指针指向派生类，可以调用派生类对应的虚函数，多个不同的派生类可以在运行期间表现出不同的表现，简单示例如下： class Base { public: virtual void fun1() { std::cout \u003c\u003c \"Base fun1\" \u003c\u003c std::endl; } virtual void fun2() { std::cout \u003c\u003c \"Base fun2\" \u003c\u003c std::endl; } }; class ChildA : public Base { public: void fun1() override { std::cout \u003c\u003c \"ChildA fun1\" \u003c\u003c std::endl; } void fun2() override { std::cout \u003c\u003c \"ChildA fun2\" \u003c\u003c std::endl; } }; class ChildB : public Base { public: void fun1() override { std::cout \u003c\u003c \"ChildB fun1\" \u003c\u003c std::endl; } void fun2() override { std::cout \u003c\u003c \"ChildB fun2\" \u003c\u003c std::endl; } }; 这里先定义三个类，继承关系为ChildA与ChildB均public继承Base类，接下来使用基类函数分别去指向三个类对象并执行虚函数： int main() { Base *ptr1 = new Base(); Base *ptr2 = new ChildA(); Base *ptr3 = new ChildB(); ptr1-\u003efun1(); ptr2-\u003efun1(); ptr3-\u003efun1(); ptr1-\u003efun2(); ptr2-\u003efun2(); ptr3-\u003efun2(); delete ptr1; delete ptr2; delete ptr3; return 0; } 执行结果如下： Base fun1 ChildA fun1 ChildB fun1 Base fun2 ChildA fun2 ChildB fun2 可以看到，虽然三个指针都是Base类型的指针，但执行的函数并不相同，这就是虚函数实现的多态：对于相同的请求可以给出不同的反应，执行不同的计划。 简单阐述一下实现原理： 在有虚函数的类中，虚函数用virtual关键字修饰，编译器在遇到有虚函数的类后，会为这个类型创建虚函数表（所谓虚函数表根据编译器的不同实现也不同，从原理上可以认为是一个函数指针数组），以及一个指向这个虚函数表的虚函数表指针，然后再将这个指针存储到类中，在实际运行中，如果执行的是虚函数则会先通过找到虚函数表，再在虚函数表中找到对应的虚函数的函数指针来执行。 而对于继承这个拥有虚函数的子类来说，在继承的时候会一并继承基类的虚函数表以及虚函数指针，可以使用override来对虚函数进行覆盖，当进行覆盖后则虚函数表中原来存储基类虚函数的函数指针会被替换为子类override后的函数指针，这样当找到子类的虚函数时执行的就是子类自己定义的虚函数。 对于继承关系，可以简单归纳为： 一般继承时，子类的虚函数表中会先将基类的虚函数放在最前面，再放自己的虚函数指针 如果子类覆盖了基类的虚函数，则该虚函数将被放到虚函数表中原来基类虚函数的位置 对于多继承的情况，每个基类都拥有自己的虚函数表，子类自身的虚函数将被放到第一个基类的表中，也就是说当类存在多重继承情况时，其实例对象的内存结构里并不只保存一个虚函数表指针，而是有几个基类就会保存几个虚函数表指针 针对上面第三种情况，给一个示例： class A { public: virtual void func_a() {} private: int a; }; class B { public: virtual void func_b() {} private: int b; }; class C : public A, B { public: virtual void func_c() {} private: int c; }; 对于类C，其内存分布如下图： ","date":"2023-04-14","objectID":"/posts/c++%E5%A6%82%E4%BD%95%E6%89%93%E5%8D%B0%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E7%9A%84%E5%9C%B0%E5%9D%80/:1:2","tags":["C/C++"],"title":"C++如何打印虚函数表的地址","uri":"/posts/c++%E5%A6%82%E4%BD%95%E6%89%93%E5%8D%B0%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E7%9A%84%E5%9C%B0%E5%9D%80/"},{"categories":["C/C++"],"content":"如何打印虚函数表 要想知道如何打印虚函数表，首先要确定虚函数表位于类的什么位置，因此我们来用一个例子来具体看一下一个拥有虚函数的类的内存分布到底是什么样子： 首先创建一个类，这个类拥有两个虚函数以及一个成员变量，并在主函数中创建这样一个类 class Test { public: virtual void v_func() {} virtual ~Test() {} int m_test; }; int main() { Test* t = new Test(); return 0; } 这个类的内存中的分布大致如下： 首先创建的Test*对象位于栈上，指向一个堆中对应的Test实例 对象Test的头部是一个虚函数表指针，紧接着是Test对象按照声明顺序排列的成员变量（当创建一个对象时，可以通过实例对象的地址，得到该实例的虚函数表，从而获取其函数指针） 虚函数表指针指向的是代码段中Test类型的虚函数表中的第一个虚函数起始地址 在虚函数表中会构建两个虚析构函数，因为对象有两种构造方式，栈上构造和堆上构造，对于栈上构造的对象其析构不需要执行对应的delete函数，会自动被回收 typeinfo存储着Test的类基础信息，包括父类与类名称，C++关键字typeid返回的也就是这个对象 typeinfo本质也是一个类，对于没有父类的Test类来说，当前的tinfo是class_type_info类型 最后重新再把虚表摘出来，其内部结构如下： 常规认知中的虚函数表并不是单独存在的，而是虚表的一部分，橘色框中的内容即之前理解的虚函数表，其中存放的是虚函数指针 紫色框中的是虚函数的一些基本信息： offset to top指的是这个表到对象起始位置（即内存顶部）的偏移值，只有多重继承的情形才有可能不为0，单继承或者无继承的情况下都是0 RTTI information是一个对象指针，它用于唯一的标识该类型，指向存储运行时类型信息(type_info)的地址，用于运行时进行类型识别，用于typeid和dynamic_cast 蓝色框中的内容仅限于虚拟继承的情况（若无虚拟继承，则无此内容） 来看一下如何打印虚函数表吧～ 这里拿出前面总结中最重要的两点 对象Test的头部是一个虚函数表指针，紧接着是Test对象按照声明顺序排列的成员变量（当创建一个对象时，可以通过实例对象的地址，得到该实例的虚函数表，从而获取其函数指针） 虚函数表指针指向的是代码段中Test类型的虚函数表中的第一个虚函数起始地址 可以很简单理解为，类中有一个虚函数表指针，该指针位于类的最前面即首地址处，而虚函数表指针则指向了第一个虚函数。 因此还是这个基本类： class Base { public: virtual void fun1() { std::cout \u003c\u003c \"Base fun1\" \u003c\u003c std::endl; } virtual void fun2() { std::cout \u003c\u003c \"Base fun2\" \u003c\u003c std::endl; } }; 首先我们使用语句查看编译后的虚函数表与前面分析是否一致： # gcc查看对象布局 g++ -fdump-class-hierarchy main.cpp后查看生成的文件 # clang可以使用如下命令 clang -Xclang -fdump-record-layouts -stdlib=libc++ -c main.cpp # 查看对象布局 clang -Xclang -fdump-vtable-layouts -stdlib=libc++ -c main.cpp # 查看虚函数表布局 对象布局结果如下（只展示Base部分）： *** Dumping AST Record Layout 0 | class Base 0 | (Base vtable pointer) | [sizeof=8, dsize=8, align=8, | nvsize=8, nvalign=8] 这个含有虚函数的Base类大小为8，因为只有一个虚函数指针，在对象的头部，前8个字节是虚函数表的指针，指向虚函数的相应函数指针地址。 虚函数表布局执行结果如下（只展示虚函数表部分）： Vtable for 'Base' (4 entries). 0 | offset_to_top (0) 1 | Base RTTI -- (Base, 0) vtable address -- 2 | void Base::fun1() 3 | void Base::fun2() VTable indices for 'Base' (2 entries). 0 | void Base::fun1() 1 | void Base::fun2() 可以看到，虚函数表地址指向的是void Base::fun1()，往上是信息以及偏移，由于无继承，因此offset也确实为0，往下是两个虚函数，符合预期，与前文分析相同，接下来具体实践一下如何通过编程的手段来打印这个虚函数表。 要想打印这个类的虚函数表，可以采用如下方式： using FUNC = void (*)(); int main() { Base *b = new Base(); // 将b的地址转换成long long型，因为在64位编译器上面，指针占用8个字节 // b是指向虚函数表的指针的地址 auto *tmp = (long long *) b; // 对tmp解引用，得到虚函数表的地址 auto *vptr = (long long *) (*tmp); cout \u003c\u003c \"虚函数表的地址为：\" \u003c\u003c vptr \u003c\u003c endl; // 虚函数表中第一个方法，继承于父类的虚函数fun1 FUNC fun1 = (FUNC) *vptr; // 虚函数表中第二个方法 FUNC fun2 = (FUNC) *(vptr + 1); fun1(); fun2(); return 0; } 最终执行结果为： 虚函数表的地址为：0x104cb42c8 Base fun1 Base fun2 可以看到，打印出来了虚函数表的地址，并且可以直接通过这个地址区调用对应的虚函数 ","date":"2023-04-14","objectID":"/posts/c++%E5%A6%82%E4%BD%95%E6%89%93%E5%8D%B0%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E7%9A%84%E5%9C%B0%E5%9D%80/:1:3","tags":["C/C++"],"title":"C++如何打印虚函数表的地址","uri":"/posts/c++%E5%A6%82%E4%BD%95%E6%89%93%E5%8D%B0%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E7%9A%84%E5%9C%B0%E5%9D%80/"},{"categories":["设计模式"],"content":"C++的单例模式到任务队列 ","date":"2023-02-21","objectID":"/posts/%E4%BB%8Ec++%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%88%B0%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%E7%9A%84%E6%9E%84%E5%BB%BA/:1:0","tags":["设计模式","C/C++"],"title":"从C++的单例模式到任务队列的构建","uri":"/posts/%E4%BB%8Ec++%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%88%B0%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%E7%9A%84%E6%9E%84%E5%BB%BA/"},{"categories":["设计模式"],"content":"什么是单例模式？ 单例模式是设计模式中的一种，它隶属于创建型设计模式，作用是让使用者能保证该类只会存在一个实例，同时对外提供一个访问该实例的全局节点。 单例解决了两个问题： 保证一个类只有一个实例 它的运作机制是这样的：如果创建了一个对象，同时过一会决定再创建一个对象则使用者会获得之前创建的对象而不是一个新的对象，换言之——也就是保证了一个类只会存在一个实例 为什么会有人想要只有一个实例？最常见的原因是为了控制某些共享资源（例如数据库、任务队列或者文件）的访问权限。 同时还要注意，普通构造函数一定无法完成这个任务，因为构造函数的设定使得它每次使用必须返回一个新对象，因此需要一些特殊处理，暂时按下不表，后文详细介绍。 为该实例提供了一个全局访问节点 从前面的描述看起来，单例与全局变量似乎起到了一个作用，但是全局变量的使用具用极强的安全隐患，因为任何代码都有可能覆盖掉那个全局变量的内容，它只是保证了名字不变，但内容不一定始终如一，同时全局变量也无法保证这个类只有一个实例（请牢记：不要把安全隐患暴露给使用者，而应尽可能从源头遏制相关问题） 单例虽然也允许程序在任何地方访问特定对象，但它可以保护该实例不被其他代码覆盖。 另外：没有一个代码编写者希望解决同一个问题的代码分散在程序各处的，把它们放到同一个类中是一个特别好的方法，尤其是如果还有其他代码已经依赖于这个类的时候。 ","date":"2023-02-21","objectID":"/posts/%E4%BB%8Ec++%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%88%B0%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%E7%9A%84%E6%9E%84%E5%BB%BA/:1:1","tags":["设计模式","C/C++"],"title":"从C++的单例模式到任务队列的构建","uri":"/posts/%E4%BB%8Ec++%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%88%B0%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%E7%9A%84%E6%9E%84%E5%BB%BA/"},{"categories":["设计模式"],"content":"编写单例模式的解决方案 所有单例的实现一定不会跳脱出以下两个相同的步骤： 将默认构造函数设为私有， 防止其他对象使用单例类的new运算符 新建一个静态构建方法作为构造函数。 该函数会“偷偷”调用上述被设置为私有的构造函数来创建对象，并将其保存在一个静态成员变量中。 此后所有对于该函数的调用都将返回这一缓存对象。（只要能够访问单例类， 那就可以调用单例类的静态方法进而获得单例实例对象） ","date":"2023-02-21","objectID":"/posts/%E4%BB%8Ec++%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%88%B0%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%E7%9A%84%E6%9E%84%E5%BB%BA/:1:2","tags":["设计模式","C/C++"],"title":"从C++的单例模式到任务队列的构建","uri":"/posts/%E4%BB%8Ec++%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%88%B0%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%E7%9A%84%E6%9E%84%E5%BB%BA/"},{"categories":["设计模式"],"content":"编写单例模式的具体步骤 在类中添加一个私有静态成员变量用于保存单例实例 声明一个公有静态构建方法用于获取单例实例 在静态方法中实现\"延迟初始化\"。 该方法会在首次被调用时创建一个新对象， 并将其存储在静态成员变量中，此后该方法每次被调用时都返回该实例 将类的构造函数设为私有。 类的静态方法仍能调用构造函数， 但是其他对象不能调用 检查客户端代码，将对单例的构造函数的调用替换为对其静态构建方法的调用 ","date":"2023-02-21","objectID":"/posts/%E4%BB%8Ec++%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%88%B0%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%E7%9A%84%E6%9E%84%E5%BB%BA/:1:3","tags":["设计模式","C/C++"],"title":"从C++的单例模式到任务队列的构建","uri":"/posts/%E4%BB%8Ec++%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%88%B0%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%E7%9A%84%E6%9E%84%E5%BB%BA/"},{"categories":["设计模式"],"content":"使用C++实现单例模式 上文有提到，单例模式应禁止掉涉及一个类会产生新对象的构造函数，在C++中，会涉及到一个类多对象操作的函数有如下几个： 构造函数：创建一个新的对象 拷贝构造函数：根据已有对象拷贝出一个新的对象 拷贝赋值操作符重载函数：对于=的重载，用于两个对象之间的赋值操作 为了把一个类的实例化多个对象的路封死，可以进行如下处理： 构造函数私有化，使得只有类内部才能调用，并通过一定方式保证只会调用一次 考虑到使用者在类外部不能使用构造函数，所以在类内部创建的这个唯一的对象必须是静态的，这样就可以仅通过类名来进行访问，同时为了不破坏封装，一般会选择将这个静态对象的访问权限设置为私有 C++中类的静态成员变量只有其静态成员函数才可以访问，因此给这个单例类提供一个公有的静态函数来访问得到这个静态的单例对象 拷贝构造函数私有化(private\\protect)或者禁用(使用=delete后缀) 拷贝赋值操作符重载函数私有化(private\\protect)或者禁用(使用=delete后缀)，从单例的语义上讲这个函数已经毫无意义，因此类中不再提供这样一个函数，所以也将它一并处理掉 单例模式的类的模版——雏形 根据上述信息，我们给出单例模式的第一版代码： 将相关函数禁用的写法： // 定义一个单例模式的类 class Singleton { public: // = delete 代表函数禁用, 也可以将其访问权限设置为私有 Singleton(const Singleton \u0026obj) = delete; Singleton \u0026operator=(const Singleton \u0026obj) = delete; static Singleton *getInstance(); private: Singleton() = default; static Singleton *m_obj; }; 将相关函数设置为私有化的写法： // 定义一个单例模式的类 class Singleton { public: static Singleton *getInstance(); private: // = default 代表使用默认的实现 Singleton() = default; Singleton(const Singleton \u0026obj) = default; Singleton \u0026operator=(const Singleton \u0026obj) = default; static Singleton *m_obj; }; 以上就是一个单例模式的C++实现的基本雏形，首先，它有两种方案，一个是将构造函数禁用，一个是将构造函数私有化，这里要注意一点如果选用禁用构造函数的方案的话不能把所有构造函数都禁用，因为我们还是需要一个实例。 接下来，我们要注意一个细节，无论哪种方案目前有一个函数都还没有去实现，那就是getInstance()方法，通过这个方法可以获得这个类的唯一实例，同时因为要操作静态成员变量，因此这个函数也是静态成员函数，可以直接通过类名进行访问。 具体到getInstance()的实现，这里需要先引入两个概念，懒汉模式与饿汉模式: 懒汉模式：懒汉比较懒，不考虑场景，在类加载的时候就立即进行实例化，这样就得到了一个唯一的可用对象 饿汉模式：饿汉则比较乖巧，在类加载的时候（不饿）不去创建这个唯一的实例，而是在需要使用的时候（饿了）再进行实例化 从这个两个概念我们很容易看出来，懒汉模式比较简单直接，只要程序开始运行就会有这个唯一的类，而饿汉只有只有用到的时候才去创建，因此懒汉模式更适合全局要使用的对象（比如服务器的数据库连接池），而饿汉更适合局部使用的对象，同时仅在需要的时候才去创建，会更节省相应资源，这也是饿汉模式的一个优点。接下来我们看一下懒汉模式以及饿汉模式应如何编写相关代码。 单例模式的类的模版——饿汉模式 饿汉模式实现代码如下： // 懒汉模式 // 定义一个单例模式的类 class Singleton { public: // = delete 代表函数禁用, 也可以将其访问权限设置为私有 Singleton(const Singleton \u0026obj) = delete; Singleton \u0026operator=(const Singleton \u0026obj) = delete; static Singleton *getInstance() { return m_obj; } private: Singleton() = default; static Singleton *m_obj; }; Singleton *Singleton::m_obj = new Singleton; 可以看到，饿汉模式的代码非常简单，只需要直接返回私有成员变量m_obj即可，这是因为在第20行m_obj成员变量已经被定义好了，因此每次返回的都是这个唯一的成员变量。 这里注意一下，C++中类的静态成员变量在使用之前必须在类的外部进行初始化才可以使用 单例模式的类的模版——懒汉模式 有了上面的经验，我们很容易给出饿汉模式的第一版代码： // 饿汉模式 // 定义一个单例模式的类 class Singleton { public: // = delete 代表函数禁用, 也可以将其访问权限设置为私有 Singleton(const Singleton \u0026obj) = delete; Singleton \u0026operator=(const Singleton \u0026obj) = delete; static Singleton *getInstance() { if (m_obj == nullptr) { m_obj = new Singleton; } return m_obj; } private: Singleton() = default; static Singleton *m_obj; }; Singleton *Singleton::m_obj = nullptr; 也就是在getInstance()方法中对私有成员变量进行一个判断，如果是空指针那么就说明还没有使用过它，需要创建，而如果不是空指针则说明已经使用过，直接返回私有成员变量即可。 这在单线程下自然是没有问题，接下来我们进一步思考，这个实现是多线程安全的实现方式吗，很显然不是，如果有多个线程同时执行这个函数，则每一个线程都会判断m_obj是空指针，也就每个线程都会创建一个新的实例对象，换言之，在第一次使用这个单例对象时，有多少个线程同时调用这个方法就会生成多少个实例对象。这明显与预期不符。 同时我们考虑一下之前的懒汉模式有没有线程安全问题，很显然没有，因为每个线程在使用之前就已经生成了唯一的实例对象，也就不会产生新的对象。接下来我们看一下要如何修改饿汉模式的代码使它成为线程安全的实现。 双重检查锁定 想要像饿汉模式一样没有线程安全问题，就需要保证对象只有一个，解决它最常用的办法是互斥锁，通过将创建单例对象的代码使用互斥锁锁住就可以保证线程安全，代码如下： // 饿汉模式 // 定义一个单例模式的类 class Singleton { public: // = delete 代表函数禁用, 也可以将其访问权限设置为私有 Singleton(const Singleton \u0026obj) = delete; Singleton \u0026operator=(const Singleton \u0026obj) = delete; void test_print() { cout \u003c\u003c \"test success\" \u003c\u003c endl; } static Singleton *getInstance() { m_mutex.lock(); if (m_obj == nullptr) { m_obj = new Singleton; } m_mutex.unlock(); return m_obj; } private: Singleton() = default; static mutex m_mutex; static Singleton *m_obj; }; Singleton *Singleton::m_obj = nullptr; mutex Singleton::m_mutex; 看似解决了，但上面代码的15～19行被互斥锁锁住了，这就意味着无论多少个线程，只要想获得这个对象，就只能串行执行，这执行效率相比较于饿汉模式差了十万八千里，因此需要对它进行优化： // 饿汉模式 // 定义一个单例模式的类 class Singleton { public: // = delete 代表函数禁用, 也可以将其访问权限设置为私有 Singleton(const Singleton \u0026obj) = delete; Singleton \u0026operator=(const Singleton \u0026obj) = delete; void test_print() { cout \u003c\u003c \"test success\" \u003c\u003c endl; } static Singleton *getInstance() { if (m_obj == nullptr) { m_mutex.lock(); if (m_obj == nullptr) { m_obj = new Singleton; } m_mutex.unlock(); } return m_obj; } private: Singleton() = default; static mutex m_mut","date":"2023-02-21","objectID":"/posts/%E4%BB%8Ec++%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%88%B0%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%E7%9A%84%E6%9E%84%E5%BB%BA/:1:4","tags":["设计模式","C/C++"],"title":"从C++的单例模式到任务队列的构建","uri":"/posts/%E4%BB%8Ec++%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%88%B0%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%E7%9A%84%E6%9E%84%E5%BB%BA/"},{"categories":["设计模式"],"content":"一个基于单例模式的任务队列 接下来对这个单例模式进行一下实践，假设我们需要一个任务队列来接受需要完成任务并定时的处理，同时这个任务队列是全局共享的，那么使用单例模式来设计该任务队列就合情合理。 我们可以预先设计好这个队列的一些属性和方法如下： 属性： 存储任务的容器，因为任务是先进先出的(FIFO)，因此可以选用STL中的队列(queue) 互斥锁，多线程访问该队列时应保护队列中的数据的线程安全 方法： 队列判空操作 向队列中添加一个任务 从队列中取出一个任务 从队列中删除一个任务 我们还是使用饿汉模式来完成这个任务队列，代码如下： 首先我们预先准备一组任务类，假设有两种任务分别为A和B，代码实现如下： class Task { public: virtual void work() = 0; virtual std::string get_attribute() = 0; }; class Task_A : public Task { public: void work() override { std::cout \u003c\u003c \"已经执行完成任务A\" \u003c\u003c std::endl; } std::string get_attribute() override { return \"Task A\"; } }; class Task_B : public Task { public: void work() override { std::cout \u003c\u003c \"已经执行完成任务B\" \u003c\u003c std::endl; } std::string get_attribute() override { return \"Task B\"; } }; 任务队列代码实现如下： class TaskQueue { public: TaskQueue(const TaskQueue \u0026t) = delete; TaskQueue \u0026operator=(const TaskQueue \u0026t) = delete; static TaskQueue *getTaskQueue() { static TaskQueue taskQueue; return \u0026taskQueue; } // 队列判空 bool empty() { std::lock_guard\u003cstd::mutex\u003e locker(m_mutex); return m_queue.empty(); } // 添加任务 void push_task(Task *task) { std::lock_guard\u003cstd::mutex\u003e locker(m_mutex); m_queue.push(task); } // 删除任务 bool pop_task() { std::lock_guard\u003cstd::mutex\u003e locker(m_mutex); if (m_queue.empty()) { return false; } m_queue.pop(); return true; } // 获取队头任务 Task *get_task() { std::lock_guard\u003cstd::mutex\u003e locker(m_mutex); if (m_queue.empty()) { return nullptr; } return m_queue.front(); } private: TaskQueue() = default; std::queue\u003cTask *\u003e m_queue; std::mutex m_mutex; }; 最终测试代码如下： int main() { // 生产者：基数次生产A任务，偶数次生产B任务 std::thread t1([]() { auto q = TaskQueue::getTaskQueue(); for (int i = 1; i \u003c= 10; ++i) { if (i \u0026 1) { q-\u003epush_task(new Task_A); } else { q-\u003epush_task(new Task_B); } cout \u003c\u003c \"+++push task: \" \u003c\u003c i \u003c\u003c \", threadID: \" \u003c\u003c this_thread::get_id() \u003c\u003c endl; this_thread::sleep_for(chrono::milliseconds(500)); } }); // 消费者 std::thread t2([]() { auto q = TaskQueue::getTaskQueue(); while (!q-\u003eempty()) { auto task = q-\u003eget_task(); if (task) { task-\u003ework(); q-\u003epop_task(); } this_thread::sleep_for(chrono::seconds(1)); } }); t1.join(); t2.join(); return 0; } 代码执行结果如下： push task: 1, threadID: 0x16f987000 已经执行完成任务A push task: 2, threadID: 0x16f987000 已经执行完成任务B push task: 3, threadID: 0x16f987000 push task: 4, threadID: 0x16f987000 已经执行完成任务A push task: 5, threadID: 0x16f987000 push task: 6, threadID: 0x16f987000 已经执行完成任务B push task: 7, threadID: 0x16f987000 push task: 8, threadID: 0x16f987000 已经执行完成任务A push task: 9, threadID: 0x16f987000 push task: 10, threadID: 0x16f987000 已经执行完成任务B 已经执行完成任务A 已经执行完成任务B 已经执行完成任务A 已经执行完成任务B 正常情况的任务队列的work函数肯定要复杂很多，这里用文本输出替代 任务队列中的互斥锁保护的是队列的数据（也就是任务），之前单例中说的线程安全是保障一个单例对象只会被创建一次，是不一样的 ","date":"2023-02-21","objectID":"/posts/%E4%BB%8Ec++%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%88%B0%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%E7%9A%84%E6%9E%84%E5%BB%BA/:1:5","tags":["设计模式","C/C++"],"title":"从C++的单例模式到任务队列的构建","uri":"/posts/%E4%BB%8Ec++%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%88%B0%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%E7%9A%84%E6%9E%84%E5%BB%BA/"},{"categories":["算法模版"],"content":"前缀和与差分 前缀和与差分互为逆运算，本质上是一种思想而不是一种模版，对于一段问题的求解有奇效 ","date":"2023-01-03","objectID":"/posts/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/:1:0","tags":["数据结构与算法","算法模版"],"title":"前缀和与差分算法模版","uri":"/posts/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"},{"categories":["算法模版"],"content":"前缀和 一维前缀和：给定一个数组，来查询[l, r]中所有数字的和，一共查询m次 #include \u003ciostream\u003e #include \u003ccstring\u003e #include \u003calgorithm\u003e #include \u003cvector\u003e using namespace std; int main() { int n, m; cin \u003e\u003e n \u003e\u003e m; vector\u003cint\u003e nums(n, 0); for (int i = 0; i \u003c n; ++i) cin \u003e\u003e nums[i]; nums.insert(nums.begin(), 0); vector\u003cint\u003e sums(n + 1, 0); for (int i = 1; i \u003c= n; ++i) { sums[i] = sums[i - 1] + nums[i]; } while (m--) { int l, r; cin \u003e\u003e l \u003e\u003e r; cout \u003c\u003c sums[r] - sums[l - 1] \u003c\u003c endl; } return 0; } 二维前缀和：与一维很相似，只是表示的变成一块区域[左上, 右下]的矩形内部所有元素的和 #include \u003ciostream\u003e #include \u003ccstring\u003e #include \u003calgorithm\u003e #include \u003cvector\u003e using namespace std; // 获取前缀和的模版 int get_sum(vector\u003cvector\u003cint\u003e\u003e\u0026 sums, int x, int y) { int m = sums.size(), n = sums[0].size(); if (x \u003c 0 || y \u003c 0 || x \u003e= m || y \u003e= n) return 0; return sums[x][y]; } // 求区域和的模版 int get(vector\u003cvector\u003cint\u003e\u003e\u0026 sums, int x1, int y1, int x2, int y2) { return get_sum(sums, x2, y2) - get_sum(sums, x2, y1 - 1) - get_sum(sums, x1 - 1, y2) + get_sum(sums, x1 - 1, y1 - 1); } int main() { int m, n, q; cin \u003e\u003e m \u003e\u003e n \u003e\u003e q; vector\u003cvector\u003cint\u003e\u003e nums(m, vector\u003cint\u003e (n, 0)); for (int i = 0; i \u003c m; ++i) { for (int j = 0; j \u003c n; ++j) { cin \u003e\u003e nums[i][j]; } } // 构造前缀和的模版 vector\u003cvector\u003cint\u003e\u003e sums(m, vector\u003cint\u003e(n, 0)); for (int i = 0; i \u003c m; ++i) { for (int j = 0; j \u003c n; ++j) { sums[i][j] = get_sum(sums, i - 1, j) + get_sum(sums, i, j - 1) - get_sum(sums, i - 1, j - 1) + nums[i][j]; } } while (q--) { int x1, y1, x2, y2; cin \u003e\u003e x1 \u003e\u003e y1 \u003e\u003e x2 \u003e\u003e y2; // x1--, y1--, x2--, y2--; cout \u003c\u003c get(sums, x1, y1, x2, y2) \u003c\u003c endl; } return 0; } ","date":"2023-01-03","objectID":"/posts/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/:1:1","tags":["数据结构与算法","算法模版"],"title":"前缀和与差分算法模版","uri":"/posts/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"},{"categories":["算法模版"],"content":"差分 对于数组$A_n = [a_1, a_2, a_3, … , a_n]$，构造数组$B_n = [b_1, b_2, b_3, …, b_n]$使得$a_i = b_1 + b_2 + b_3 + … + b_i$，换言之使得$A_n$数组是$B_n$数组的前缀和 对于一维数组的构造：（构造本身没那么重要，理解他俩的关系即可，因为对于所有的原始数组都可以认为本来是0，然后里面的初始值是影响） $b_1 = a_1$ $b2 = a_2 - a_1$ $b_3 = a_3 - a_3$ … $b_4 = a_4 - a_3$ 对于这样的数组$B_n$就称数组$B_n$是数组$A_n$的差分，大多数时候是通过数组$B_n$来求数组$A_n$，一般是利用$B_n$对数组$A_n$的影响来解题，比如对于一段数组希望在[l, r]这个区间内所有的数字加上C，则对于差分数组$B_n$对l进行加C操作，而对r + 1执行-C再对差分数组求前缀和，得到的结果就是全部加上了C，使用这个算法可以对多重影响一起求解。 #include \u003ciostream\u003e #include \u003ccstring\u003e #include \u003calgorithm\u003e #include \u003cvector\u003e using namespace std; int main() { int n, m; // n个数字，m行操作 cin \u003e\u003e n \u003e\u003e m; vector\u003cint\u003e nums(n + 1, 0); vector\u003cint\u003e diff(n + 1, 0); for (int i = 1; i \u003c= n; ++i) { cin \u003e\u003e nums[i]; diff[i] += nums[i]; diff[i + 1] -= nums[i]; } // m行操作，对[l, r]区间内的所有数字进行加C的操作 while (m--) { int l, r, c; cin \u003e\u003e l \u003e\u003e r \u003e\u003e c; diff[l] += c; diff[r + 1] -= c; } for (int i = 1; i \u003c= n; ++i) { diff[i] += diff[i - 1]; cout \u003c\u003c diff[i] \u003c\u003c ' '; } cout \u003c\u003c endl; return 0; } 对于二维数组来说也是一样的，是给一个子矩阵给上一个值（一个影响） #include \u003ciostream\u003e #include \u003ccstring\u003e #include \u003calgorithm\u003e #include \u003cvector\u003e using namespace std; void insert(vector\u003cvector\u003cint\u003e\u003e\u0026 sums, int x1, int y1, int x2, int y2, int c) { sums[x1][y1] += c; sums[x1][y2 + 1] -= c; sums[x2 + 1][y1] -= c; sums[x2 + 1][y2 + 1] += c; } int main() { int m, n, q; cin \u003e\u003e m \u003e\u003e n \u003e\u003e q; vector\u003cvector\u003cint\u003e\u003e nums(m, vector\u003cint\u003e (n, 0)); vector\u003cvector\u003cint\u003e\u003e sums(m + 2, vector\u003cint\u003e (n + 2, 0)); for (int i = 0; i \u003c m; ++i) { for (int j = 0; j \u003c n; ++j) { cin \u003e\u003e nums[i][j]; insert(sums, i + 1, j + 1, i + 1, j + 1, nums[i][j]); } } while (q--) { int x1, y1, x2, y2, c; cin \u003e\u003e x1 \u003e\u003e y1 \u003e\u003e x2 \u003e\u003e y2 \u003e\u003e c; insert(sums, x1, y1, x2, y2, c); } for (int i = 1; i \u003c= m; ++i) { for (int j = 1; j \u003c= n; ++j) { sums[i][j] += sums[i][j - 1] + sums[i - 1][j] - sums[i - 1][j - 1]; cout \u003c\u003c sums[i][j] \u003c\u003c ' '; } cout \u003c\u003c endl; } return 0; } ","date":"2023-01-03","objectID":"/posts/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/:1:2","tags":["数据结构与算法","算法模版"],"title":"前缀和与差分算法模版","uri":"/posts/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"},{"categories":["C/C++"],"content":"现代C++中的类型推导 C++起源于C语言，因此具有许多与C相同的特性，比如最重要的C++与C都是强类型语言，也就意味着每次在声明一个变量的时候需要明确该变量的类型，比如：int a = 1024;，C语言由于语法相对简单，这样的声明对于程序员并不会造成太大的负担，但随着C++的发展，尤其是随着标准库中对于模版使用的推广，每次都要求对类型就行明确的指定会对程序员造成极大的负担，比如对于一个map的迭代器，如果不使用类型推导，则可能的形式是这样的 std::map\u003cint, std::string\u003e m = {{1, \"a\"}, {2, \"b\"}}; std::map\u003cint, std::string\u003e::const_iterator it = m.begin(); // 看起来就好累，而且并不直观 而如果使用类型推导，则上述代码形式可以变为： std::map\u003cint, std::string\u003e m = {{1, \"a\"}, {2, \"b\"}}; auto it = m.begin(); 可以看出来，对于现代C++中的一些类，使用确定的类型声明即麻烦还不清晰，反而使用auto关键字声明变量会更清晰也更简单，比如对于上述的这个例子，我们都知道他就是m的开始的迭代器，但如果进行类型声明，反而一开始并不知道它要表述的是什么意思，要阅读好长好长的代码才知道：噢，这是个迭代器。 而事实上，类型推导其实并不“现代”，C++ 之父 Bjarne Stroustrup（B·S ) 早在 C++ 诞生之初就设计并实现了它，但因为与早期 C 语言的语义有冲突，所以一直没有正式作为C++的语言特性，而知道C99消除了兼容性问题，C++11才正式引入类型推导。而随着逐渐进入现代C++的时代之后，类型推导的应用愈加广泛，从简单的auto到C++的模版编程，再到C++14引入的decltype，因此对于类型推导进行详细的学习是非常有必要的。 ","date":"2022-12-14","objectID":"/posts/%E7%8E%B0%E4%BB%A3c++%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/:0:0","tags":["C++语法"],"title":"现代C++中的类型推导","uri":"/posts/%E7%8E%B0%E4%BB%A3c++%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/"},{"categories":["C/C++"],"content":"理解模版的类型推导 auto关键字的出现起源于模版，可以说，模版是auto的基础，首先我们来回顾一下模版的基本形式： // 模版函数的声明 template\u003ctypename T\u003e void f(ParamType param); // 模版函数的调用 f(expr); // 通过某种表达式调用f 在编译期内，编译器会通过expr进行推导两个类型：一个是T的类型，一个是ParamType的类型，需要注意的是这两个类型大多数的时候并不一样（因为大多数时候ParamType中会有对于T的一些限定，比如const比如\u0026。 例如，对于下面这个例子T和ParamType就不相同： template\u003ctypename T\u003e void f(const T\u0026 param); 在这个例子中，param的类型就是const T\u0026，在调用的过程中，比如使用int x = 0; f(x);来对这个例子进行调用，那么T就会被推导为int而ParamType则被推导为const int\u0026，在进行类型推导的时候，模版会根据f(expr)中的expr的情况以及**ParamType的形式**分别推导出T的类型以及ParamType的类型。 这里，将它分为三种情况： ParamType具有指针或者引用型别，但不是万能引用 ParamType是一个万能引用 ParamType既非指针也非引用 ","date":"2022-12-14","objectID":"/posts/%E7%8E%B0%E4%BB%A3c++%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/:1:0","tags":["C++语法"],"title":"现代C++中的类型推导","uri":"/posts/%E7%8E%B0%E4%BB%A3c++%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/"},{"categories":["C/C++"],"content":"情况一：ParamType具有指针或者引用型别，但不是万能引用 在这种情况下，模版的类型推导运作机制如下： 若expr具有引用型别，先将引用部分忽略 然后对expr和ParamType的型别执行模式匹配，最终根据结果决定T的型别 在如下这个例子中，用三种不同的变量输入到f中，得到的类型推导结果不相同： template\u003ctypename T\u003e void f(T\u0026 param); // 给出三个变量 int x = 0; // x是int类型 const int x2 = x; // x2是const int类型 const int\u0026 x3 = x; // x3是const int的引用类型 // 输入到f中 f(x); // T被推导为int，ParamType被推导为int\u0026 f(x2); // T被推导为const int，ParamType被推导为const int\u0026 f(x3); // T被推导为const int，ParamType被推导为const int\u0026 通过这个例子，可以得出以下几条结论： 在ParamType具有指针或者引用的情况下，类型推导的过程先找到对应的expr的形式，根据expr的形式推导出来T的格式，再根据模版中expr所写的格式推导出paramType的类型 在上述的过程中，有两个地方要注意，一个是向T\u0026类型的模版传入const对象是安全的，const属性会被推导到T的类型中；另一个就是传入的变量本身就是引用的话它的引用性会被忽略，T不会被推导为引用 上述例子是左值引用形参，但右值引用形参的推导与左值完全相同，唯一的区别就是传给右值引用形参的变量只能是右值引用实参（不过这个限制其实跟类型推导没有什么关系，这是右值的特点） ","date":"2022-12-14","objectID":"/posts/%E7%8E%B0%E4%BB%A3c++%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/:1:1","tags":["C++语法"],"title":"现代C++中的类型推导","uri":"/posts/%E7%8E%B0%E4%BB%A3c++%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/"},{"categories":["C/C++"],"content":"情况二：ParamType是个万能引用 对于万能引用，情况表现如下： 如果expr是左值，则T和ParamType会被推导为左值引用，要注意这是在模版类型推导中**T会被推导为引用的唯一情况**，另外虽然ParamType的形式是右值引用语法，但最后推导的结果是左值引用； 如果expr是右值，则应用情况一的规则即可 template\u003ctypename T\u003e void f(T\u0026\u0026 param); // param现在是万能引用 // 给出三个变量 int x = 0; // x是int类型 const int x2 = x; // x2是const int类型 const int\u0026 x3 = x; // x3是const int的引用类型 // 输入到f中 f(x); // x是左值，T被推导为int\u0026，ParamType被推导为int\u0026 f(x2); // x2是左值，T被推导为const int\u0026，ParamType被推导为const int\u0026 f(x3); // x3是左值引用，T被推导为const int\u0026，ParamType被推导为const int\u0026 f(0); // 0是个右值，T被推导为int\u0026\u0026，ParamType被推导为int\u0026\u0026 ","date":"2022-12-14","objectID":"/posts/%E7%8E%B0%E4%BB%A3c++%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/:1:2","tags":["C++语法"],"title":"现代C++中的类型推导","uri":"/posts/%E7%8E%B0%E4%BB%A3c++%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/"},{"categories":["C/C++"],"content":"情况三：ParamType按值传递 当ParamType既不是指针也不是引用的时候，那就是按照值传递，按照值传递就意味着无论怎么传递最终传入的都是一个副本，最终推导规则如下： 如果expr是引用，则忽略引用的部分 忽略引用性质之后，如果expr是const则也忽略const，另外如果是volatile对象，也一同忽略volatile性质；这就导致一个很重要的特点：不能因为expr是一个常量则认为param也是一个常量，常量的副本是可以修改的 对于指针，考虑到常量指针与指针常量的特殊性，如果param的类型是一个指针，则类型推导的时候会忽略param指针本身的常量性而保留指针指向对象的常量性，换句话说常量指针会被正常推导，指针常量则会被推导为普通指针 数组实参 对于数组实参，情况略有不同，在C/C++中数组作为参数传递会有点特殊，因为数组会退化（数组会变成首元素的指针然后再作为参数进行传递），看一下下面这个例子： const char str[] = \"hello, world\"; // str的类型是const char[13] const char* strToPtr = str; // 数组退化成指针 事实上，str和strToPtr这两个变量的类型并不统一，但能编译成功的原因就在于数组退化成了指针然后指针可以传递。而在模版推导中，不能把他俩完全的等价，这里有一个很重要的特性：尽管函数无法声明真正的数组类型的形参，但却能够将形参声明为数组的引用，比如对于下面这个例子： template\u003ctypename T\u003e void f(T\u0026 param); f(str); // 向f传递一个数组 这种情况下，T会被推导为const char [13]，而ParamType则会被推导为const char (\u0026)[13]，这里就可以利用这个模版特性去做一些魔法🪄，比如可以在编译器确定数组的长度。 template\u003ctypename T, std::size_t N\u003e constexpr std::size_t arraySize(T (\u0026)[N]) noexcept { return N; } 通过这种设计，就可以在编译器使用一个数组的大小来设定另一个数组的大小，比如： int nums[] = {1,2,3,4,5}; int nums2[arraySize(nums)]; // nums2的大小会与nums相同 函数实参 对于函数而言，函数传递给一个形参，函数也会退化为指针，函数的模版推导结果可以参考下面这个例子： template\u003ctypename T\u003e void f1(T param); template\u003ctypename T\u003e void f2(T\u0026 param); void func(int, int); // func是一个函数，类型为void (int, int) f1(func); // func退化为指针，T和ParamType类型均推导为void (*)(int, int) f2(func); // func是函数引用，T的类型为void (int, int)，而ParamType的类型则为void (\u0026)(int, int) 模版推导总结： 在模版类型推导的过程中，具有引用类型的实参会被当作非引用类型来处理（引用的忽略性） 对万能引用形参进行推导时，左值实参会特殊处理 对按值传递的形参进行推导时，const和volatile会被忽略 在模版类型推导过程中，函数或数组的实参会退化为对应的指针，除非它们被用来初始化引用 ","date":"2022-12-14","objectID":"/posts/%E7%8E%B0%E4%BB%A3c++%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/:1:3","tags":["C++语法"],"title":"现代C++中的类型推导","uri":"/posts/%E7%8E%B0%E4%BB%A3c++%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/"},{"categories":["C/C++"],"content":"理解auto的类型推导 auto是现代C++中最常用的特性之一，它就像是一个占位符，写上它，就可以让编译器去自动填上它应具有的类型名称，举几个很简单的例子： auto i = 1024; // 自动推导为int类型 auto x = 1024.0; // 自动推导为double类型 auto str = \"hello, world\"; // 自动推导为const char*类型 auto f = bind1st(std::less\u003cint\u003e(), 2); // 自动推导出类型，具体是啥不知道，反正很复杂不好写 当然auto也不是万能的，它也会有无法推导的情况存在： std::map\u003cint, std::string\u003e mp = {{1,\"a\"}, {2,\"b\"}}; // 自动推导不出来 // auto mp = {{1,\"a\"}, {2,\"b\"}}; // 报错：Cannot deduce actual type for variable 'mp' with type 'auto' from initializer list auto iter = mp.begin(); // 自动推导为map内部的迭代器类型 当存在一定的歧义的时候，编译器就会报错，避免进行错误的推导，就比如上面这个例子，如果不加以限制，那么把mp的类型推导为std::vector\u003cstd::pair\u003cint, std::string\u003e\u003e\u003e也是毫无问题的，但如果这样子推导了后面所有的代码都会以程序员意料之外的方式进行，这就会导致很多莫名其妙的问题，因此，通过有歧义直接不推导的方式也规避了许多的风险，但这并不意味着就可以随意去用auto了，作为优秀的C++程序员仍然非常有必要了解一下auto类型推导的规则。 ","date":"2022-12-14","objectID":"/posts/%E7%8E%B0%E4%BB%A3c++%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/:2:0","tags":["C++语法"],"title":"现代C++中的类型推导","uri":"/posts/%E7%8E%B0%E4%BB%A3c++%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/"},{"categories":["C/C++"],"content":"auto类型推导规则 从一定程度上来说，理解了最前面所讲的模版类型推导中的情况一就基本上覆盖了auto类型推导99%的规则了，因为除了一种情况以外，auto的推导规则与情况一的推导规则完全相同。接下来我们就来看看auto与情况一之间的联系以及它在特殊的情况下的推导规则。 常规情况 在模版推导中，我们使用了例子： template\u003ctypename T\u003e void f(ParamType param); // 调用 f(expr); // 以某表达式来调用模版函数，进而推测出T和ParamType的类型 而当某变量使用auto进行推导时，auto就会扮演模版中T的这个角色，而变量的类型修饰词（特定修饰+auto）则扮演了ParamType的角色，比如在下面这个例子中： auto x = 1024; // x的类型修饰词就是auto本身 const auto x2 = x; // x的类型修饰词就是const auto const auto\u0026 x3 = x2; // x的类型修饰词就是const auto\u0026 而在推导上述的变量类型时，编译器就会像是进行了一次模版编程一样，会将auto与类型修饰词对应到模版中进行相同规则的类型推导，就像如下展示的代码一样： // 注意：⚠️仅仅是像这里展示的一样，并不是真的进行了这种编译 template\u003ctypename T\u003e void func_for_x(T param); func_for_x(1024); // 推导出来x的类型是int template\u003ctypename T\u003e void func_for_x2(const T param); func_for_x2(x); // 推导出来x2的类型是const int template\u003ctypename T\u003e void func_for_x3(const T\u0026 param); func_for_x3(x2); // 推导出来x3的类型是const int\u0026 按照情况一中的推导规则很容易得出结果，这个结果跟我们感性预想的也是相同的，同时也可以将auto推导与模版推导中对ParamType分类类似地进行一下分类： 类型修饰词是指针或者引用，但不是万能引用 类型修饰词是万能引用 类型修饰词即非指针也非引用 【1】和【3】在之前例子有见过： auto x = 1024; // 3.非指针也非引用 const auto x2 = x; // 3.非指针也非引用 const auto\u0026 x3 = x2; // 1.指针或引用但非万能引用 对于【2】，其运作方式也符合感性认知： auto\u0026\u0026 uref1 = x; // x是int且是左值，uref1类型为int\u0026 auto\u0026\u0026 uref2 = x2; // x2是const int，也是左值，因此uref2类型为const int\u0026 auto\u0026\u0026 uref3 = x3; // x3是const int\u0026，也是左值，因此uref3类型为const int\u0026 auto\u0026\u0026 uref4 = 1024; // 1024是int且是右值，因此uref4的类型为int\u0026\u0026 对于C风格的数组会退化成指针这种情况，auto也完全符合模版推导中的规则： const char str[] = \"Hello, world\"; // str的类型是const char[13] auto arr1 = name; // arr1的类型是const char* auto\u0026 arr2 = name; // arr2的类型是const char (\u0026)[13] void somFunc(int, double); // someFunc是函数，类型为void(int, double) auto func1 = someFunc; // func1的类型为void (*)(int, double) auto\u0026 func2 = someFunc; // func2的类型为void (\u0026)(int, double) 特殊情况 接下来看一下auto可能会导致出错的一种特殊情况，在传统的C++98中，如果我们要声明一个int并进行初始化，我们有如下两种方法： int x = 27; // 最标准的做法，C风格 int x2(27); // C++风格的初始化 而在现代C++中，从C++11开始，为了支持统一初始化，C++增加了下面的语法选项： int x3 = {27}; int x4{27}; 截止目前为止，可以使用四种方式对一个变量进行初始化，而如果我们把int替换成auto，那么结果却会与想像中不一样 auto x = 27; // 没问题，x是int类型 auto x2(27); // 没问题，x是int类型 auto x3 = {27}; // 出现问题，x3不是int类型 auto x4{27}; // 出现问题，x4不是int类型 使用C++98的语法进行auto替换不会存在问题，但如果使用现代C++中新增的方法则推导出来的结果会是std::initializer_list\u003cint\u003e，并且这个列表中有一个元素，值为27 这是auto类型推导中比较特殊的一种情况，当使用大括号括起来时，推导所属类型就会变成std::initializer_list 在这种情况下，就会对列表中的元素类型要求统一，因为std::initializer_list\u003cT\u003e其实也是一个模版，因此如果大括号中的元素类型不一致，就无法推导出T的类型。 同时需要单独记忆的一点就是，在类型推导中std::initializer_list这个类型只会被auto推导，模版无法推导： auto x = {1, 2, 3}; // 推导没有问题，x类型是std::initializer_list\u003cint\u003e template\u003ctypename T\u003e void func(T param); f({1, 2, 3}); // 推导失败，无法推导出T的类型 void func2(std::vector\u003cint\u003e test); func2({1, 2, 3}); // 可行，会通过std::initializer_list\u003cint\u003e初始化一个std::vector template\u003ctypename T\u003e void func3(std::initializer_list\u003cT\u003e list); func3({1, 2, 3}); // 可行，确定输入的类型是std::initializer_list\u003cT\u003e，推导T的类型是没有问题的 一些全新特性 C++11的特性就全部结束了，但在C++14中，C++委员会又赋予了auto更多的能力 C++14允许使用auto来说明函数返回值需要推导： // 可以推导返回的类型，推导结果为int auto func() { return 0; } // 推导返回的类型失败，这里auto不会执行它的特殊情况，而是与模版推导的结果相同，需要单独记忆比较烦 auto func2() { return {1, 2, 3}; } C++14中lambda表达式也允许形参中用到auto，同时执行推导的规则也是按照模版推导的规则来的： std::vector\u003cint\u003e v; /* ... */ auto lambda1 = [\u0026v](const auto\u0026 value) {v.push_back(value);}; // 没有问题 // lambda1的类型推导为void (const int\u0026) const // value的类型推导为const int\u0026 /* ... */ auto lambda2 = [\u0026v](const auto\u0026 value) {v = value;}; // 重置v的函数 lambda2({1, 2, 3}); // 类型推导失败，无法推导出{1, 2, 3}的类型 以上就是auto的全部内容啦，然后最后我们来看一下C++的新特性：decltype ","date":"2022-12-14","objectID":"/posts/%E7%8E%B0%E4%BB%A3c++%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/:2:1","tags":["C++语法"],"title":"现代C++中的类型推导","uri":"/posts/%E7%8E%B0%E4%BB%A3c++%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/"},{"categories":["C/C++"],"content":"理解delctype的类型推导 delctype是用来获得某个变量其类型的方法，但对于这个方法使用的时候要慎重，虽然大多数时候都可以获得正确的结果，但有时候获得的结果也会有点让人迷惑不太正确，下面我们就来具体看看delctype的运行规则。 ","date":"2022-12-14","objectID":"/posts/%E7%8E%B0%E4%BB%A3c++%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/:3:0","tags":["C++语法"],"title":"现代C++中的类型推导","uri":"/posts/%E7%8E%B0%E4%BB%A3c++%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/"},{"categories":["C/C++"],"content":"delctype的一般情况 和模版以及auto的类型推导过程相反，delctype不太可以归属到类型推导中去，它更像是鹦鹉学舌，返回给定的名字或表达式的确切类型，这里直接使用《Effective Modern C++》中的例子： const int i = 0; // decltype(i) 是const int bool f(const Widget\u0026 w); // decltype(w) 是 const Widget\u0026 // decltype(f) 是 bool(const Widget\u0026) struct Point { int x, y; // decltype(Point::x) 是 int }; // decltype(Point::y) 是 int Widget w; // decltype(w) 是 Widget if (f(w)) … // decltype(f(w)) 是 bool template\u003ctypename T\u003e class vector { // std::vector的简化版 public: … T\u0026 operator[](std::size_t index); … }; vector\u003cint\u003e v; // decltype(v) 是 vector\u003cint\u003e … if (v[0] == 0) // decltype(v[0]) 是 int\u0026 … C++11中，decltype的主要用途大概就在于声明那些返回值类型依赖于形参类型的函数模版 举个例子，同时也补充一个auto的用法，这个auto与类型推导就没有关系，只是为了符合返回值类型尾序语法规则，这种语法使得返回值在形参列表之后，它的好处就在于可以配合decltype来使用模版推导中形参的类型结果作为返回类型： template\u003ctypename Container, typename Index\u003e auto process(Container\u0026 c, Index i) -\u003e decltype(c[i]) { /* 处理逻辑 */ return c[i]; } 而到C++14中后，这个语法变得更加简单了，可以去掉尾序的部分： template\u003ctypename Container, typename Index\u003e // 错误版本：因为模版推导中，初始化表达的引用性会被忽略，返回的类型会是int而不是我们期待的int\u0026 auto process(Container\u0026 c, Index i) { /* 处理逻辑 */ return c[i]; } // C++14中使用decltype(auto)解决了这个问题，本质上就是auto指定了想要实施自动推导返回类型，然后decltype表明使用的规则是decltype的推导规则 // 修订版本⬇️ template\u003ctypename Container, typename Index\u003e decltype(auto) process(Container\u0026 c, Index i) { /* 处理逻辑 */ return c[i]; // 返回类型是int\u0026 } // decltype(auto)这种方式也可以在普通语句中使用 int t = 1; const int\u0026 t2 = t; auto t3 = t2; // t3是auto类型推导，是int类型 decltype(auto) t4 = t2; // t4是decltype类型推导，是const int\u0026类型 ","date":"2022-12-14","objectID":"/posts/%E7%8E%B0%E4%BB%A3c++%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/:3:1","tags":["C++语法"],"title":"现代C++中的类型推导","uri":"/posts/%E7%8E%B0%E4%BB%A3c++%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/"},{"categories":["C/C++"],"content":"decltype的特殊情况 主要考虑一种特殊情况，首先再回忆一下decltype的工作方式，在decltype后面的括号中填入变量名称，然后会根据这个变量的定义返回一个类型，但这个变量的名称其实是有一定可能会出现一些问题的。 主要是因为，decltype(x)中的x是一个变量名称，而x和(x)在我们的感性认知中应该是相同，同时在C++中(x)也被定义为一个左值，因此也就支持decltype((x))这种写法，这就会导致出错，因为x和(x)其实是不同的： int x = 1024; decltype(x); // 返回结果是int，符合预期 decltype((x)); // 推导的是(x)的类型，最终推导结果是int\u0026，不符合预期，一定要规避这个问题 包括在使用decltype(auto)时，也一定要注意这个问题 decltype(auto) f1() { int x = 1024; /* ... */ return x; } decltype(auto) f2() { int x = 1024; /* ... */ return (x); // !!!非常危险⚠️，最终返回的是一个局部变量的引用，当去使用的时候会造成UB } ","date":"2022-12-14","objectID":"/posts/%E7%8E%B0%E4%BB%A3c++%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/:3:2","tags":["C++语法"],"title":"现代C++中的类型推导","uri":"/posts/%E7%8E%B0%E4%BB%A3c++%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/"},{"categories":["Linux"],"content":"Linux中的信号量 ","date":"2022-09-03","objectID":"/posts/linux%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E9%87%8F/:0:0","tags":["Linux"],"title":"Linux中的信号量","uri":"/posts/linux%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E9%87%8F/"},{"categories":["Linux"],"content":"信号量的概念 信号量本质上是一个计数器，用于协调多个进程（包括但不限于父子进程）或多个线程对共享数据对象的读/写。它不以传送数据为目的，一般会有两种作用： 用来保护共享资源（共享内存、消息队列、socket连接池、数据库连接池等），保证共享资源在一个时刻只有一个进程独享，类似于互斥锁的操作 用来实现生产者-消费者模型，其中生产者每生产一个对象对信号量+1，消费者每消费一个对象对信号量-1，如果没有可以被消费的对象则阻塞等待 信号量是一个特殊的变量，只允许进程（线程）对它进行等待信号和发送信号操作。最简单的信号量是取值0和1的二元信号量，这是信号量最常见的形式。 ","date":"2022-09-03","objectID":"/posts/linux%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E9%87%8F/:1:0","tags":["Linux"],"title":"Linux中的信号量","uri":"/posts/linux%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E9%87%8F/"},{"categories":["Linux"],"content":"Linux中的信号量使用 在Linux中，信号量有着两种实现：「传统的Systm V信号量」和「POSIX信号量」 对于这两种信号量在系统所提供的函数中很容易进行区分： 所有的Systm V信号量的函数名中没有下划线，例如semget()而不是sem_get() 相对应的，所有的POSIX信号量函数都有下划线 另外，对于POSIX信号量，可以有命名的信号量，例如信号量有一个文件关联他们 比如在下面对照表中的POSIX最后三个函数就是用来关闭、打开、删除这样一个命名的信号量，而sem_destroy()和sem_init()仅仅供非命名信号量使用 Systm V POSIX semctl() sem_getvalue() semget() sem_post() semop() sem_timedwait() sem_trywait() sem_wait() sem_destroy() sem_init() sem_close() sem_open() sem_unlink() 引用一下网上对于这两者使用时的结论： POSIX信号量来源于POSIX技术规范的实时扩展方案(POSIX Realtime Extension)，常用于线程（但其有名信号量也可用于进程）；system v信号量，常用于进程的同步。 这两者非常相近，但它们使用的函数调用各不相同。前一种的头文件为semaphore.h，函数调用为sem_init()，sem_wait()，sem_post()，sem_destory()等等。后一种头文件为sys/sem.h，函数调用为semctl()，semget()，semop()等函数 ","date":"2022-09-03","objectID":"/posts/linux%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E9%87%8F/:2:0","tags":["Linux"],"title":"Linux中的信号量","uri":"/posts/linux%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E9%87%8F/"},{"categories":["Linux"],"content":"System V信号量的使用 ","date":"2022-09-03","objectID":"/posts/linux%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E9%87%8F/:3:0","tags":["Linux"],"title":"Linux中的信号量","uri":"/posts/linux%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E9%87%8F/"},{"categories":["Linux"],"content":"头文件 #include \u003csys/types.h\u003e #include \u003csys/ipc.h\u003e #include \u003csys/sem.h\u003e ","date":"2022-09-03","objectID":"/posts/linux%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E9%87%8F/:3:1","tags":["Linux"],"title":"Linux中的信号量","uri":"/posts/linux%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E9%87%8F/"},{"categories":["Linux"],"content":"semget函数 作用：得到一个信号量集标识符或创建一个信号量集对象并返回信号量集标识符 函数原型： int semget(key_t key, int nsems, int semflg); 参数： key是信号量的键值，（类型定义：typedef unsigned int key_t），是信号量在系统中的编号，不同信号量的编号不能相同，这一点由程序员保证。key用十六进制表示比较好，便于查看和管理 nsems是创建信号量集中信号量的个数，该参数只在创建信号量集时有效，其他情况填1即可 semflag是一组标志，如果希望信号量不存在时创建一个新的信号量，可以和值IPC_CREAT做按位或操作。如果没有设置IPC_CREAT标志并且信号量不存在，就会返错误（errno的值为2，No such file or directory）。 返回值： 成功：返回信号量集的标识 失败：返回-1，并设置errno 错误代码： EACCESS：没有权限 EEXIST：信号量集已经存在，无法创建 EIDRM：信号量集已经删除 ENOENT：信号量集不存在，同时semflg没有设置IPC_CREAT标志 ENOMEM：没有足够的内存创建新的信号量集 ENOSPC：超出限制 如果semget创建了一个新的信号量集对象，则semid_ds结构成员变量的值设置如下： sem_otime设置为0 sem_ctime设置为当前时间 msg_qbytes设成系统的限制值 sem_nsems设置为nsems参数的数值 semflg的读写权限写入sem_perm.mode中 sem_perm结构的uid和cuid成员被设置成当前进程的有效用户ID，gid和cuid成员被设置成当前进程的有效组ID 示例代码： // 获取键值为0x5000的信号量，如果该信号量不存在，就创建它，代码如下： int semid=semget(0x5000,1,0640|IPC_CREAT); // 获取键值为0x5000的信号量，如果该信号量不存在，返回-1，errno的值被设置为2，代码如下： int semid= semget(0x5000,1,0640); ","date":"2022-09-03","objectID":"/posts/linux%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E9%87%8F/:3:2","tags":["Linux"],"title":"Linux中的信号量","uri":"/posts/linux%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E9%87%8F/"},{"categories":["Linux"],"content":"semctl函数 作用：控制信号量（常用于设置信号量的初始值和销毁信号量） 函数原型： int semctl(int semid, int sem_num, int command, ...); 参数： semid是由semget函数返回的信号量标识 sem_num是信号量集数组上的下标，表示某一个信号量，填0 参数cmd是对信号量操作的命令种类，常用的有以下两个： IPC_RMID：销毁信号量，不需要第四个参数； SETVAL：初始化信号量的值（信号量成功创建后，需要设置初始值），这个值由第四个参数决定。第四参数是一个自定义的联合体，联合体结构如下： // 用于信号灯操作的共同体。 union semun { int val; struct semid_ds *buf; unsigned short *arry; }; 返回值： 成功：返回值根据操作的不同返回不同的值，具体查看手册 失败：返回-1 示例代码： // 销毁信号量 semctl(semid,0,IPC_RMID); // 初始化信号量的值为1，信号量可用 union semun sem_union; sem_union.val = 1; semctl(semid,0,SETVAL,sem_union); ","date":"2022-09-03","objectID":"/posts/linux%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E9%87%8F/:3:3","tags":["Linux"],"title":"Linux中的信号量","uri":"/posts/linux%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E9%87%8F/"},{"categories":["Linux"],"content":"semop函数 作用：对信号量集标识符为semid中的一个或多个信号量进行P操作或V操作 V操作：把信号量的值+1，这个过程也称之为释放锁 P操作：等待信号量的值大于1，如果等待成功，立即把信号量的值-1，这个过程也称之为等待锁 函数原型： int semop(int semid, struct sembuf *sops, unsigned nsops); 参数： semid：由semget函数返回的信号量标识 nsops：操作信号量的个数，即sops结构变量的个数，设置它的为1（只对一个信号量的操作） sops是一个指向进行操作的信号量集结构体数组的首地址的指针，此结构结构如下： struct sembuf { short sem_num; short sem_op; // 。 short sem_flg; }; struct sembuf { unsigned short int sem_num; // 信号量集的个数，单个信号量设置为0 short int sem_op; // 大于零则进行V操作+对应值，小于零则进行P操作-对应值，如果剩余量不够减则会阻塞等待； short int sem_flg; // 把此标志设置为SEM_UNDO，操作系统将跟踪这个信号量。 // 如果当前进程退出时没有释放信号量，操作系统将释放信号量，避免资源被死锁。 }; 返回值： 成功：返回信号量集的标识符 失败：返回-1，并设置errno 错误代码： E2BIG：一次对信号量个数的操作超过了系统限制 EACCESS：权限不够 EAGAIN：使用了IPC_NOWAIT，但操作不能继续进行 EFAULT：sops指向的地址无效 EIDRM：信号量集已经删除 EINTR：当睡眠时接收到其他信号 EINVAL：信号量集不存在,或者semid无效 ENOMEM：使用了SEM_UNDO，但无足够的内存创建所需的数据结构 ERANGE：信号量值超出范围 示例代码： // 等待信号量的值大于0，如果等待成功，立即把信号量的值减1； struct sembuf sem_b; sem_b.sem_num = 0; sem_b.sem_op = -1; sem_b.sem_flg = SEM_UNDO; semop(sem_id, \u0026sem_b, 1); // 将信号量的值+1 struct sembuf sem_b; sem_b.sem_num = 0; sem_b.sem_op = 1; sem_b.sem_flg = SEM_UNDO; semop(sem_id, \u0026sem_b, 1); ","date":"2022-09-03","objectID":"/posts/linux%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E9%87%8F/:3:4","tags":["Linux"],"title":"Linux中的信号量","uri":"/posts/linux%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E9%87%8F/"},{"categories":["Linux"],"content":"其他操作命令 用ipcs -s可以查看系统的信号量，内容有键值（key），信号量编号（semid），创建者（owner），权限（perms），信号量数（nsems） ➜ c ipcs -s --------- 信号量数组 ----------- 键 semid 拥有者 权限 nsems 用ipcrm sem + 信号量编号，可以手工删除信号量 ","date":"2022-09-03","objectID":"/posts/linux%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E9%87%8F/:3:5","tags":["Linux"],"title":"Linux中的信号量","uri":"/posts/linux%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E9%87%8F/"},{"categories":["Linux"],"content":"POSIX信号量的使用 ","date":"2022-09-03","objectID":"/posts/linux%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E9%87%8F/:4:0","tags":["Linux"],"title":"Linux中的信号量","uri":"/posts/linux%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E9%87%8F/"},{"categories":["Linux"],"content":"头文件 #include \u003csemaphore.h\u003e ","date":"2022-09-03","objectID":"/posts/linux%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E9%87%8F/:4:1","tags":["Linux"],"title":"Linux中的信号量","uri":"/posts/linux%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E9%87%8F/"},{"categories":["Linux"],"content":"信号量的类型——sem_t typedef int sem_t; ","date":"2022-09-03","objectID":"/posts/linux%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E9%87%8F/:4:2","tags":["Linux"],"title":"Linux中的信号量","uri":"/posts/linux%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E9%87%8F/"},{"categories":["Linux"],"content":"sem_init函数 作用：初始化信号量 函数原型： int sem_init(sem_t *sem, int pshared, unsigned int value); 参数： sem : 信号量变量的地址 pshared : 0 用在线程间 ，非0用在进程间 value : 信号量中初始化的值 返回值： 成功：返回0 失败：返回-1，并设置errno 错误代码： EINVAL：设定的值超过SEM_VALUE_MAX ENOSYS： pshared非零，但系统不支持进程共享 ","date":"2022-09-03","objectID":"/posts/linux%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E9%87%8F/:4:3","tags":["Linux"],"title":"Linux中的信号量","uri":"/posts/linux%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E9%87%8F/"},{"categories":["Linux"],"content":"sem_destroy函数 作用：释放指向的地址处的无名信号量资源（只能释放由sem_init初始化的信号量） 函数原型： int sem_destroy(sem_t *sem); 参数： sem：sem_init函数中初始化的信号量地址 返回值： 成功：返回0 失败：返回-1，并设置errno 错误代码： EINVAL： sem不是有效的信号量 ","date":"2022-09-03","objectID":"/posts/linux%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E9%87%8F/:4:4","tags":["Linux"],"title":"Linux中的信号量","uri":"/posts/linux%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E9%87%8F/"},{"categories":["Linux"],"content":"sem_wait函数 作用：对信号量加锁，调用一次对信号量的值-1，如果值为0，就阻塞（也就是P操作） 函数原型： int sem_wait(sem_t *sem); 参数： sem：sem_init函数中初始化的信号量地址 返回值： 成功：返回0 失败：返回-1，并设置errno 错误代码 错误码如下： EINTR： 呼叫被信号处理程序打断 EINVAL ：sem不是有效的信号量 ETIMEDOUT：超时 ","date":"2022-09-03","objectID":"/posts/linux%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E9%87%8F/:4:5","tags":["Linux"],"title":"Linux中的信号量","uri":"/posts/linux%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E9%87%8F/"},{"categories":["Linux"],"content":"sem_trywait函数 作用：与sem_wait相同，但不阻塞等待，如果不能执行则直接返回错误 函数原型： int sem_trywait(sem_t *sem); 参数： sem：sem_init函数中初始化的信号量地址 返回值： 成功：返回0 失败：返回-1，并设置errno 错误代码为EAGAIN ","date":"2022-09-03","objectID":"/posts/linux%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E9%87%8F/:4:6","tags":["Linux"],"title":"Linux中的信号量","uri":"/posts/linux%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E9%87%8F/"},{"categories":["Linux"],"content":"sem_timedwait函数 作用：与sem_wait函数相同，但阻塞时间有限制，如果超过设定阻塞时间仍不能执行则返回错误 函数原型： int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout); 参数： sem：sem_init函数中初始化的信号量地址 abs_timeout：timespec类型的指针，里面填充的数据是限制的阻塞时间，timespec结构如下： struct timespec { time_t tv_sec; /* Seconds */ long tv_nsec; /* Nanoseconds [0 .. 999999999] */ }; 返回值： 成功：返回0 失败：返回-1，并设置errno 错误代码，如果是超时则设置为ETIMEDOUT ","date":"2022-09-03","objectID":"/posts/linux%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E9%87%8F/:4:7","tags":["Linux"],"title":"Linux中的信号量","uri":"/posts/linux%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E9%87%8F/"},{"categories":["Linux"],"content":"sem_post函数 作用：对信号量解锁，调用一次对信号量的值+1 函数原型： int sem_post(sem_t *sem); 参数： sem：sem_init函数中初始化的信号量地址 返回值： 成功：返回0 失败：返回-1，并设置errno 错误代码 错误码： EINVAL：sem不是有效的信号量 EOVERFLOW：信号量的最大允许值将被超过 ","date":"2022-09-03","objectID":"/posts/linux%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E9%87%8F/:4:8","tags":["Linux"],"title":"Linux中的信号量","uri":"/posts/linux%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E9%87%8F/"},{"categories":["Linux"],"content":"sem_getvalue函数 作用：获取信号量当前的值，并将这个值保存到参数中的地址中 函数原型： int sem_getvalue(sem_t *sem, int *sval); 使用需链接pthread库 参数： sem：sem_init函数中初始化的信号量地址 sval：存储信号值的地址 返回值： 成功：返回0 失败：返回-1，并设置errno 错误代码EINVAL (sem不是有效的信号量) ","date":"2022-09-03","objectID":"/posts/linux%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E9%87%8F/:4:9","tags":["Linux"],"title":"Linux中的信号量","uri":"/posts/linux%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E9%87%8F/"},{"categories":["Linux"],"content":"示例程序 使用多线程完成生产者-消费者模型 #include \u003cstdio.h\u003e #include \u003cpthread.h\u003e #include \u003cstdlib.h\u003e #include \u003cunistd.h\u003e #include \u003csemaphore.h\u003e // 创建一个互斥量 pthread_mutex_t mutex; // 创建两个信号量 sem_t psem; sem_t csem; struct Node{ int num; struct Node *next; }; // 头结点 struct Node * head = NULL; void * producer(void * arg) { // 不断的创建新的节点，添加到链表中 while(1) { sem_wait(\u0026psem); pthread_mutex_lock(\u0026mutex); struct Node * newNode = (struct Node *)malloc(sizeof(struct Node)); newNode-\u003enext = head; head = newNode; newNode-\u003enum = rand() % 1000; printf(\"add node, num : %d, tid : %ld\\n\", newNode-\u003enum, pthread_self()); pthread_mutex_unlock(\u0026mutex); sem_post(\u0026csem); } return NULL; } void * customer(void * arg) { while(1) { sem_wait(\u0026csem); pthread_mutex_lock(\u0026mutex); // 保存头结点的指针 struct Node * tmp = head; head = head-\u003enext; printf(\"del node, num : %d, tid : %ld\\n\", tmp-\u003enum, pthread_self()); free(tmp); pthread_mutex_unlock(\u0026mutex); sem_post(\u0026psem); } return NULL; } int main() { pthread_mutex_init(\u0026mutex, NULL); sem_init(\u0026psem, 0, 8); sem_init(\u0026csem, 0, 0); // 创建5个生产者线程，和5个消费者线程 pthread_t ptids[5], ctids[5]; for(int i = 0; i \u003c 5; i++) { pthread_create(\u0026ptids[i], NULL, producer, NULL); pthread_create(\u0026ctids[i], NULL, customer, NULL); } for(int i = 0; i \u003c 5; i++) { pthread_detach(ptids[i]); pthread_detach(ctids[i]); } while(1) { sleep(10); } pthread_mutex_destroy(\u0026mutex); pthread_exit(NULL); return 0; } ","date":"2022-09-03","objectID":"/posts/linux%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E9%87%8F/:4:10","tags":["Linux"],"title":"Linux中的信号量","uri":"/posts/linux%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E9%87%8F/"},{"categories":["Linux"],"content":"Linux中的共享内存 先简单写写这里，后面有时间慢慢深挖 ","date":"2022-09-03","objectID":"/posts/linux%E4%B8%AD%E7%9A%84%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/:0:0","tags":["Linux"],"title":"Linux中的共享内存","uri":"/posts/linux%E4%B8%AD%E7%9A%84%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/"},{"categories":["Linux"],"content":"共享内存是啥 这里摘抄一下维基百科： 共享内存（shared memory）指在多处理器的计算机系统中，可以被不同中央处理器访问的大容量内存。由于多个CPU需要快速访问存储器，这样就要对存储器进行缓存。由于其他处理器可能也要存取，任一缓存数据更新后，共享内存就需要立即更新，否则不同处理器可能用到不同的数据（参见缓存一致和内存一致）。 简单来说，共享内存（Shared Memory）就是允许多个进程访问同一个内存空间，是在多个进程之间共享和传递数据最高效的方式。 操作系统将不同进程之间共享内存安排为同一段物理内存，进程可以将共享内存连接到它们自己的地址空间中，如果某个进程修改了共享内存中的数据，其它的进程读到的数据也将会改变。 比较重要的一点：共享内存并未提供锁机制，也就是说，在某一个进程对共享内存的进行读写的时候，不会阻止其它的进程对它的读写（如果要对共享内存的读/写加锁，可以使用信号量）。 ","date":"2022-09-03","objectID":"/posts/linux%E4%B8%AD%E7%9A%84%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/:1:0","tags":["Linux"],"title":"Linux中的共享内存","uri":"/posts/linux%E4%B8%AD%E7%9A%84%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/"},{"categories":["Linux"],"content":"相关函数 ","date":"2022-09-03","objectID":"/posts/linux%E4%B8%AD%E7%9A%84%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/:2:0","tags":["Linux"],"title":"Linux中的共享内存","uri":"/posts/linux%E4%B8%AD%E7%9A%84%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/"},{"categories":["Linux"],"content":"头文件 在Linux中对于共享内存的操作首先要包含头文件： #include \u003csys/ipc.h\u003e #include \u003csys/shm.h\u003e ","date":"2022-09-03","objectID":"/posts/linux%E4%B8%AD%E7%9A%84%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/:2:1","tags":["Linux"],"title":"Linux中的共享内存","uri":"/posts/linux%E4%B8%AD%E7%9A%84%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/"},{"categories":["Linux"],"content":"创建或者获取共享内存——shmget函数 作用：创建一段共享内存或者读取已经存在的共享内存 函数原型： int shmget(key_t key, size_t size, int shmflg); 参数： key：共享内存的键值，是一个整数，typedef unsigned int key_t，是共享内存在系统中的编号，不同共享内存的编号不能相同，这一点由程序员保证，个人经验之谈，key用十六进制表示比较好，因为一般在终端中查看时显示的也是十六进制，用十六进制设置比较直观也方便管理。 size：待创建的共享内存的大小，以字节为单位 shmflg：共享内存的访问权限，与文件的权限一样，0666|IPC_CREAT表示全部用户对它可读写，如果共享内存不存在，就创建一个共享内存 返回值： 成功：将返回有效的共享内存标识符 失败或错误时，返回-1，并设置errno以指示错误。 ","date":"2022-09-03","objectID":"/posts/linux%E4%B8%AD%E7%9A%84%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/:2:2","tags":["Linux"],"title":"Linux中的共享内存","uri":"/posts/linux%E4%B8%AD%E7%9A%84%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/"},{"categories":["Linux"],"content":"连接共享内存——shmat函数 作用：把共享内存连接到当前进程的地址空间 函数原型： void *shmat(int shm_id, const void *shm_addr, int shmflg); 参数： shm_id是由shmget函数返回的共享内存标识 参数shm_addr指定共享内存连接到当前进程中的地址位置，通常为空，表示让系统来选择共享内存的地址 参数shm_flg是一组标志位，通常为0。 返回值： 成功：返回一个指向共享内存第一个字节的指针 失败：返回(void*) -1，并设置errno以指示错误的原因 ","date":"2022-09-03","objectID":"/posts/linux%E4%B8%AD%E7%9A%84%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/:2:3","tags":["Linux"],"title":"Linux中的共享内存","uri":"/posts/linux%E4%B8%AD%E7%9A%84%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/"},{"categories":["Linux"],"content":"分离共享内存——shmdt函数 作用：将共享内存从当前进程中分离，相当于shmat函数的反操作 函数原型： int shmdt(const void *shmaddr); 参数： shmaddr：是shmat函数返回的地址 返回值： 成功：返回0 失败：返回-1，并设置errno以指示错误的原因 ","date":"2022-09-03","objectID":"/posts/linux%E4%B8%AD%E7%9A%84%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/:2:4","tags":["Linux"],"title":"Linux中的共享内存","uri":"/posts/linux%E4%B8%AD%E7%9A%84%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/"},{"categories":["Linux"],"content":"删除共享内存——shmctl函数 作用：控制共享内存，这里注意一下，shmctl不仅可以删除共享内存，还可以做其他事情，但删除是这个函数最主要也是最常用的功能 函数原型： int shmctl(int shm_id, int command, struct shmid_ds *buf); 参数(删除)： shm_id是shmget函数返回的共享内存标识符 command填IPC_RMID buf填0 返回值： 删除成功返回0（其他有部分操作不是，详情看man手册） 失败返回-1，并会设置对应errno 另外：用root创建的共享内存，不管创建的权限是什么，普通用户无法删除 ","date":"2022-09-03","objectID":"/posts/linux%E4%B8%AD%E7%9A%84%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/:2:5","tags":["Linux"],"title":"Linux中的共享内存","uri":"/posts/linux%E4%B8%AD%E7%9A%84%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/"},{"categories":["Linux"],"content":"其他命令操作 用ipcs -m可以查看系统的共享内存，内容有键值（key），共享内存编号（shmid），创建者（owner），权限（perms），大小（bytes） ➜ c git:(main) ✗ ipcs -m ------------ 共享内存段 -------------- 键 shmid 拥有者 权限 字节 连接数 状态 0x00000000 4 sugar 600 524288 2 目标 0x00000000 7 sugar 600 524288 2 目标 0x00000000 11 sugar 600 4194304 2 目标 0x00000000 12 sugar 600 524288 2 目标 0x00005005 13 sugar 640 56 0 用ipcrm -m共享内存编号，可以手工删除共享内存 ➜ c git:(main) ✗ ipcrm -m 13 ➜ c git:(main) ✗ ipcs -m ------------ 共享内存段 -------------- 键 shmid 拥有者 权限 字节 连接数 状态 0x00000000 4 sugar 600 524288 2 目标 0x00000000 7 sugar 600 524288 2 目标 0x00000000 11 sugar 600 4194304 2 目标 0x00000000 12 sugar 600 524288 2 目标 ","date":"2022-09-03","objectID":"/posts/linux%E4%B8%AD%E7%9A%84%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/:3:0","tags":["Linux"],"title":"Linux中的共享内存","uri":"/posts/linux%E4%B8%AD%E7%9A%84%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/"},{"categories":["Linux"],"content":"补充一个小demo ","date":"2022-09-03","objectID":"/posts/linux%E4%B8%AD%E7%9A%84%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/:4:0","tags":["Linux"],"title":"Linux中的共享内存","uri":"/posts/linux%E4%B8%AD%E7%9A%84%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/"},{"categories":["Linux"],"content":"程序A创建共享内存并写入 代码： #include \u003cstring.h\u003e #include \u003csys/ipc.h\u003e #include \u003csys/shm.h\u003e #include \u003ciostream\u003e struct st_pid { int pid; char name[51]; }; int main(int argc, char* argv[]) { int shmid; if ((shmid = shmget(0x5005, sizeof (st_pid), 0640 | IPC_CREAT)) == -1) { printf(\"shmget failed\\n\"); return -1; } st_pid* stpid = nullptr; if ((stpid = (st_pid*)shmat(shmid, nullptr, 0)) == (void*)-1) { printf(\"shmat failed\\n\"); return -1; } stpid-\u003epid = 10010; strcpy(stpid-\u003ename, \"JOJO\"); return 0; } 执行结果： ➜ c git:(main) ✗ ipcs -m ------------ 共享内存段 -------------- 键 shmid 拥有者 权限 字节 连接数 状态 0x00000000 4 sugar 600 524288 2 目标 0x00000000 7 sugar 600 524288 2 目标 0x00000000 11 sugar 600 4194304 2 目标 0x00000000 12 sugar 600 524288 2 目标 0x00005005 14 sugar 640 56 0 ","date":"2022-09-03","objectID":"/posts/linux%E4%B8%AD%E7%9A%84%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/:4:1","tags":["Linux"],"title":"Linux中的共享内存","uri":"/posts/linux%E4%B8%AD%E7%9A%84%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/"},{"categories":["Linux"],"content":"程序B读取共享内存并读出 代码： #include \u003cstdlib.h\u003e #include \u003ciostream\u003e #include \u003cunistd.h\u003e #include \u003csys/ipc.h\u003e #include \u003csys/shm.h\u003e struct st_pid { int pid; char name[51]; }; int main() { int shmid; if ((shmid = shmget(0x00005005, sizeof(st_pid), 0640 | IPC_CREAT)) == -1) { printf(\"shmget failed\\n\"); return -1; } st_pid* test2 = nullptr; if ((test2 = (st_pid*)shmat(shmid, nullptr, 0)) == (void*)-1) { printf(\"shmat failed\\n\"); return -1; } printf(\"name: %s\\n\", test2-\u003ename); printf(\"pid: %d\\n\", test2-\u003epid); if (shmctl(shmid, IPC_RMID, nullptr) == -1) { printf(\"删除失败\\n\"); return -1; } return 0; } 执行结果： name: JOJO pid: 10010 ➜ c git:(main) ✗ ipcs -m ------------ 共享内存段 -------------- 键 shmid 拥有者 权限 字节 连接数 状态 0x00000000 4 sugar 600 524288 2 目标 0x00000000 7 sugar 600 524288 2 目标 0x00000000 11 sugar 600 4194304 2 目标 0x00000000 12 sugar 600 524288 2 目标 ","date":"2022-09-03","objectID":"/posts/linux%E4%B8%AD%E7%9A%84%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/:4:2","tags":["Linux"],"title":"Linux中的共享内存","uri":"/posts/linux%E4%B8%AD%E7%9A%84%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/"},{"categories":["Linux"],"content":"Linux中的信号 简单讲讲Linux中的信号 ","date":"2022-09-02","objectID":"/posts/linux%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7/:0:0","tags":["Linux"],"title":"Linux中的信号","uri":"/posts/linux%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7/"},{"categories":["Linux"],"content":"信号的概念 信号（signal）是软件中断，是进程之间相互传递消息的一种方法，用于通知进程发生了事件，但是，不能给进程传递任何数据。 信号产生的原因有许多种，在Linux中可以使用kill或者killall命令发送特定信号 ","date":"2022-09-02","objectID":"/posts/linux%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7/:1:0","tags":["Linux"],"title":"Linux中的信号","uri":"/posts/linux%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7/"},{"categories":["Linux"],"content":"信号的类型 Linux下常见的信号如下，其中加粗的需要重点关注 默认处理动作： A 缺省的动作是终止进程。 B 缺省的动作是忽略此信号，将该信号丢弃，不做处理。 C 缺省的动作是终止进程并进行内核映像转储（core dump），内核映像转储是指将进程数据在内存的映像和进程在内核结构中的部分内容以一定格式转储到文件系统，并且进程退出执行，这样做的好处是为程序员 提供了方便，使得他们可以得到进程当时执行时的数据值，允许他们确定转储的原因，并且可以调试他们的程序。 D 缺省的动作是停止进程，进入停止状态的程序还能重新继续，一般是在调试的过程中。 E 信号不能被捕获。 F 信号不能被忽略。 信号名 信号值 默认处理动作 发出信号的原因 SIGHUP 1 A 终端挂起或者控制进程终止 SIGINT 2 A 键盘中断Ctrl+c SIGQUIT 3 C 键盘的退出键被按下 SIGILL 4 C 非法指令 SIGABRT 6 C 由abort(3)发出的退出指令 SIGFPE 8 C 浮点异常 SIGKILL 9 AEF 采用kill -9 进程编号 强制杀死程序 SIGSEGV 11 C 无效的内存引用 SIGPIPE 13 A 管道破裂，写一个没有读端口的管道。 SIGALRM 14 A 由alarm()发出的信号 SIGTERM 15 A 采用“kill 进程编号”或“killall程序名”通知程序。 SIGUSR1 10 A 用户自定义信号1 SIGUSR2 12 A 用户自定义信号2 SIGCHLD 17 B 子进程结束信号 SIGCONT 18 进程继续（曾被停止的进程） SIGSTOP 19 DEF 终止进程 SIGTSTP 20 D 控制终端（tty）上按下停止键 SIGTTIN 21 D 后台进程企图从控制终端读 SIGTTOU 22 D 后台进程企图从控制终端写 ","date":"2022-09-02","objectID":"/posts/linux%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7/:2:0","tags":["Linux"],"title":"Linux中的信号","uri":"/posts/linux%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7/"},{"categories":["Linux"],"content":"信号的处理 一般而言，进程对信号的处理方法有三种： 对该信号的处理采用系统的默认操作，大部分的信号的默认操作是终止进程 设置中断的处理函数，收到信号后，由该函数来处理 忽略某个信号，对该信号不做任何处理，就像未发生过一样 // signal函数可以用来设置程序对信号的处理方式 #include \u003csignal.h\u003e typedef void (*sighandler_t)(int); sighandler_t signal(int signum, sighandler_t handler); // signum表示信号的编号 // 参数handler表示对于信号的处理方式，有如下三种情况 // - SIG_DFL：signal.h 预制的宏定义，用于恢复信号的处理方式为默认处理方式 // - 一个自定义的信号处理函数 handler，执行函数内容 // - SIG_IGN：忽略参数signum所指代的信号 ","date":"2022-09-02","objectID":"/posts/linux%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7/:3:0","tags":["Linux"],"title":"Linux中的信号","uri":"/posts/linux%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7/"},{"categories":["Linux"],"content":"信号的作用 信号的作用顾名思义，给出一个一个信号，起到一个通知的作用表示发生了某件事情，这里要注意它只起到通知，不起到告知具体信息 比如说： 服务程序运行在后台，如果想让中止它，杀掉不是个好办法，因为程序被杀的时候，程序突然死亡，没有安排善后工作。 如果向服务程序发送一个信号，服务程序收到这个信号后，调用一个函数，在函数中编写善后的代码，程序就可以有计划的退出。 再比如说： 向服务程序发送0的信号，可以检测程序是否存活。 ","date":"2022-09-02","objectID":"/posts/linux%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7/:4:0","tags":["Linux"],"title":"Linux中的信号","uri":"/posts/linux%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7/"},{"categories":["Linux"],"content":"信号应用示例 ","date":"2022-09-02","objectID":"/posts/linux%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7/:5:0","tags":["Linux"],"title":"Linux中的信号","uri":"/posts/linux%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7/"},{"categories":["Linux"],"content":"屏蔽信号 一般在需要编辑一个服务器程序的时候，会先将所有的信号进行屏蔽，防止运行期间程序被一些预期之外的信号干扰 for (int i = 1; i \u003c 65; ++i) { signal(i, SIG_IGN); } ","date":"2022-09-02","objectID":"/posts/linux%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7/:5:1","tags":["Linux"],"title":"Linux中的信号","uri":"/posts/linux%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7/"},{"categories":["Linux"],"content":"针对特定信号自行设定处理方式 比如针对ctrl + C以及kill + 进程号或者killall + 进程名这种目的是中断进程的信号。 其中ctrl + C发送的信号是SIGINT信号，编号为2；kill + 进程号或者killall + 进程名发送的信号是SIGTERM信号，编号为15 ⚠️：另外还有一种方式会中断程序，即通过kill -9 进程号的方式发送编号为9的信号，此信号不能被捕获也不能被忽略，当发送这个信号时程序会直接停止运行，是强制关闭进程的一种措施 设置SIGINT和SIGTERM两个信号的处理函数，这两个信号可以使用同一个处理函数，函数的代码是在程序运行结束前释放资源，增强程序的健壮性，完整程序如下： #include \u003ciostream\u003e #include \u003csignal.h\u003e void EXIT(int sig) { printf(\"收到了信号%d, 即将退出\\n\", sig); /** 这里应该填充程序的资源释放代码 * * */ exit(0); // 进程退出 } int main(int argc, char** argv) { for (int i = 1; i \u003c 65; ++i) { signal(i, SIG_IGN); } signal(SIGINT, EXIT); signal(SIGTERM, EXIT); while (true) { printf(\"模拟执行一次任务，每次任务两秒钟\\n\"); sleep(2); } return 0; } ","date":"2022-09-02","objectID":"/posts/linux%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7/:5:2","tags":["Linux"],"title":"Linux中的信号","uri":"/posts/linux%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7/"},{"categories":["Linux"],"content":"发送信号 Linux操作系统提供了kill和killall命令向程序发送信号，C语言也提供了相对应的库函数，用于在程序中向其它进程或者线程发送信号。 #include \u003csys/types.h\u003e #include \u003csignal.h\u003e int kill(pid_t pid, int sig); 这里sig参数与之前终端发送的sig编号相同，要注意一下参数pid一共会有三种情况： pid\u003e0将信号传给进程号为pid的进程 pid=0将信号传给和目前进程相同进程组的所有进程，常用于父进程给子进程发送信号，注意，发送信号者进程也会收到自己发出的信号 pid=-1将信号广播传送给系统内所有的进程，例如系统关机时，会向所有的登录窗口广播关机信息 返回值说明： 成功执行时，返回0； 失败返回-1，errno被设为以下的某个值： EINVAL：指定的信号码无效（参数 sig 不合法） EPERM：权限不够无法传送信号给指定进程 ESRCH：参数 pid 所指定的进程或进程组不存在 ","date":"2022-09-02","objectID":"/posts/linux%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7/:6:0","tags":["Linux"],"title":"Linux中的信号","uri":"/posts/linux%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7/"},{"categories":["C/C++"],"content":"C++的指针 ","date":"2022-08-27","objectID":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/:0:0","tags":["C++语法"],"title":"C++的指针","uri":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/"},{"categories":["C/C++"],"content":"指针的概念 ","date":"2022-08-27","objectID":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/:1:0","tags":["C++语法"],"title":"C++的指针","uri":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/"},{"categories":["C/C++"],"content":"C++中内存单元内容与地址 内存由很多内存单元组成，这些内存单元用于存放各种类型的数据 计算机对内存中的每个内存单元都进行了编号，这个编号就称为内存地址，地址决定了内存单元在内存中的位置 记住这些单元地址不方便，于是C++的编译器就允许通过设置变量的方式来访问这些内存地址，而这个变量就是指针 举例： int a = 5; int* ptr = \u0026a; // 此时ptr存储的变量内容就是a的地址，通过ptr可以间接访问a ","date":"2022-08-27","objectID":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/:1:1","tags":["C++语法"],"title":"C++的指针","uri":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/"},{"categories":["C/C++"],"content":"指针的定义与间接访问操作 指针定义的基本形式：指针本身就是一个变量，只不过它存储的内容是地址。对于类型T，T* ptr 就是在定义一个指向类型为T的指针ptr，这个ptr就可以存储「类型为T的变量的地址」 通过一个指针访问它所指向地址的过程称为间接访问或者引用指针，而这个用于执行间接访问的操作符就是单目运算符* 例如：std::cout \u003c\u003c *ptr \u003c\u003c std::endl;就可以打印出来ptr所指向的值（使用std::cout \u003c\u003c ptr \u003c\u003c std::endl;可以打印出来ptr存储的地址） ","date":"2022-08-27","objectID":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/:1:2","tags":["C++语法"],"title":"C++的指针","uri":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/"},{"categories":["C/C++"],"content":"左值与右值 一个小案例： int main() { // 定义一个数组 char str1[] = {\"Hello, world\"}; char* str2 = \"Hello, world\"; str2 = str1; // str1 = str2; // 这一行如果不注释会报错 return 0; } 上面这个小demo中，str2可以赋值为str1，但是str1并不可以被str2赋值，换言之指针变量的值允许改变而数组变量的值不可以改变，虽然在使用的时候str1和str2区别不大，但在赋值上他俩截然不同，这就是左值与右值。 ","date":"2022-08-27","objectID":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/:2:0","tags":["C++语法"],"title":"C++的指针","uri":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/"},{"categories":["C/C++"],"content":"概念 这里不深究原理，简单从工程的角度上来解读一下左值与右值 左值即可以放到赋值运算符=左边的值，包括设定好的变量、指针等（左值也可以放到=右边） 右值即只能放到赋值运算符=右边的值，它一般是一个数据的本身，不能取到本身的地址，包括字面值常量、数值常量等（右值只能放到=右边） ","date":"2022-08-27","objectID":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/:2:1","tags":["C++语法"],"title":"C++的指针","uri":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/"},{"categories":["C/C++"],"content":"具体分析 左值最常见的情况如函数和数据成员的名字 右值是没有标识符、不可以取地址的表达式，一般也称为临时对象 比如a = b + c，可以通过\u0026a来取a的地址但不可以\u0026(b + c)来取(b + c)的地址，这里的a就是左值，而(b + c)就是右值 ","date":"2022-08-27","objectID":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/:2:2","tags":["C++语法"],"title":"C++的指针","uri":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/"},{"categories":["C/C++"],"content":"C中的指针 这里先简单引入一下C中的指针以及其特点 ","date":"2022-08-27","objectID":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/:3:0","tags":["C++语法"],"title":"C++的指针","uri":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/"},{"categories":["C/C++"],"content":"一般类型的指针T* 这里的T指的是任何一种类型，比如int*指的就是int类型的指针，它指向一个相应类型的对象，存储的内容就是其地址 这个类型也包括函数类型，当对应的类型是函数时，它也就被称为函数指针 ","date":"2022-08-27","objectID":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/:3:1","tags":["C++语法"],"title":"C++的指针","uri":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/"},{"categories":["C/C++"],"content":"指针数组 指针数组首先是一个数组，其里面存储的变量是指针，一般的数组定义时如int a[]，对于指针类型也一样，定义一组指针数组形如T* a[] ","date":"2022-08-27","objectID":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/:3:2","tags":["C++语法"],"title":"C++的指针","uri":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/"},{"categories":["C/C++"],"content":"数组指针 数组指针与指针数组是相反的概念，数组指针首先是一个指针，只是这个指针指向的类型是数组，比如T(*b)[] 其实可以理解为：[]的优先级比*高 ","date":"2022-08-27","objectID":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/:3:3","tags":["C++语法"],"title":"C++的指针","uri":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/"},{"categories":["C/C++"],"content":"const与指针 const与指针真的爱恨纠缠，const和pointer的前后顺序不同就会导致其表达的意思不同，总体上分为两类： const pointer：常量指针，形式为const T* ptr，常量指针表示的是这个指针指向的是一个常量，即指向的对象本身不可以修改，但指针可以更换地址（也即可以更换指向的对象） pointer to const：指针常量，形式为T* const ptr，指针常量表示的是这个指针是一个常量，即指针所存储的地址不可以改变（指向的对象不可以变更），但指向的对象本身可以更改其值 已经在上面的介绍中透露出来了一种速记方式，即按照const与*出现的顺序来判断，const在前就先念常量，*在前就先念指针，同时按照顺序去理解，常量指针——类似于「字符串指针」、「数组指针」即它指向的是常量；而指针常量——则直接按照顺序读即可「指针是常量」。 这里个人推荐尽可能避免使用指针常量，因为它本身确实有些反人类，在代码中会很容易降低可读性，除非必须使用，否则应当避免 ","date":"2022-08-27","objectID":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/:3:4","tags":["C++语法"],"title":"C++的指针","uri":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/"},{"categories":["C/C++"],"content":"指向指针的指针 即一个指针，它存储的地址所对应的对象还是一个地址，形如T** ptr int a = 123; int* b = \u0026a; int** c = \u0026b; ","date":"2022-08-27","objectID":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/:3:5","tags":["C++语法"],"title":"C++的指针","uri":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/"},{"categories":["C/C++"],"content":"野指针与悬空指针 野指针是未初始化的指针，这种指针内存储的地址值是未定义的，会存在两种情况： 访问的地址是无效的：会报错，进程会终止 访问的地址是有效的：但并不知道访问的是哪里的地址，造成程序混乱 解决办法：只要定义一个指针就要对其进行初始化，比如直接赋值为nullptr，在具体使用时再对其赋实际的地址 悬空指针是指针所指的对象已被释放掉的指针，对其访问也会存在与野指针相似的两种情况 解决办法：当析构对象的时候，将指向其的指针设置为nullptr，当然这样子并不一定总是可靠，最好还是通过RAII的方式来管理指针，当析构函数执行时自动执行设置为nullptr的行为，比如使用智能指针 ⚠️：这里给到的提示就是当用指针进行间接访问时，一定要非常非常小心，确保其地址有意义再去使用 ❗️：另外，历史代码中一般使用NULL来表示空指针，但这个本质上是0，是一个数字，仍然存在着一定的问题，因此在C++11中推出了nullptr表示空指针，nullptr无任何实际含义，只表示指针为空，现代C++程序应尽可能使用nullptr ","date":"2022-08-27","objectID":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/:3:6","tags":["C++语法"],"title":"C++的指针","uri":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/"},{"categories":["C/C++"],"content":"C++的资源管理方式——RAII ","date":"2022-08-27","objectID":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/:4:0","tags":["C++语法"],"title":"C++的指针","uri":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/"},{"categories":["C/C++"],"content":"RAII(Resource Acquisition Is Initialization): C++所特有的资源管理方式（部分语言如D、Rust也采纳了RAII），主流语言中唯一一个依赖RAII来做资源管理的 RAII依托于栈和析构函数，来对所有的资源——包括堆内存进行管理。通过使用RAII，使得C++不需要类似于JAVA的垃圾回收机制也可以有效的管理内存分配释放问题。 RAII比较成熟的代表：智能指针（unique_ptr、shared_ptr） ","date":"2022-08-27","objectID":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/:4:1","tags":["C++语法"],"title":"C++的指针","uri":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/"},{"categories":["C/C++"],"content":"内存泄漏 什么是内存泄漏： 程序中通过动态分配（new）的堆内存由于某种原因导致程序未释放或无法释放相应资源而导致的内存资源浪费的情况称为内存泄漏，内存泄漏会导致程序运行期间可用内存的减少，严重者可以导致程序的运行速度减缓甚至崩溃 发生原因和排查方法： 内存泄漏主要发生在堆内存分配方式中，即“配置了内存后，所有指向该内存的指针都遗失了”，没有垃圾回收机制时这块内存就再也无法归还给系统 内存泄漏属于程序运行的问题，无法在编译期间排查，只能通过代码检查以及运行期间内存检测工具进行诊断和判别 解决办法：通过RAII对内存进行管理，一个类构造的时候进行内存申请，在析构的时候进行内存释放，由于一个变量有其作用域，当离开作用域范围时会自动调用析构函数，也就会自动进行内存释放了（典型的做法是使用智能指针来对其进行管理） ","date":"2022-08-27","objectID":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/:4:2","tags":["C++语法"],"title":"C++的指针","uri":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/"},{"categories":["C/C++"],"content":"智能指针 ","date":"2022-08-27","objectID":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/:5:0","tags":["C++语法"],"title":"C++的指针","uri":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/"},{"categories":["C/C++"],"content":"比普通指针更安全的解决方案 之前介绍了普通指针可能会出现的问题，对于这些问题，现代C++一般有两种典型方案： 使用更安全的指针——智能指针 不使用指针，用更安全的方式——使用引用的方式 ","date":"2022-08-27","objectID":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/:5:1","tags":["C++语法"],"title":"C++的指针","uri":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/"},{"categories":["C/C++"],"content":"C++中的智能指针 C++目前一共推出了共四种智能指针，分别是unique_ptr、shared_ptr、weak_ptr以及已经在C++11中被弃用（deprecated）的auto_ptr（在C++17中已经正式被删除） ","date":"2022-08-27","objectID":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/:5:2","tags":["C++语法"],"title":"C++的指针","uri":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/"},{"categories":["C/C++"],"content":"auto_ptr 首先来看一下auto_ptr，它是最早的智能指针，可以比较容易的看出来智能指针的作用与思想，后续的智能指针本质上都是将auto_ptr进行完善与延伸。 基本特性：首先auto_ptr使用方法跟指针一样，内部也相当于存储着一个地址，但对于new expression获得的对象不需要像普通的new的对象一样delete去销毁对象而是在auto_ptr对象销毁时，它所管理的对象也会被自动delete掉，这里还是比较抽象的，举一个简单的例子：在一个函数片段中如果需要new一个对象，那么使用普通指针和智能指针的表现如下： // 普通指针 if (xxx) { test_class* ptr = new test_class(); ... delete ptr; } // 智能指针 if (xxx) { auto_ptr\u003ctest_class\u003e ptr2 (new test_class()); ... } 可以看出来，当使用普通指针的时候，在离开作用域之前需要先delete，而使用智能指针则不用，这是因为智能指针离开作用域时会被销毁，而智能指针被销毁时会自动delete掉它的对象。 所有权转移：如果将auto_ptr传递给另外的智能指针，原来的指针就不再拥有这个对象了，在拷贝/赋值的过程中，会剥夺指针对原对象的内存都控制权，控制权转交给新对象，再将原对象的指针置为nullptr，为了更好展示这个特点以及其可能存在的隐患，看一下下面这个例子 #include \u003ciostream\u003e #include \u003cstring\u003e #include \u003cmemory\u003e using namespace std; class Test { public: explicit Test(string str) : str(std::move(str)) { printf(\"构造成功\\n\"); } ~Test() { printf(\"析构成功\\n\"); } public: void print() { cout \u003c\u003c str \u003c\u003c endl; } private: string str; }; int main() { auto_ptr\u003cTest\u003e strs[3] = { auto_ptr\u003cTest\u003e(new Test(\"C\")), auto_ptr\u003cTest\u003e(new Test(\"C++\")), auto_ptr\u003cTest\u003e(new Test(\"Java\")) }; cout \u003c\u003c \"------first loop------\" \u003c\u003c endl; for (auto\u0026 str_ptr : strs) { str_ptr-\u003eprint(); } strs[1]-\u003eprint(); cout \u003c\u003c \"------second loop------\" \u003c\u003c endl; for (auto str_ptr : strs) { str_ptr-\u003eprint(); } strs[1]-\u003eprint(); printf(\"运行结束\\n\"); return 0; } 运行结果如下： 构造成功 构造成功 构造成功 ------first loop------ C C++ Java C++ ------second loop------ C 析构成功 C++ 析构成功 Java 析构成功 进程已结束,退出代码139 (interrupted by signal 11: SIGSEGV) 可以看到，first loop可以打印出C++，而second loop并没有能够打印出C++，这个就是因为所有权的转移，第一个循环中使用的是引用的方式，因此并没有发生所有权的转移，因此循环结束再次访问没有问题，而第二个循环使用的是值拷贝的方式，这就导致了每一次使用都会使得之前的auto_ptr损失掉自己的所有权，而每一轮循环又会因为这个问题导致new的对象被直接释放掉，进而在第二次循环结束的时候再去访问这个指针，导致了crash被信号中断了，这就意味着auto_ptr其实并不安全。 ","date":"2022-08-27","objectID":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/:5:3","tags":["C++语法"],"title":"C++的指针","uri":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/"},{"categories":["C/C++"],"content":"unique_ptr 在刚刚的auto_ptr中，智能指针与对象有着强耦合关系，如果出现了拷贝智能指针就很有可能会出现之前所讲述的问题，并不想释放掉这个元素但在使用过程中很可能在没有察觉的过程中就完成了释放，导致后续程序错误。为了改进auto_ptr也就提出了unique_ptr。 unique_ptr的所有权是专属所有权，所以unique_ptr管理的内存，智能被一个对象所持有，同时不支持拷贝和赋值 移动语义：unique_ptr禁止了拷贝语义，但有时也需要能够转移所有权，于是提供了移动语义，也即可以使用std::move()语句进行转移所有权。接下来具体看一下，首先同样是之前的例子，将auto_ptr更换为unique_ptr： #include \u003ciostream\u003e #include \u003cstring\u003e #include \u003cmemory\u003e using namespace std; class Test { public: explicit Test(string str) : str(std::move(str)) { printf(\"构造成功\\n\"); } ~Test() { printf(\"析构成功\\n\"); } public: void print() { cout \u003c\u003c str \u003c\u003c endl; } private: string str; }; int main() { unique_ptr\u003cTest\u003e strs[3] = { unique_ptr\u003cTest\u003e(new Test(\"C\")), unique_ptr\u003cTest\u003e(new Test(\"C++\")), unique_ptr\u003cTest\u003e(new Test(\"Java\")) }; cout \u003c\u003c \"------first loop------\" \u003c\u003c endl; for (auto\u0026 str_ptr : strs) { str_ptr-\u003eprint(); } strs[1]-\u003eprint(); cout \u003c\u003c \"------second loop------\" \u003c\u003c endl; for (auto str_ptr : strs) { str_ptr-\u003eprint(); } strs[1]-\u003eprint(); printf(\"运行结束\\n\"); return 0; } 如果这个时候进行编译，会发现程序编译会报错，报错内容在for (auto str_ptr : strs)，报错信息为：Call to implicitly-deleted copy constructor of 'unique_ptr\u003cTest\u003e'，也就是说unique_ptr不支持通过拷贝来构造，通过这种方式就不可以继续使用之前的方式来进行访问了，如果确定要移动走所有权，那么就要显示的使用std::move()进行转移，代码如下： #include \u003ciostream\u003e #include \u003cstring\u003e #include \u003cmemory\u003e using namespace std; class Test { public: explicit Test(string str) : str(std::move(str)) { printf(\"构造成功\\n\"); } ~Test() { printf(\"析构成功\\n\"); } public: void print() { cout \u003c\u003c str \u003c\u003c endl; } private: string str; }; int main() { unique_ptr\u003cTest\u003e strs[3] = { unique_ptr\u003cTest\u003e(new Test(\"C\")), unique_ptr\u003cTest\u003e(new Test(\"C++\")), unique_ptr\u003cTest\u003e(new Test(\"Java\")) }; cout \u003c\u003c \"------first loop------\" \u003c\u003c endl; for (auto\u0026 str_ptr : strs) { str_ptr-\u003eprint(); } strs[1]-\u003eprint(); cout \u003c\u003c \"------second loop------\" \u003c\u003c endl; for (auto\u0026 str_ptr : strs) { auto tmp = std::move(str_ptr); tmp-\u003eprint(); } if (strs[1] != nullptr) { strs[1]-\u003eprint(); } printf(\"运行结束\\n\"); return 0; } 通过明确的移动语义移动走所有权，然后进行使用，析构，当使用明确的移动语义时就可以避免程序员的失误导致对象被释放。另外，unique_ptr也支持了与nullptr进行比较，这一点也是auto_ptr没有的，相比之下也就更安全，另外，在C++11中更加提倡使用工厂模式的工厂函数来生产智能指针，因此在第一段生成unique_ptr的函数那里，将代码更改为： unique_ptr\u003cTest\u003e strs[3] = { std::make_unique\u003cTest\u003e(\"C\"), std::make_unique\u003cTest\u003e(\"C++\"), std::make_unique\u003cTest\u003e(\"Java\") }; 常用的unique_ptr方法： ptr.get()：用于获取原始指针，因为历史的包袱问题，很多时候C++并不能完全使用智能指针，对于需要使用C指针的时候通过get()方法就可以使用普通指针了 ","date":"2022-08-27","objectID":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/:5:4","tags":["C++语法"],"title":"C++的指针","uri":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/"},{"categories":["C/C++"],"content":"shared_ptr与weak_ptr 不论是auto_ptr还是unique_ptr，本质上其实都是一样的，都只允许一个智能指针来访问一个对象，而不允许多个智能指针来访问同一个对象，但如果想像普通指针一样去使用智能指针，那么就必须允许多个智能指针来访问同一个对象，因此也就有了shared_ptr 解决方法：通过「引用计数」机制使得多个智能指针可以访问同一个对象，引用计数就是当有一个智能指针指向该对象时，引用计数加1，当一个智能对象被销毁时引用计数减1，当引用计数减小到0时会释放对象资源然后执行对应的析构函数。（当然引入「引用计数」会存在一定的额外开销，但相比较于它的优势可以忽略不计，除非非常明确不使用shared_ptr会更好，否则使用shared_ptr一定不是一件坏事情） 引用计数的问题——循环引用： 起因：如下图所示，两个类中，A中含有类型B的shared_ptr，B中含有类型A的shared_ptr 这时使用分别new一个类型为A和B的对象A和对象B，并使用ptr A指向对象A，ptrB指向对象B，此时对象A的指针指向对象B，此时对象B的指针指向对象A。当ptrA使用结束时，ptrA释放，对象A的引用计数-1，但因为对象B仍然持有对象A的智能指针，所以引用计数大于0，也就不会析构对象A；接下来ptrB也使用结束，对象B的引用计数-1，但因为之前对象A并没有被析构，因此对象B的引用计数也仍然大于0，因此对象B也没有被析构，这种情况下，ptrA和ptrB都被释放了，但对象A和对象B都没有被析构，同时也没有其他指针指向他们，换言之，已经发生了内存泄漏，因为对象A和对象B不可能再被析构。 解决方法：使用weak_ptr weak_ptr被设计用来和shared_ptr一起使用，它工作在观察者模式，对于它指向的对象是一种弱引用，也就是说它可以获得资源的观测权，像旁观者一样观察资源的使用情况，但是弱引用就代表着它不会增加shared_ptr的引用计数，当被观察的shared_ptr失效之后，相应的weak_ptr也就失效了，如下图所示，虚线代表观察，不增加引用计数 代码示例： 不使用weak_ptr： #include \u003ciostream\u003e #include \u003cmemory\u003e #include \u003cstring\u003e #include \u003cmemory\u003e using namespace std; class B; class A { public: A(shared_ptr\u003cB\u003e ptr = nullptr) : ptr(ptr) { printf(\"A构造完成\\n\"); } ~A() { printf(\"A析构完成\\n\"); } shared_ptr\u003cB\u003e ptr; }; class B { public: B(shared_ptr\u003cA\u003e ptr = nullptr) : ptr(ptr) { printf(\"B构造完成\\n\"); } ~B() { printf(\"B析构完成\\n\"); } shared_ptr\u003cA\u003e ptr; }; int main() { auto ptrA = make_shared\u003cA\u003e(); auto ptrB = make_shared\u003cB\u003e(ptrA); ptrA-\u003eptr = ptrB; } 此时，ptrA和ptrB出现了相互引用，程序结果为： A构造完成 B构造完成 可以看出来并没有发生析构，此时如果将最后一行代码去掉，即ptrA的ptr为nullptr #include \u003ciostream\u003e #include \u003cmemory\u003e #include \u003cstring\u003e #include \u003cmemory\u003e using namespace std; class B; class A { public: A(shared_ptr\u003cB\u003e ptr = nullptr) : ptr(ptr) { printf(\"A构造完成\\n\"); } ~A() { printf(\"A析构完成\\n\"); } shared_ptr\u003cB\u003e ptr; }; class B { public: B(shared_ptr\u003cA\u003e ptr = nullptr) : ptr(ptr) { printf(\"B构造完成\\n\"); } ~B() { printf(\"B析构完成\\n\"); } shared_ptr\u003cA\u003e ptr; }; int main() { auto ptrA = make_shared\u003cA\u003e(); auto ptrB = make_shared\u003cB\u003e(ptrA); // ptrA-\u003eptr = ptrB; } 此时结果为： A构造完成 B构造完成 B析构完成 A析构完成 可以推断出来，只要一方不持有另一方的指针，那么就可以正常析构，而这也就是weak_ptr的基本原理，同时再赋予其观察者的身份，使得其可以正常使用相对应的指针。 使用weak_ptr: #include \u003ciostream\u003e #include \u003cmemory\u003e #include \u003cstring\u003e #include \u003cmemory\u003e using namespace std; class B; class A { public: A(shared_ptr\u003cB\u003e ptr = nullptr) : ptr(ptr) { printf(\"A构造完成\\n\"); } ~A() { printf(\"A析构完成\\n\"); } shared_ptr\u003cB\u003e ptr; }; class B { public: B(shared_ptr\u003cA\u003e ptr = nullptr) : ptr(ptr) { printf(\"B构造完成\\n\"); } ~B() { printf(\"B析构完成\\n\"); } weak_ptr\u003cA\u003e ptr; }; int main() { auto ptrA = make_shared\u003cA\u003e(); auto ptrB = make_shared\u003cB\u003e(ptrA); ptrA-\u003eptr = ptrB; } 这里只需要将B中的ptr指针更改为weak_ptr类型即可以完成实验，实验结果如下： A构造完成 B构造完成 A析构完成 B析构完成 这里有两个地方要注意： 类型B的构造函数其实是运用了隐式转换，另外一方面也可以理解为weak_ptr是通过shared_ptr构造的，它不可以由普通指针构造，要牢记它是一个shared_ptr的观察者 这里实验结果的析构顺序和之前将A的ptr置空的析构顺序是相反的，这里是因为置空时的ptrA被释放时，B中还持有A的智能指针，也就是说引用计数不为0所以一定是先析构B再析构A；而使用weak_ptr时正好相反，B中相当于没持有A的指针而A中持有了B的shared_ptr，所以一定是先析构A再析构B shared_ptr常用函数： ptr.use_count()：返回shared_ptr当前指向对象的引用计数，还是刚刚的例子，我们来看一下使用weak_ptr和不使用weak_ptr在引用计数上的区别： int main() { auto ptrA = make_shared\u003cA\u003e(); auto ptrB = make_shared\u003cB\u003e(ptrA); ptrA-\u003eptr = ptrB; cout \u003c\u003c ptrA.use_count() \u003c\u003c endl; } 不使用weak_ptr执行结果： A构造完成 B构造完成 2 A析构完成 B析构完成 使用weak_ptr执行结果 A构造完成 B构造完成 1 A析构完成 B析构完成 shared_ptr的move语义：对shared_ptr进行std::move()会将这个智能指针的所有内容转移给新指针，同时原指针会被置为nullptr 示例代码如下： int main() { auto ptrA = make_shared\u003cA\u003e(); cout \u003c\u003c ptrA.use_count() \u003c\u003c endl; auto ptr2 = std::move(ptrA); cout \u003c\u003c ptrA.use_count() \u003c\u003c endl; cout \u003c\u003c ptr2.use_count() \u003c\u003c endl; if (ptrA == nullptr) { cout \u003c\u003c \"ptrA已经被置为nullptr\" \u003c\u003c endl; } return 0; } 执行结果如下： A构造完成 1 0 1 ptrA已经被置为nullptr A析构完成 shared_ptr也支持get()方法，使用作用与weak_ptr相同 ","date":"2022-08-27","objectID":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/:5:5","tags":["C++语法"],"title":"C++的指针","uri":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/"},{"categories":["C/C++"],"content":"C++的引用 ","date":"2022-08-27","objectID":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/:6:0","tags":["C++语法"],"title":"C++的指针","uri":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/"},{"categories":["C/C++"],"content":"引用是什么 引用就是一种特殊的指针，是一种不允许修改的指针。 使用指针的坑： 野指针 悬空指针 不知不觉更改了指针的值但却继续使用 使用引用解决的问题： 不存在空引用 必须初始化 一个引用永远指向它初始化的那个对象 ","date":"2022-08-27","objectID":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/:6:1","tags":["C++语法"],"title":"C++的指针","uri":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/"},{"categories":["C/C++"],"content":"引用的基本使用 可以认为引用就是指定变量的别名，在使用时可认为引用即是变量本身 ","date":"2022-08-27","objectID":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/:6:2","tags":["C++语法"],"title":"C++的指针","uri":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/"},{"categories":["C/C++"],"content":"最常用的使用场景 输入到一个函数中，需要更改两个对象的值，比如最简单的交换值swap()程序: void swap(int\u0026 a, int\u0026 b) { int c = a; a = b; b = c; } int main() { int a = 10, b = 20; cout \u003c\u003c \"a: \" \u003c\u003c a \u003c\u003c \", b: \" \u003c\u003c b \u003c\u003c endl; swap(a, b); cout \u003c\u003c \"a: \" \u003c\u003c a \u003c\u003c \", b: \" \u003c\u003c b \u003c\u003c endl; return 0; } 执行结果： a: 10, b: 20 a: 20, b: 10 ","date":"2022-08-27","objectID":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/:6:3","tags":["C++语法"],"title":"C++的指针","uri":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/"},{"categories":["C/C++"],"content":"两个问题的思考 有了指针为什么还需要引用 JAVA只有引用，而C则只有指针，C++则支持指针和引用混合编程 C++之父Bjarne Stroustrup的解释是：为了支持函数运算符重载 有了引用为什么还需要指针 因为这是C++，一定要去兼容C语言，是一种历史遗留问题，像JAVA就可以直接舍弃C语言，因为它并不需要兼容C语言 简单来说，个人认为指针是历史，跑不掉而且在很多场景下更灵活，而引用则更符合人的直觉，使用起来更加顺畅，所有引用的场景确实都可以通过指针实现，但引用是一种更加便捷的工具，都支持不是C++的缺点，反而是优点，而重点则在程序员们要如何去使用这两样工具 ","date":"2022-08-27","objectID":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/:6:4","tags":["C++语法"],"title":"C++的指针","uri":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/"},{"categories":["iOS"],"content":"UITableView使用指南，速查手册，快速上手","date":"2022-08-17","objectID":"/posts/ios-uitableview%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/","tags":["iOS"],"title":"iOS-UITableView使用指南","uri":"/posts/ios-uitableview%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":["iOS"],"content":"UITableView使用指南 ","date":"2022-08-17","objectID":"/posts/ios-uitableview%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:0:0","tags":["iOS"],"title":"iOS-UITableView使用指南","uri":"/posts/ios-uitableview%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":["iOS"],"content":"概述 一般遇到大量相同结构的视图进行同一方向排列时，比如一般app的设置页面、通讯录等，使用UITableView是一个非常合适的方案。 ","date":"2022-08-17","objectID":"/posts/ios-uitableview%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:1:0","tags":["iOS"],"title":"iOS-UITableView使用指南","uri":"/posts/ios-uitableview%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":["iOS"],"content":"基本介绍 ","date":"2022-08-17","objectID":"/posts/ios-uitableview%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:2:0","tags":["iOS"],"title":"iOS-UITableView使用指南","uri":"/posts/ios-uitableview%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":["iOS"],"content":"风格样式： 这个属性是UITableView最基本的属性，共有两种 UITableViewStylePlain：默认样式 在 plain 模式下，如果 tableview 有多个 section（分区、分组），组与组之间默认是没有间距的。 同时组头或组尾会有 sticky 效果（粘性效果、悬停效果），即表格滚动时组头与组尾会自动停留，而不是跟随单元格一同移动。 同时plain模式下的tableView可以有一个section索引，作为一个bar在table的右边(例如A ~ Z)。你可以点击一个特定的标签，跳转到目标section。 例如：iOS中「通讯录」就是典型应用 UITableViewStyleGrouped：分组样式 在 grouped 模式下，如果 tableview 有多个 section，组与组之间默认是有间距的。 在表格滚动的同时组头与组尾会随之滚动、不停留，不会有 sticky 效果（粘性效果、悬停效果）。 Group类型默认设置tableView灰色背景色，cell为白色背景色，section外边缘设置浅灰色边框，cell设置浅灰色间隔线 例如：iOS中「设置」就是典型应用 踩坑记录： 在iOS15中，如果使用UITableViewStylePlain样式建立TableView，如果给section添加一个header那么会出现一个现象，就是在这个header上方会出现一个空白区域。这个空白区域是由于在iOS15中UITableView中引入了一个新的属性sectionHeaderTopPadding，这个属性默认是22，如果不需要这块空白，改为0即可，代码如下： let tableView = UITableView() if #available(iOS 15.0, *) { tableView.sectionHeaderTopPadding = 0 } else { // Fallback on earlier versions } ","date":"2022-08-17","objectID":"/posts/ios-uitableview%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:2:1","tags":["iOS"],"title":"iOS-UITableView使用指南","uri":"/posts/ios-uitableview%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":["iOS"],"content":"单元格Cell UITableView的每行数据都是一个UITableViewCell： 每个Cell使用IndexPath来表示位置，换言之UITableView中的数据只有行的概念，没有列的概念 IndexPath又分为section和row，每个section为一组，其中可以包含多个行row。 关于Cell的重用 需要注意的是 TableView 必须使用重用机制 ，当cell滑出屏幕的时候 cell会被系统回收，在下面cell将要显示时会调用之前回收的cell，这样就不必每次都创建销毁，节省内存同时节省时间，如果不使用重用机制，每次都创建新的cell 是非常消耗内存和性能的 // 必须实作的方法：Cell重用，然后设定Cell的内容 func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -\u003e UITableViewCell { // 取得 tableView 目前使用的 cell let cell = tableView.dequeueReusableCell( withIdentifier: \"Cell\", for: indexPath) as UITableViewCell // 设置显示的内容 if let myLabel = cell.textLabel { myLabel.text = \"xxxx\" } return cell } Cell的UI和布局 UITableView中每行数据都是一个UITableViewCell，在这个控件中为了显示更多的信息，iOS已经在其内部设置好了多个子控件以供开发者使用。如果我们查看UITableViewCell的声明文件可以发现在内部有一个UIView控件（contentView，作为其他元素的父控件）两个UILable控件（textLabel、detailTextLabel）、一个UIImage控件（imageView），分别用于容器、显示内容、详情和图片。 如果直接使用UITableViewCell则默认共有四种Style设定： typedef NS_ENUM(NSInteger, UITableViewCellStyle) { UITableViewCellStyleDefault, // 左侧显示textLabel（不显示detailTextLabel），imageView可选（显示在最左边） UITableViewCellStyleValue1, // 左侧显示textLabel、右侧显示detailTextLabel（默认蓝色），imageView可选（显示在最左边） UITableViewCellStyleValue2, // 左侧依次显示textLabel(默认蓝色)和detailTextLabel，imageView可选（显示在最左边） UITableViewCellStyleSubtitle // 左上方显示textLabel，左下方显示detailTextLabel（默认灰色）,imageView可选（显示在最左边） }; Cell的属性 accessoryView 在contentView的右边，还有一个accessoryView，这个View是用来作为功能键使用，在iOS中称为访问器，支持显示不同的图标，点击可以触发不同的事件 这个View的设定是通过设置UITableViewCell中的accesoryType属性完成的： public enum AccessoryType : Int, @unchecked Sendable { case none = 0 // 不显示任何图标 case disclosureIndicator = 1 // 跳转指示图标 case detailDisclosureButton = 2 // 内容详情图标和跳转指示图标 case checkmark = 3 // 勾选图标 @available(iOS 7.0, *) case detailButton = 4 // 内容详情图标 } 默认情况如图所示： Cell的分割线 // 设置分割线端距，这里表示separator离左边和右边均80像素 myTableView.separatorInset = UIEdgeInsets(top: 0, left: 40, bottom: 0, right: 40) myTableView.separatorStyle = .singleLine // 分割线的样式 myTableView.separatorColor = .red // 分割线颜色 隐藏部分Cell的分割线 因为TableView的风格设置是针对整个tableView的，如果设置myTableView.separatorStyle = .singleLine，则所有的cell都会有分割线，如果要隐藏部分cell的话就需要一点点小trick 在要显示cell的时候将cell的分割线inset左右各设为cell宽度的一半 func tableView(_ tableView: UITableView, willDisplay cell: UITableViewCell, forRowAt indexPath: IndexPath) { if indexPath.section == 1 { cell.separatorInset = .init(top: 0, left: cell.bounds.width / 2, bottom: 0, right: cell.bounds.width / 2) } } Cell选中样式 // cell的选中样式 cell.selectionStyle = .default // 默认点击时为灰色 cell.selectionStyle = .none // 设置为none点击时无反应 // 这里要注意一下，其实还有.grey和.blue但效果和.default是相同的 // 在iOS7的时候更改了，然后如果想要设置为其他颜色，则要设置selectedBackgroundView // cell的选中样式为其他颜色 cell.selectionStyle = .default cell.selectedBackgroundView = UIView() cell.selectedBackgroundView?.backgroundColor = .blue UITableView的使用： 在controller中引入UITableView类型的变量，然后设置相应的数据源和代理： tableView.delegate = self tableView.datasource = self 表格分组section的DataSource方法的调用时序： DataSource数据源：需要在Controller引入UITableViewDataSource协议 返回表格视图的Section数：numberOfSections func numberOfSections(in tableView: UITableView) -\u003e Int { // 返回section的数量 return 1 } 设置 section中的row行的个数： func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -\u003e Int { // 返回Section中的row行数 return 1 } 返回Section的头部View： func tableView(_ tableView: UITableView, viewForHeaderInSection section: Int) -\u003e UIView? { // 返回对应Section的头部 return UIView() } 返回Section的尾部View： func tableView(_ tableView: UITableView, viewForFooterInSection section: Int) -\u003e UIView? { // 返回对应Section的尾部 return UIView() } UITableViewDelegate：需要在Controller引入UITableViewDelegate协议 返回每个cell对应的行高： func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -\u003e CGFloat { if indexPath.section == 0 { // section0 的cell行高为70 return 70 } else if indexPath.section == 1 { // section1 的cell行高为140 return 140 } // 默认行高 return 106 } 返回Section头部的高度： func tableView(_ tableView: UITableView, heightForHeaderInSection section: Int) -\u003e CGFloat { if section == 0 { return 0.01 } if (isShowUrlCell \u0026\u0026 section == 5) || (!isShowUrlCell \u0026\u0026 section ==","date":"2022-08-17","objectID":"/posts/ios-uitableview%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:2:2","tags":["iOS"],"title":"iOS-UITableView使用指南","uri":"/posts/ios-uitableview%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":["iOS"],"content":"UIStackView使用指南 ","date":"2022-08-17","objectID":"/posts/ios-uistackvie%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:0:0","tags":["iOS"],"title":"iOS-UIStackView使用指南","uri":"/posts/ios-uistackvie%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":["iOS"],"content":"概述 一般遇到两个或以上的控件进行一行或一列布局时，或行列组合成卡片形式的布局时，使用 UIStackView 是最简单有效的方案，例如一些 tab 的展示时，可简单使用 UIStackView + UIScrollView 实现。当然要排列的控件比较多，且需要分页加载的时候，请考虑使用 UICollectionView。 所以这里的 Stack 不是堆栈的意思，也不存在压栈、弹栈的操作，可以理解为“堆叠”。UIStackView实现了U界面×轴和丫轴方向上的堆叠。类比理解，Swiftul 带来的 ZStack 就是Z轴方向上的视图堆叠。 一图概之： 基本要点： 基于 Auto Layout 布局子视图。UIStackView 自身也需要使用 Auto Layout 布局，使用 frame 布局可能效果不一定符合预期。 开发者负责定义 UIStackView 的位置和尺寸（可选），UIStackView 自身管理子视图的内容布局和自身大小，即至少给 UIStackView 添加两个邻边的位置约束。 可动态修改所有属性。 阄割了 UView 基类的一些特性，如设置 backgroundColor UIStackView 是 Apple 基于 Flexbox 思想来实现的布局，虽然是以一个控件 （UlView 子类）呈现，但它做的更多是布局其加入子视图。这种布局思想更接近物理世界的直觉。 Flexbox 在2009 年被W3C 提出，可以很简单、完整地实现各种页面布局，而且还是响应式的，开始被应用于前端领域，目前所有浏览器都已支持。后来通过 React Native 和 Weex等框架，它被带入到客户端开发中，同时支持了 i0s 和 Android。想了解 Flexbax 的详细 CSS布局，可参阅 Flex 布局教程：语法篇-阮一峰的网络日志。 要想更直观地体验把玩 Flexbox 布局，可参阅以下链接： display: flex Flexbox Froggy - A game for learning CSS flexbox Flexy Boxes — CSS flexbox playground and code generation tool 要想在iOS完整体验 Flexbox 布局，可使用 Texture 中的 ASStackLayoutSpec。一些聪明的开发者通过UICollectionViewLayout也实现了简单的 Flexbox 布局，如 UICollectionViewFlexboxLayouto SwiftUl也引入了些 Flexbox 布局，如 HStack、 vStack 和 ZStack，可参阅 Building layouts with UIStackViews 简单体验其为布局带来的便利 ","date":"2022-08-17","objectID":"/posts/ios-uistackvie%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:1:0","tags":["iOS"],"title":"iOS-UIStackView使用指南","uri":"/posts/ios-uistackvie%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":["iOS"],"content":"内容自适应规则 一句话概括：subview content size + spacing。 UIStackView 沿轴方向长度 = 所有排列子视图大小之和 + 子视图之间的间距总和 UIStackView 正交轴方向（垂直于轴方向）长度 = 最大排列子视图的长度 若 isLayoutwarginsReLativeArrangement 为 true，上述的长度还会包含相关的 layoutMargins 上面所说的长度都是拟合大小 （fitting size) 注意: 这里的子视图大小是视图的 content size，内容大小，是指 Auto Layout 约束计算之后的 size，所以直接设置 frame是无效的，必须通过重写 intrinsieContentsize 属性或给子视图的宽高添加 Auto Layout 约束 这里还隐含了一些潜规则： 让 UIStackView 能自适应子视图大小的前提是子视图要有 content size。 最终子视图的 size 也不一定等于 content size，当 UIStackView 自身设置了宽高约束，其会为了填充空间会对子视图进行拉伸或收缩。 自适应子视图大小意味着其不允许子视图溢出其自身。这与 CSS flexbox 的 flex-wrap 表现有别。 另外 UIStackView 的这些布局属性会直接影响其自适应的大小： axis：定义了堆叠的轴方向，是在垂直方向还是水平方向进行堆叠。 distribution：定义了轴方向上的子视图布局。 alignment：定义了轴正交方向上的子视图布局。 spacing：定义了轴方向上的子视图之间的最小间距。 isBaselineRelativeArrangement：定义了视图之间的垂直间距是否从基线测量 isLayoutMarginsRelativeArrangement：定义了是否要基于子视图的 LayoutMargins 来布局 若修改上述属性无法达到你的预期效果，则优先检查 Xcode 控制台是否输出了 Auto Layout 约束冲突的错误日志，从中检查需要修改的属性或补充的约束。 ","date":"2022-08-17","objectID":"/posts/ios-uistackvie%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:2:0","tags":["iOS"],"title":"iOS-UIStackView使用指南","uri":"/posts/ios-uistackvie%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":["iOS"],"content":"NSLayoutConstraint.Axis 默认为horizontal水平方向 ","date":"2022-08-17","objectID":"/posts/ios-uistackvie%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:2:1","tags":["iOS"],"title":"iOS-UIStackView使用指南","uri":"/posts/ios-uistackvie%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":["iOS"],"content":"UIStackView.Distribution 定义沿 UIStackView 轴方向的子视图的大小和位置的布局。 除了 fillEqually 以外的 distribution，UStackView 在沿轴方向计算尺寸时，会使用每个子视图的 intrinsicContentsize 属性。而 fiLLEqually 会相等调整子视图的大小，使其在轴方向的长度是一致的，如果可能，UIStackView 会拉伸所有子视图，以匹配轴方向最大内容大小的视图。 fill 默认情况，UIStackView 调整其子视图的大小,以填充轴方向上的可用空间 当子视图塞不进 UIStackView 时,UIStackView 根据其抗压优先级 (compression resistance priority) 收缩视图 当子视图没有塞满UIStackView时，UIStackView根据其拥抱优先级(hugging priority)拉伸时图 当存在歧义时,UIStackView 根据子视图在 arrangedSubviews 中的索引调整子视图的大小 fillEqually UIStackView 调整其子视图的大小，以填充轴方向上的可用空间。子视图会拉伸调整大小（匹配最大的子视图），以保持轴方向上的大小都相等。 fillPropertionlly UIStackView 调整其子视图的大小，以填充轴方向上的可用空间。视图根据其沿 UIStackView 轴的内在内容大小按比例调整大小。 equalSpacing UIStackView 放置排列子视图，以填充轴方向上的可用空间。 当排列的视图没有填充 UIStackView 时：UIstackview 会均匀地填充视图之间行间距。即此时的 spaicing 只限定了最小的间距。 当子视图塞不进 UIStackView 时，UIStackView 会根据其抗压优先级收缩视图。 equalCentering 对⼦视图中点等距布局，同时保持⼦视图之间的间距。同样，此时的 spaicing 只限定了最⼩的间距。 当⼦视图塞不进 UIStackView 时，UIStackView 收缩间距，直到达到 spaicing 值。若⼦视图仍塞不进UIStackView，则会根据其抗压优先级收缩子视图 当存在歧义时，UIStackView 会根据其在 arrangedsubviews 中的索引收缩子视图 为了保持⼦视图内容⼤⼩，UIStackView 会突破中点等距布局。同样，为保持⼦视图间的最⼩间距， UIStackView 会压缩⼦视图的内容⼤⼩。 ","date":"2022-08-17","objectID":"/posts/ios-uistackvie%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:2:2","tags":["iOS"],"title":"iOS-UIStackView使用指南","uri":"/posts/ios-uistackvie%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":["iOS"],"content":"UIStackView.Alignment 定义垂直于 UIStackView 轴方向的子视图布局。 对于除 fill 之外的所有 alignment，UIStackView 在计算轴正交方向的大小时使用每个子视图的 intrinsiccontentsize 属性。fill 则调整所有子视图的大小，以填充轴正交方向上的可用空间，如果可能，UIStackView 会拉伸所有子视图，以匹配轴正交方向上最大内在大小的视图。 fill 默认。UIStackView 调整其子视图大小，以填充轴正交方向上的可用空间。 center UIStackView 把⼦视图中点沿轴对⻬，即垂直方向居中对⻬。 leading：横轴时也可以用top UIStackView把子视图沿着前边缘对齐 trailing：横轴时也可以用bottom fisrtBaseline 仅横轴有效，UIStackView根据首个基线对齐排列子视图 lastBaseline 仅纵轴有效，UIStackView根据末尾基线对齐排列子视图 ","date":"2022-08-17","objectID":"/posts/ios-uistackvie%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:2:3","tags":["iOS"],"title":"iOS-UIStackView使用指南","uri":"/posts/ios-uistackvie%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":["iOS"],"content":"Spacing间距 固定间距 var spacing: CGFloat { get set } 默认为0.0，此属性定义了在UIStackViewDistribution.fill子视图之间的严格间距，也是UIStackView.Distribution.equalSpacing 和 UIStackView.Distribution.equalCentering 的最小间距 使用负值会重叠子视图，其堆叠层级按子视图的层级索引排列 更进一步，iOS 11.0+ 还增加了设置自定义间距的方法 // Applies custom spacing after the specified view. func setCustomSpacing(_ spacing: CGFloat, after arrangedSubview: UIView) func customSpacing(after arrangedSubview: UIView) -\u003e CGFloat 通过这个方法可以设置子视图之间的间距，如下图所示，只可以设置两个subView之间的间距，而不可以设置一个subView到supperView的边缘的距离 这个时候可以通过给边缘位置添加一个占位视图的方式来进行相关设置，这里简单封装一个占位视图： import UIKit /// 自定义内容尺寸视图 public class SizeView: UIView { public var size: CGSize = .zero required init?(coder: NSCoder) { super.init(coder: coder) commonInit() } override init(frame: CGRect) { super.init(frame: frame) commonInit() } private func commonInit() { isUserInteractionEnabled = false } public override var intrinsicContentSize: CGSize { size } } public extension SizeView { convenience init(size: CGSize, color: UIColor? = nil) { self.init(frame: .zero) self.size = size backgroundColor = color } /// 尽可能大 static func expanded(width: CGFloat = .greatestFiniteMagnitude, height: CGFloat = .greatestFiniteMagnitude, color: UIColor? = nil) -\u003e SizeView { SizeView(size: CGSize(width: width, height: height), color: color) } /// 尽可能小 static func shrinked(width: CGFloat = 0, height: CGFloat = 0, color: UIColor? = nil) -\u003e SizeView { SizeView(size: CGSize(width: width, height: height), color: color) } } 音乐入口代码如下： noMusicStackView.then { let musicIconView = makeMusicIconView() // 使用占位视图添加左侧间距 $0.addArrangedSubview(SizeView.shrinked(width: 12)) $0.addArrangedSubview(musicIconView) // 使用自定义间距 API 设置 sub view 间的间距 $0.setCustomSpacing(6, after: musicIconView) let addLabel = self.addLabel addLabel.font = UI.textFont addLabel.textColor = UI.textColor addLabel.layer.lv.setupShadow(color: UI.textShadow.color, offset: UI.textShadow.offset, radius: UI.textShadow.radius) $0.addArrangedSubview(addLabel) // 使用占位视图添加右侧间距 $0.addArrangedSubview(SizeView.shrinked(width: 12)) } 效果： ","date":"2022-08-17","objectID":"/posts/ios-uistackvie%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:2:4","tags":["iOS"],"title":"iOS-UIStackView使用指南","uri":"/posts/ios-uistackvie%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":["iOS"],"content":"子视图管理 func addArrangedSubview(_ view: UIView) var arrangedSubviews: [UIView] { get } func insertArrangedSubview(_ view: UIView, at stackIndex: Int) func removeArrangedSubview(_ view: UIView) 上述所有方法都会作用于arrangedSubviews数组，调用UIStackView的addArrangedSubview(_:)时，添加的视图除了添加到 arrangedSubviews 中，同时也会添加到基类的 subviews 中，即成为子视图。 由于 UIStackView 内部会确保 arrangedSubviews 是 subviews 的子集，所以即使在调用 addArrangedSubview(_:) 前调用了基类的 addSubview(_:)，也不会有什么影响，也不会改变其在 arrangedSubviews 中的顺序。但必须要调用 addArrangedSubview(_:) 来添加管理的子视图，否则设置 UIStackView 的各个属性将无法作用于添加的子视图。 移除视图的时候要注意，removeArrangedSubview(_:) 只是从 arrangedSubviews 中移除子视图，即移除的子视图不受 UIStackView 管理，但其还在基类的 subviews 中，即还在视图层级中。所以要直接从层级中移除子视图，可直接使用基类的 removeFromSuperview() 方法。 ","date":"2022-08-17","objectID":"/posts/ios-uistackvie%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:3:0","tags":["iOS"],"title":"iOS-UIStackView使用指南","uri":"/posts/ios-uistackvie%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":["iOS"],"content":"布局管理 UIStackView 会动态响应以下操作，并自动更新布局： 添加、删除或插入到 arrangedSubviews。 修改 UIStackView 定义的所有属性。 修改子视图的 isHidden 属性。其效果跟 UIView 对子视图的效果不一致，当值为 true 时 UIStackView 会重新计算布局（跟移除视图效果一致），还甚至默认添加了动画（轴方向收缩效果），而 UIView 对子视图 isHidden 为 true 时不会有布局更新，更不会有动画。 处理第 1 点管理 arrangedSubviews 的几个方法，第 2、3 点涉及的属性都可以添加动画。另外要控制子视图 isHidden 的时长，可以放到 animate(withDuration:animations:) 中控制。 ","date":"2022-08-17","objectID":"/posts/ios-uistackvie%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:3:1","tags":["iOS"],"title":"iOS-UIStackView使用指南","uri":"/posts/ios-uistackvie%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":["算法模版"],"content":"字符串处理 ","date":"2022-06-12","objectID":"/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95/:1:0","tags":["数据结构与算法","算法模版"],"title":"字符串算法","uri":"/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95/"},{"categories":["算法模版"],"content":"KMP 讲解视频：最浅显易懂的 KMP 算法讲解 vector\u003cint\u003e strStr(string\u0026 str, string\u0026 pattern) { int m = str.length(); int n = pattern.length(); // 构造next数组，next数组是根据模版字符串创建的，默认为-1，即没有前缀能与现在构成的后缀进行匹配 vector\u003cint\u003e ne(n, -1); // 从下标1开始构造，因为下标0一定没有前缀 // i代表的是后缀，j代表的是前缀 for (int i = 1, j = -1; i \u003c n; ++i) { // 找到第一个pattern[i] == pattern[j + 1]的下标j while (j \u003e= 0 \u0026\u0026 pattern[i] != pattern[j + 1]) j = ne[j]; // 如果相同即说明前后缀相匹配 if (pattern[i] == pattern[j + 1]) ++j; // 得到j ne[i] = j; } // ans存储所有匹配上的首字符下标 vector\u003cint\u003e ans; // i是普通字符串下标，j是模版字符串下标，因为需要回退，j初始化为-1 for (int i = 0, j = -1; i \u003c m; ++i) { while (j \u003e= 0 \u0026\u0026 str[i] != pattern[j + 1]) j = ne[j]; // str[i] == pattern[j + 1]匹配上了，j加1 if (j + 1 \u003c n \u0026\u0026 str[i] == pattern[j + 1]) ++j; // j + 1 == n代表匹配完成，首字符下标为i - n + 1 if (j + 1 == n) ans.push_back(i - n + 1); } return ans; } ","date":"2022-06-12","objectID":"/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95/:1:1","tags":["数据结构与算法","算法模版"],"title":"字符串算法","uri":"/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95/"},{"categories":["算法模版"],"content":"字典树Trie 字典树Trie是一种高效地存储和查找字符串集合的数据结构，由“结点”和“带有字符的边〞构成。 典型应用是用于统计和排序大量的字符串（但不仅限于字符串），经常被搜索引擎系统用于文本词频统计。 它的优点是：最大限度地减少无谓的字符串比较，查询效率比哈希表高。 基本性质 结点本身不保存完整单词 从根结点到某一结点，路径上经过的字符连接起来即为该结点对应的单词 每个结点出发的所有边代表的字符都不相同 结点用于存储单词的额外信息（例如频次） 内部实现 字符集数组法（简单） 每个结点保存一个长度固定为字符集大小（例如26）的数组，以字符为下标，保存指向的结点空间复杂度为O(结点数*字符集大小)，查询的时间复杂度为O(单词长度)适用于较小字符集，或者单词短、分布稠密的字典 字符集映射法（优化） 把每个结点上的字符集数组改为一个映射（词频统计：hashmap，排序：ordered map) 空间复杂度为O(文本字符总数)，查询的时间复杂度为O(单词长度)，但常数稍大一些适用性更广 核心思想——空间换时间 无论是保存树的结构、字符集数组还是字符集映射，都需要额外的空间 利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的 分组思想：前缀相同的字符串在同一子树中 模版 一般实现 class Trie { public: Trie() { root = new Node(); } void insert(string word) { Node* cur = root; for (char ch : word) { if (cur-\u003emp.find(ch) == cur-\u003emp.end()) { cur-\u003emp[ch] = new Node(); } cur = cur-\u003emp[ch]; } ++cur-\u003ecount; } bool search(string word) { Node* cur = root; for (char ch : word) { if (cur-\u003emp.find(ch) == cur-\u003emp.end()) return false; cur = cur-\u003emp[ch]; } return cur-\u003ecount \u003e 0; } bool startsWith(string prefix) { Node* cur = root; for (char ch : prefix) { if (cur-\u003emp.find(ch) == cur-\u003emp.end()) return false; cur = cur-\u003emp[ch]; } return true; } private: struct Node { int count; unordered_map\u003cchar, Node*\u003e mp; Node() { count = 0; } }; Node* root; }; 重构实现（更精简） struct Trie { public: /** Initialize your data structure here. */ Trie() { root = new Node(); } /** Inserts a word into the trie. */ void insert(string word) { find(word, true, true); } /** Returns if the word is in the trie. */ bool search(string word) { return find(word, true, false); } /** Returns if there is any word in the trie that starts with the given prefix. */ bool startsWith(string prefix) { return find(prefix, false, false); } private: struct Node { int count; unordered_map\u003cchar, Node*\u003e child; Node() : count(0) {} }; Node* root; bool find(const string\u0026 s, bool exact_match, bool insert_if_not_exist) { Node* curr = root; for (char c : s) { if (curr-\u003echild.find(c) == curr-\u003echild.end()) { if (!insert_if_not_exist) return false; curr-\u003echild[c] = new Node(); } curr = curr-\u003echild[c]; } if (insert_if_not_exist) curr-\u003ecount++; return exact_match ? curr-\u003ecount \u003e 0 : true; } }; ","date":"2022-06-12","objectID":"/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95/:1:2","tags":["数据结构与算法","算法模版"],"title":"字符串算法","uri":"/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95/"},{"categories":["算法模版"],"content":"一道有意思的Trie应用题 最大异或对 在给定的N个整数 A1，A2……An中选出两个进行 xor（异或）运算，得到的结果最大是多少？ 输入格式 第一行输入一个整数 N。 第二行输入N个整数 A1A1～An。 输出格式 输出一个整数表示答案。 数据范围 32位整数，N \u003c= 1e5 #include \u003ciostream\u003e #include \u003ccstring\u003e #include \u003calgorithm\u003e #include \u003cvector\u003e using namespace std; struct Node { Node* child[2]; int number; Node() { number = -1; memset(child, 0, sizeof child); } }; Node* root; void insert(int x) { Node* cur = root; for (int i = 31; i \u003e= 0; --i) { if (x \u0026 (1 \u003c\u003c i)) { if (!cur-\u003echild[1]) { cur-\u003echild[1] = new Node(); } cur = cur-\u003echild[1]; } else { if (!cur-\u003echild[0]) { cur-\u003echild[0] = new Node(); } cur = cur-\u003echild[0]; } } cur-\u003enumber = x; } int cmp(int x) { Node* cur = root; for (int i = 31; i \u003e= 0; --i) { if (x \u0026 (1 \u003c\u003c i)) { cur = cur-\u003echild[0] ? cur-\u003echild[0] : cur-\u003echild[1]; } else { cur = cur-\u003echild[1] ? cur-\u003echild[1] : cur-\u003echild[0]; } } return x ^ cur-\u003enumber; } int main() { int n; cin \u003e\u003e n; int nums[n]; root = new Node(); for (int i = 0; i \u003c n; ++i) { int x; cin \u003e\u003e x; nums[i] = x; insert(x); } int ans = -1; for (int i = 0; i \u003c n; ++i) { ans = max(ans, cmp(nums[i])); } printf(\"%d\\n\", ans); return 0; } ","date":"2022-06-12","objectID":"/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95/:1:3","tags":["数据结构与算法","算法模版"],"title":"字符串算法","uri":"/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95/"},{"categories":["算法模版"],"content":"高精度算法 关于高精度：高精度就是计算结果位数非常多，一般的数字整型无法正常显示，java和Python无需考虑，语法自带即可完成高精度处理 ","date":"2022-06-12","objectID":"/posts/%E9%AB%98%E7%B2%BE%E5%BA%A6%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/:0:0","tags":["数据结构与算法","算法模版"],"title":"高精度算法模版","uri":"/posts/%E9%AB%98%E7%B2%BE%E5%BA%A6%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"},{"categories":["算法模版"],"content":"高精度加法 高精度加法就是用数组来模拟人的加法过程，先加个位，然后十位、百位、千位，每一位都要考虑上一位的进位，由于最后可能还存在一位进位，因此用大端模式存储（即数字的高位在数组的高位，数字的低位在数组的低位，即nums[0]是个位）可以利用数组的push_back()而无需搬移整个数组来在最前面加一位。 vector\u003cint\u003e add(vector\u003cint\u003e\u0026 A, vector\u003cint\u003e\u0026 B) { if (A.size() \u003c B.size()) return add(B, A); vector\u003cint\u003e ans; // i是位数，由低到高分别是个位-\u003e最高位，t是进位 int t = 0; for (int i = 0; i \u003c A.size(); ++i) { int cur = A[i] + (i \u003c B.size() ? B[i] : 0) + t; ans.push_back(cur % 10); t = cur / 10; } if (t) ans.push_back(t); return ans; } ","date":"2022-06-12","objectID":"/posts/%E9%AB%98%E7%B2%BE%E5%BA%A6%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/:0:1","tags":["数据结构与算法","算法模版"],"title":"高精度算法模版","uri":"/posts/%E9%AB%98%E7%B2%BE%E5%BA%A6%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"},{"categories":["算法模版"],"content":"高精度减法 与高精度加法类似，也是从低位减起，不够减需要向高位借位，因此一定要用大的减小的，小的减大的则反过来减然后补负号 用cmp来判断A和B的大小，sub用来做减法，要求大的减小的 // 判断A大于等于B bool cmp(vector\u003cint\u003e\u0026 A, vector\u003cint\u003e\u0026 B) { if (A.size() != B.size()) return A.size() \u003e B.size(); for (int i = A.size() - 1; i \u003e= 0; --i) { if (A[i] \u003e B[i]) return true; else if (A[i] \u003c B[i]) return false; else continue; } return true; } vector\u003cint\u003e sub(vector\u003cint\u003e\u0026 A, vector\u003cint\u003e\u0026 B) { vector\u003cint\u003e ans; // 这里就已经保证了A是大于等于B的 for (int i = 0, t = 0; i \u003c A.size(); ++i) { int cur = A[i] - (i \u003c B.size() ? B[i] : 0) - t; if (cur \u003e= 0) { t = 0; } else { cur += 10; t = 1; } ans.push_back(cur); } while (ans.size() \u003e 1 \u0026\u0026 ans.back() == 0) ans.pop_back(); return ans; } ","date":"2022-06-12","objectID":"/posts/%E9%AB%98%E7%B2%BE%E5%BA%A6%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/:0:2","tags":["数据结构与算法","算法模版"],"title":"高精度算法模版","uri":"/posts/%E9%AB%98%E7%B2%BE%E5%BA%A6%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"},{"categories":["算法模版"],"content":"高精度乘法 和加法非常像，对于高精度数字A和普通数字B，A * B的结果是A中每一位与B相乘的结果相加，注意进位即可 vector\u003cint\u003e mul(vector\u003cint\u003e\u0026 A, int b) { if (b == 0) return {0}; vector\u003cint\u003e ans; for (int i = 0, t = 0; i \u003c A.size() || t; ++i) { if (i \u003c A.size()) t += A[i] * b; ans.push_back(t % 10); t /= 10; } return ans; } ","date":"2022-06-12","objectID":"/posts/%E9%AB%98%E7%B2%BE%E5%BA%A6%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/:0:3","tags":["数据结构与算法","算法模版"],"title":"高精度算法模版","uri":"/posts/%E9%AB%98%E7%B2%BE%E5%BA%A6%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"},{"categories":["算法模版"],"content":"高精度除法 模拟除法，与上述三种的不同在于，除法要先从高位开始除，不够除就是零，✖️10加上下一位继续除 vector\u003cint\u003e div(vector\u003cint\u003e\u0026 A, int b, int\u0026 r) { // A 除 b，r是余数 if (b == 0) return {}; r = 0; vector\u003cint\u003e ans; // 这里依旧是高位表示的是高位 for (int i = A.size() - 1; i \u003e= 0; --i) { r = r * 10 + A[i]; ans.push_back(r / b); r = r % b; } reverse(ans.begin(), ans.end()); while (ans.size() \u003e 1 \u0026\u0026 ans.back() == 0) ans.pop_back(); return ans; } ","date":"2022-06-12","objectID":"/posts/%E9%AB%98%E7%B2%BE%E5%BA%A6%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/:0:4","tags":["数据结构与算法","算法模版"],"title":"高精度算法模版","uri":"/posts/%E9%AB%98%E7%B2%BE%E5%BA%A6%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"},{"categories":["算法模版"],"content":"二分算法 二分的本质是边界，整个区间可以一分为二，左半边满足某性质，右半边不满足某性质，二分就是用来寻找这个边界的方法。 ","date":"2022-06-12","objectID":"/posts/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/:0:0","tags":["数据结构与算法","算法模版"],"title":"二分算法模版","uri":"/posts/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"},{"categories":["算法模版"],"content":"整数二分 做法： 情况一：找到mid = (l + r + 1) / 2 if (check(mid)): true 边界点在 [mid, r]这个范围内，更新方式：l = mid false 边界点在[l, mid - 1]这个范围内，更新方式r = mid - 1 情况二：找到mid = (l + r) / 2 if (check(mid)): true 边界点在 [l, mid]这个范围内，更新方式：r = mid false 边界点在[mid + 1, r]这个范围内，更新方式l = mid + 1 拿到题目： 先写check函数，如果true的时候是l = mid则补上+1，如果true的时候是r = mid则不加一 模版 // 普通二分查找int int binarySearch(const vector\u003cint\u003e\u0026 nums, int target) { int left = 0, right = (int)nums.size() - 1; while (left \u003c= right) { int mid = left + (right - left) / 2; if (nums[mid] == target) return mid; else if (nums[mid] \u003c target) left = mid + 1; else right = mid - 1; } return -1; } // 更通用的二分模板 // LeetCode34 在排序数组中查找元素的第一个和最后一个位置 class Solution { public: vector\u003cint\u003e searchRange(vector\u003cint\u003e\u0026 nums, int target) { vector\u003cint\u003e ans; // 开始位置（lower_bound）：查询第一个\u003e=target的数 // 范围 [0 .. n-1 ] + [n表示不存在] int left = 0, right = nums.size(); while (left \u003c right) { int mid = (left + right) / 2; if (nums[mid] \u003e= target) right = mid; else left = mid + 1; } ans.push_back(right); //第一个\u003e=target的数的下标（不存在为n） // 结束位置：查询最后一个\u003c=target的数 // 范围 [-1表示不存在] + [0 .. n-1 ] left = -1, right = nums.size() - 1; while (left \u003c right) { int mid = (left + right + 1) / 2; if (nums[mid] \u003c= target) left = mid; else right = mid - 1; } ans.push_back(right); //最后一个\u003c=target的数（不存在为-1） // target出现在[ans[0], ans[1]] if (ans[0] \u003e ans[1]) ans = {-1, -1}; return ans; } }; ","date":"2022-06-12","objectID":"/posts/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/:0:1","tags":["数据结构与算法","算法模版"],"title":"二分算法模版","uri":"/posts/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"},{"categories":["算法模版"],"content":"浮点数二分 跟整数二分思路一致，但不用区分是否+1，没有边界问题 // 实数二分模板 // ans = realSqrt(x) // 如果要求4位小数，就多算2~4位，到1e-6或1e-8，保证精确 double realSqrt(double x, double eps = 1e-6) { double left = 0, right = max(x, 1.0); while (right - left \u003e eps) { double mid = (left + right) / 2; if (mid * mid \u003c= x) { left = mid; } else { right = mid; } } return right; } ","date":"2022-06-12","objectID":"/posts/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/:0:2","tags":["数据结构与算法","算法模版"],"title":"二分算法模版","uri":"/posts/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"},{"categories":["算法模版"],"content":"排序算法 ","date":"2022-06-12","objectID":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/:0:0","tags":["数据结构与算法","算法模版"],"title":"排序算法模版","uri":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"},{"categories":["算法模版"],"content":"快速排序（O(nlogn)) 思想：分治 做法： 确定分界点：nums[l]或nums[r]或nums[(l + r) / 2]或随机 调整范围，使得分界点左边的数小于分界点的数值，分界点右边的数大于分界点的数值 递归处理左右两段 void quickSort(vector\u003cint\u003e\u0026 nums, int l, int r) { if (l \u003e= r) return; int x = nums[(l + r) \u003e\u003e 1]; int i = l, j = r; while (i \u003c= j) { while (nums[i] \u003c x) ++i; while (nums[j] \u003e x) --j; if (i \u003e= j) break; swap(nums[i++], nums[j--]); } quickSort(nums, l, j); quickSort(nums, j + 1, r); } ","date":"2022-06-12","objectID":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/:0:1","tags":["数据结构与算法","算法模版"],"title":"排序算法模版","uri":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"},{"categories":["算法模版"],"content":"归并排序(O(nlogn)) 思想：分治 做法： 确定分界点：mid = (l + r) / 2 递归排序左右两端 归并：将左右两段合二为一 void mergeSort(vector\u003cint\u003e\u0026 nums, int l, int r) { if (l \u003e= r) return; int mid = (l + r) \u003e\u003e 1; mergeSort(nums, l, mid); mergeSort(nums, mid + 1, r); // 使用数组，速度快非常多，大概是使用vector的两倍 int n = r - l + 1; int temp[n]; int i = l, j = mid + 1, idx = 0; while (i \u003c= mid \u0026\u0026 j \u003c= r) { temp[idx++] = nums[i] \u003c nums[j] ? nums[i++] : nums[j++]; } while (i \u003c= mid) temp[idx++] = nums[i++]; while (j \u003c= r) temp[idx++] = nums[j++]; for (int i = 0; i \u003c n; ++i) { nums[l + i] = temp[i]; } } ","date":"2022-06-12","objectID":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/:0:2","tags":["数据结构与算法","算法模版"],"title":"排序算法模版","uri":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"},{"categories":["算法模版"],"content":"堆排序(O(nlogn)) 思想：利用小根堆完成排序 做法： 将数组里的所有数扔到堆里 将堆按序输出 #include \u003ciostream\u003e #include \u003cvector\u003e #include \u003cqueue\u003e using namespace std; void HeapSort(vector\u003cint\u003e\u0026 nums) { priority_queue\u003cint, vector\u003cint\u003e, greater\u003cint\u003e\u003e q(nums.begin(), nums.end()); for (int i = 0; i \u003c nums.size(); ++i) { nums[i] = q.top(); q.pop(); } } int main() { vector\u003cint\u003e nums({3, 5, 2, 5, 7, 4, 9, 0}); HeapSort(nums); for (int i : nums) cout \u003c\u003c i \u003c\u003c \" \"; cout \u003c\u003c endl; return 0; } ","date":"2022-06-12","objectID":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/:0:3","tags":["数据结构与算法","算法模版"],"title":"排序算法模版","uri":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"},{"categories":["算法模版"],"content":"计数排序(O(n + k)) 思想：遍历 做法： 确定范围 去数每个数的数量 重构数组 #include \u003calgorithm\u003e #include \u003ciostream\u003e #include \u003cvector\u003e using namespace std; void countSort(vector\u003cint\u003e\u0026 nums) { int maxVal = -1; for (int num : nums) { maxVal = max(maxVal, num); } vector\u003cint\u003e count(maxVal + 1); for (int num : nums) { ++count[num]; } int index = 0; //原数组修改坐标 for (int val = 0; val \u003c count.size(); ++val) { while (count[val] \u003e 0) { --count[val]; nums[index++] = val; } } } int main() { vector\u003cint\u003e test = {4, 5, 2, 1, 4, 2, 3, 4, 4, 0, 8}; for (auto a : test) { cout \u003c\u003c a \u003c\u003c ' '; } cout \u003c\u003c endl; countSort(test); for (auto a : test) { cout \u003c\u003c a \u003c\u003c ' '; } cout \u003c\u003c endl; } ","date":"2022-06-12","objectID":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/:0:4","tags":["数据结构与算法","算法模版"],"title":"排序算法模版","uri":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"},{"categories":["算法模版"],"content":"冒泡排序(O(n^2)) 思想：两遍遍历 做法： 第一层遍历决定开始的位置 每二层遍历将最大值放到数组的最右边 #include \u003ciostream\u003e #include \u003cvector\u003e using namespace std; void BubbleSort(vector\u003cint\u003e\u0026 nums) { int n = nums.size(); if (n \u003c= 1) return; for (int i = 1; i \u003c n; ++i) { bool check = false; for (int j = 1; j \u003c n - i + 1; ++j) { if (nums[j] \u003c nums[j - 1]) { std::swap(nums[j], nums[j - 1]); check = true; } } if (!check) break; } } int main() { vector\u003cint\u003e nums({3, 5, 2, 5, 7, 4, 9, 0}); BubbleSort(nums); for (int i : nums) cout \u003c\u003c i \u003c\u003c \" \"; cout \u003c\u003c endl; return 0; } ","date":"2022-06-12","objectID":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/:0:5","tags":["数据结构与算法","算法模版"],"title":"排序算法模版","uri":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"},{"categories":["算法模版"],"content":"插入排序 思想：将数组分为已排序和未排序两部分，每次将未排序中的第一个数插入到已排序的部分中，未排序的数量为0时排序完成 做法： 数组的首数字为已排序部分，其余部分为未排序部分 两层遍历，将未排序的第一个数字与已排序的部分逐个比较直到插入到合适的位置中 #include \u003ciostream\u003e #include \u003cvector\u003e using namespace std; void InsertSort(vector\u003cint\u003e\u0026 nums) { int n = nums.size(); if (n \u003c= 1) return; for (int i = 1; i \u003c n; ++i) { for (int j = i; j \u003e 0 \u0026\u0026 nums[j] \u003c nums[j - 1]; --j) { swap(nums[j], nums[j - 1]); } } } int main() { vector\u003cint\u003e nums({3, 5, 2, 5, 7, 4, 9, 0}); InsertSort(nums); for (int i : nums) cout \u003c\u003c i \u003c\u003c \" \"; cout \u003c\u003c endl; return 0; } ","date":"2022-06-12","objectID":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/:0:6","tags":["数据结构与算法","算法模版"],"title":"排序算法模版","uri":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"},{"categories":["算法模版"],"content":"选择排序 思想：将将数组分为已排序和未排序两部分，每次将未排序中的最小的元素放到已排序部分的末尾 做法： 已排序部分为无，整个数组都是未排序部分 两层遍历，每次选择一个最小的值放到已排序的末尾 #include \u003ciostream\u003e #include \u003cvector\u003e using namespace std; void SelectSort(vector\u003cint\u003e\u0026 nums) { int n = nums.size(); if (n \u003c= 1) return; for (int i = 0; i \u003c n; ++i) { int idx = i; for (int j = i; j \u003c n; ++j) { if (nums[j] \u003c nums[idx]) { idx = j; } } swap(nums[i], nums[idx]); } } int main() { vector\u003cint\u003e nums({3, 5, 2, 5, 7, 4, 9, 0}); SelectSort(nums); for (int i : nums) cout \u003c\u003c i \u003c\u003c \" \"; cout \u003c\u003c endl; return 0; } ","date":"2022-06-12","objectID":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/:0:7","tags":["数据结构与算法","算法模版"],"title":"排序算法模版","uri":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"},{"categories":["C/C++"],"content":"优先队列——priority_queue ","date":"2022-06-11","objectID":"/posts/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/:0:0","tags":["C/C++"],"title":"优先队列","uri":"/posts/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"categories":["C/C++"],"content":"介绍 普通的队列是一种先进先出的数据结构，元素在队列尾追加，而从队列头删除； 在优先队列中，元素被赋予优先级。当访问元素时，具有最高优先级的元素最先删除。优先队列具有最高级先出 （first in, largest out）的行为特征。 ","date":"2022-06-11","objectID":"/posts/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/:1:0","tags":["C/C++"],"title":"优先队列","uri":"/posts/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"categories":["C/C++"],"content":"使用 首先要包含头文件#include \u003cqueue\u003e, 他和queue不同的就在于我们可以自定义其中数据的优先级, 让优先级高的排在队列前面,优先出队。 ⚠️：优先队列具有队列的所有特性，包括队列的基本操作，只是在这基础上添加了内部的一个排序，它本质是一个堆实现的。 ","date":"2022-06-11","objectID":"/posts/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/:2:0","tags":["C/C++"],"title":"优先队列","uri":"/posts/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"categories":["C/C++"],"content":"基本操作 和队列基本操作相同: top访问队头元素 empty队列是否为空 size返回队列内元素个数 push插入元素到队尾 (并排序) emplace原地构造一个元素并插入队列 pop弹出队头元素 swap交换内容 ","date":"2022-06-11","objectID":"/posts/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/:2:1","tags":["C/C++"],"title":"优先队列","uri":"/posts/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"categories":["C/C++"],"content":"定义（初始化） priority_queue\u003cType, Container, Functional\u003e Type 就是数据类型，Container 就是容器类型（Container必须是用数组实现的容器，比如vector,deque等等，但不能用 list。STL里面默认用的是vector），Functional 就是比较的方式。 当需要用自定义的数据类型时才需要传入这三个参数，使用基本数据类型时，只需要传入数据类型，默认是大顶堆。 一般情况如下： //升序队列，小顶堆 priority_queue \u003cint,vector\u003cint\u003e,greater\u003cint\u003e\u003e q; //降序队列，大顶堆 priority_queue \u003cint,vector\u003cint\u003e,less\u003cint\u003e\u003eq; //greater和less是std实现的两个仿函数（就是使一个类的使用看上去像一个函数。 //其实现就是类中实现一个operator()，这个类就有了类似函数的行为，就是一个仿函数类了） ","date":"2022-06-11","objectID":"/posts/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/:2:2","tags":["C/C++"],"title":"优先队列","uri":"/posts/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"categories":["C/C++"],"content":"例子🌰 ","date":"2022-06-11","objectID":"/posts/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/:3:0","tags":["C/C++"],"title":"优先队列","uri":"/posts/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"categories":["C/C++"],"content":"默认情况 #include\u003ciostream\u003e #include \u003cqueue\u003e using namespace std; int main() { //对于基础类型 默认是大顶堆 priority_queue\u003cint\u003e a; //等同于 priority_queue\u003cint, vector\u003cint\u003e, less\u003cint\u003e \u003e a; priority_queue\u003cint, vector\u003cint\u003e, greater\u003cint\u003e\u003e c; //这样就是小顶堆 priority_queue\u003cstring\u003e b; for (int i = 0; i \u003c 5; i++) { a.push(i); c.push(i); } while (!a.empty()) { cout \u003c\u003c a.top() \u003c\u003c ' '; a.pop(); } cout \u003c\u003c endl; while (!c.empty()) { cout \u003c\u003c c.top() \u003c\u003c ' '; c.pop(); } cout \u003c\u003c endl; b.emplace(\"abc\"); b.emplace(\"abcd\"); b.emplace(\"cbd\"); while (!b.empty()) { cout \u003c\u003c b.top() \u003c\u003c ' '; b.pop(); } cout \u003c\u003c endl; return 0; } 运行结果： 4 3 2 1 0 0 1 2 3 4 cbd abcd abc ","date":"2022-06-11","objectID":"/posts/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/:3:1","tags":["C/C++"],"title":"优先队列","uri":"/posts/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"categories":["C/C++"],"content":"用pair做优先队列的元素 使用pair默认比较规则 pair默认比较规则：先比较第一个元素，第一个相等比较第二个。 #include \u003ciostream\u003e #include \u003cqueue\u003e #include \u003cvector\u003e using namespace std; int main() { priority_queue\u003cpair\u003cint, int\u003e\u003e a; pair\u003cint, int\u003e b(1, 2); pair\u003cint, int\u003e c(1, 3); pair\u003cint, int\u003e d(2, 5); a.push(d); a.push(c); a.push(b); while (!a.empty()) { cout \u003c\u003c a.top().first \u003c\u003c ' ' \u003c\u003c a.top().second \u003c\u003c '\\n'; a.pop(); } } 运行结果： 2 5 1 3 1 2 自定义pair比较规则 可参考博客： 定义比较类，重构operator() // 优先队列中使用 pair, 自定义排序 #define pii pair\u003cint,int\u003e struct cmp { bool operator()(const pii p1, const pii p2) { // 大于号是小顶堆，小于号是大顶堆 return p1.first \u003e p2.first;// first 小的先弹出 } }; 定义比较函数： // 编写比较规则cmp，要求x.first/x.second \u003c y.first/y.second // ⚠️：这里比较规则与实际编写的是反向的 auto cmp = [\u0026](const pair\u003cint, int\u003e\u0026 x, const pair\u003cint, int\u003e\u0026 y) { return arr[x.first] * arr[y.second] \u003e arr[x.second] * arr[y.first]; }; priority_queue\u003cpair\u003cint, int\u003e, vector\u003cpair\u003cint, int\u003e\u003e, decltype(cmp)\u003e q(cmp); ","date":"2022-06-11","objectID":"/posts/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/:3:2","tags":["C/C++"],"title":"优先队列","uri":"/posts/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"categories":["C/C++"],"content":"用自定义类型做优先队列元素的例子 #include \u003ciostream\u003e #include \u003cqueue\u003e using namespace std; //方法1-运算符重载\u003c struct tmp1 { int x; tmp1(int a) { x = a; } bool operator\u003c(const tmp1 \u0026a) const { return x \u003c a.x; //大顶堆 } }; //方法2-重写仿函数 struct tmp2 { bool operator()(tmp1 a, tmp1 b) { return a.x \u003c b.x; //大顶堆 } }; int main() { tmp1 a(1); tmp1 b(2); tmp1 c(3); priority_queue\u003ctmp1\u003e d; d.push(b); d.push(c); d.push(a); while (!d.empty()) { cout \u003c\u003c d.top().x \u003c\u003c '\\n'; d.pop(); } cout \u003c\u003c endl; priority_queue\u003ctmp1, vector\u003ctmp1\u003e, tmp2\u003e f; f.push(b); f.push(c); f.push(a); while (!f.empty()) { cout \u003c\u003c f.top().x \u003c\u003c '\\n'; f.pop(); } } 运行结果： 3 2 1 3 2 1 ","date":"2022-06-11","objectID":"/posts/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/:3:3","tags":["C/C++"],"title":"优先队列","uri":"/posts/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"categories":["C/C++"],"content":" 处理判断字符类 isalpha：判断字符是否为字母 返回值：是字母返回非零，不是字母返回零 使用 cout\u003c\u003cisalpha('a'); //返回非零 cout\u003c\u003cisalpha('2'); //返回0 isalnum：判断是否为字母或数字 cout\u003c\u003cisalnum('a'); //输出非零 cout\u003c\u003cisalnum('2'); // 非零 cout\u003c\u003cisalnum('.'); // 零 islower：判断是否是小写字母 cout\u003c\u003cislower('a'); //非零 cout\u003c\u003cislower('2'); //输出0 cout\u003c\u003cislower('A'); //输出0 isupper：判断是否是大写字母 cout\u003c\u003cisupper('a'); //返回0 cout\u003c\u003cisupper('2'); //返回0 cout\u003c\u003cisupper('A'); //返回非零 tolower：把字符转化为小写 string str= \"THIS IS A STRING\"; for (int i=0; i \u003cstr.size(); i++) str[i] = tolower(str[i]); toupper：把字符转化为大写 string str= \"hahahahaha\"; for (int i=0; i \u003cstr.size(); i++) str[i] = toupper(str[i]); ","date":"2022-06-11","objectID":"/posts/%E5%B8%B8%E7%94%A8c++%E5%87%BD%E6%95%B0/:0:0","tags":["C/C++"],"title":"常用C++函数","uri":"/posts/%E5%B8%B8%E7%94%A8c++%E5%87%BD%E6%95%B0/"},{"categories":["C/C++"],"content":"常用C函数 ","date":"2022-06-10","objectID":"/posts/%E5%B8%B8%E7%94%A8c%E5%87%BD%E6%95%B0/:0:0","tags":["C/C++"],"title":"常用C函数","uri":"/posts/%E5%B8%B8%E7%94%A8c%E5%87%BD%E6%95%B0/"},{"categories":["C/C++"],"content":"文件类函数： fopenh函数（打开文件） 描述：C 库函数 FILE *fopen(const char filename, const char mode)使用给定的模式 mode 打开 filename 所指向的文件。 声明：FILE *fopen(const char *filename, const char *mode) 参数 filename – 这是 C 字符串，包含了要打开的文件名称。 mode – 这是 C 字符串，包含了文件访问模式，模式如下 模式： “r” 打开一个用于读取的文件。该文件必须存在。 “w” 创建一个用于写入的空文件。如果文件名称与已存在的文件相同，则会删除已有文件的内容，文件被视为一个新的空文件。 “a” 追加到一个文件。写操作向文件末尾追加数据。如果文件不存在，则创建文件。 “r+” 打开一个用于更新的文件，可读取也可写入。该文件必须存在。 “w+” 创建一个用于读写的空文件。 “a+” 打开一个用于读取和追加的文件。 返回值：该函数返回一个 FILE 指针。否则返回 NULL，且设置全局变量 errno 来标识错误。 stat函数（检查文件属性） 头文件：#include\u003csys/stat.h\u003e 、#include\u003cuninstd.h\u003e 声明：int stat(const char * file_name, struct stat *buf); 描述：stat()用来将参数file_name 所指的文件状态, 复制到参数buf 所指的结构中 stat结构体说明： struct stat { dev_t st_dev; //device 文件的设备编号 ino_t st_ino; //inode 文件的i-node mode_t st_mode; //protection 文件的类型和存取的权限 nlink_t st_nlink; //number of hard links 连到该文件的硬连接数目, 刚建立的文件值为1. uid_t st_uid; //user ID of owner 文件所有者的用户识别码 gid_t st_gid; //group ID of owner 文件所有者的组识别码 dev_t st_rdev; //device type 若此文件为装置设备文件, 则为其设备编号 off_t st_size; //total size, in bytes 文件大小, 以字节计算 unsigned long st_blksize; //blocksize for filesystem I/O 文件系统的I/O 缓冲区大小. unsigned long st_blocks; //number of blocks allocated 占用文件区块的个数, 每一区块大小为512 个字节. time_t st_atime; //time of lastaccess 文件最近一次被存取或被执行的时间, 一般只有在用mknod、 utime、read、write 与tructate 时改变. time_t st_mtime; //time of last modification 文件最后一次被修改的时间, 一般只有在用mknod、utime 和write时才会改变 time_t st_ctime; //time of last change i-node 最近一次被更改的时间, 此参数会在文件所有者、组、权限被更改时更新 }; stat结构体中的st_mode种类： S_IFMT 0170000 文件类型的位遮罩 S_IFSOCK 0140000 scoket S_IFLNK 0120000 符号连接 S_IFREG 0100000 一般文件 S_IFBLK 0060000 区块装置 S_IFDIR 0040000 目录 S_IFCHR 0020000 字符装置 S_IFIFO 0010000 先进先出 S_ISUID 04000 文件的 (set user-id on execution)位 S_ISGID 02000 文件的 (set group-id on execution)位 S_ISVTX 01000 文件的sticky 位 S_IRUSR (S_IREAD) 00400 文件所有者具可读取权限 S_IWUSR (S_IWRITE)00200 文件所有者具可写入权限 S_IXUSR (S_IEXEC) 00100 文件所有者具可执行权限 S_IRGRP 00040 用户组具可读取权限 S_IWGRP 00020 用户组具可写入权限 S_IXGRP 00010 用户组具可执行权限 S_IROTH 00004 其他用户具可读取权限 S_IWOTH 00002 其他用户具可写入权限 S_IXOTH 00001 其他用户具可执行权限上述的文件类型在 POSIX 中定义了检查这些类型的宏定义 S_ISLNK (st_mode) 判断是否为符号连接 S_ISREG (st_mode) 是否为一般文件 S_ISDIR (st_mode) 是否为目录 S_ISCHR (st_mode) 是否为字符装置文件 S_ISBLK (s3e) 是否为先进先出 S_ISSOCK (st_mode) 是否为socket 若一目录具有sticky 位 (S_ISVTX), 则表示在此目录下的文件只能 被该文件所有者、此目录所有者或root 来删除或改名. 返回值：执行成功则返回0，失败返回-1，错误代码存于errno ","date":"2022-06-10","objectID":"/posts/%E5%B8%B8%E7%94%A8c%E5%87%BD%E6%95%B0/:0:1","tags":["C/C++"],"title":"常用C函数","uri":"/posts/%E5%B8%B8%E7%94%A8c%E5%87%BD%E6%95%B0/"},{"categories":["C/C++"],"content":"字符串类函数： strspn函数（检索第一个不在范围内的字符） 描述：检索字符串 str1 中第一个不在字符串 str2 中出现的字符下标 声明：size_t strspn(const char *str1, const char *str2) 参数： str1 – 要被检索的 C 字符串 str2 – 该字符串包含了要在 str1 中进行匹配的字符列表 返回值：返回 str1 中第一个不在字符串 str2 中出现的字符下标 strcasecmp函数（忽略大小写比较两个字符串） 头文件：#include \u003cstrings.h\u003e 描述：忽略大小比较两个字符串是否相同 声明： int strcasecmp (const char *s1, const char *s2); 返回值：若参数s1和s2字符串相等则返回0。s1大于s2则返回大于0 的值，s1 小于s2 则返回小于0的值 strcmp函数（比较两个字符串) 描述：把 str1 所指向的字符串和 str2 所指向的字符串进行比较 声明：int strcmp(const char *str1, const char *str2) strncmp函数（比较限定字节数的两个字符串） 描述：把 str1 和 str2 进行比较，最多比较前 n 个字节（换言之其实比较的长度是min(n, strlen(str2))) 声明：int strncmp(const char *str1, const char *str2, size_t n) 参数： str1 – 要进行比较的第一个字符串。 str2 – 要进行比较的第二个字符串。 n – 要比较的最大字符数。 返回值： 如果返回值 \u003c 0，则表示 str1 小于 str2。 如果返回值 \u003e 0，则表示 str1 大于 str2。 如果返回值 = 0，则表示 str1 等于 str2。 ","date":"2022-06-10","objectID":"/posts/%E5%B8%B8%E7%94%A8c%E5%87%BD%E6%95%B0/:0:2","tags":["C/C++"],"title":"常用C函数","uri":"/posts/%E5%B8%B8%E7%94%A8c%E5%87%BD%E6%95%B0/"},{"categories":["C/C++"],"content":"时间类函数： gettimeofday函数（获取当前时间） 描述：在C语言中可以使用函数gettimeofday()函数来得到时间，它的精度可以达到微秒。它把目前的时间用tv 结构体返回，当地时区的信息则放到tz所指的结构中 声明：int gettimeofday(struct timeval*tv,struct timezone *tz) 结构体说明 struct timeval{ long tv_sec;/*秒*/ long tv_usec;/*微妙*/ }； struct timezone{ int tz_minuteswest;/*和greenwich 时间差了多少分钟*/ int tz_dsttime;/*type of DST correction*/ } 参数： 在gettimeofday()函数中tv或者tz都可以为空。如果为空则就不返回其对应的结构体 返回值：函数执行成功后返回0，失败后返回-1，错误代码存于errno中 ","date":"2022-06-10","objectID":"/posts/%E5%B8%B8%E7%94%A8c%E5%87%BD%E6%95%B0/:0:3","tags":["C/C++"],"title":"常用C函数","uri":"/posts/%E5%B8%B8%E7%94%A8c%E5%87%BD%E6%95%B0/"},{"categories":["杂谈"],"content":"第一篇博客 ","date":"2022-06-10","objectID":"/posts/first_post/:0:0","tags":["杂谈"],"title":"First_post","uri":"/posts/first_post/"},{"categories":["杂谈"],"content":"1.1简单介绍 这里是一枚励志成为一名优秀的后端开发工程师的同学 未来会逐步将自己以前写的博客迁移过来 ","date":"2022-06-10","objectID":"/posts/first_post/:0:1","tags":["杂谈"],"title":"First_post","uri":"/posts/first_post/"}]