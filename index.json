[{"categories":["C/C++"],"content":"C++的指针 ","date":"2022-08-27","objectID":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/:0:0","tags":["C++语法"],"title":"C++的指针","uri":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/"},{"categories":["C/C++"],"content":"指针的概念 ","date":"2022-08-27","objectID":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/:1:0","tags":["C++语法"],"title":"C++的指针","uri":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/"},{"categories":["C/C++"],"content":"C++中内存单元内容与地址 内存由很多内存单元组成，这些内存单元用于存放各种类型的数据 计算机对内存中的每个内存单元都进行了编号，这个编号就称为内存地址，地址决定了内存单元在内存中的位置 记住这些单元地址不方便，于是C++的编译器就允许通过设置变量的方式来访问这些内存地址，而这个变量就是指针 举例： int a = 5; int* ptr = \u0026a; // 此时ptr存储的变量内容就是a的地址，通过ptr可以间接访问a ","date":"2022-08-27","objectID":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/:1:1","tags":["C++语法"],"title":"C++的指针","uri":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/"},{"categories":["C/C++"],"content":"指针的定义与间接访问操作 指针定义的基本形式：指针本身就是一个变量，只不过它存储的内容是地址。对于类型T，T* ptr 就是在定义一个指向类型为T的指针ptr，这个ptr就可以存储「类型为T的变量的地址」 通过一个指针访问它所指向地址的过程称为间接访问或者引用指针，而这个用于执行间接访问的操作符就是单目运算符* 例如：std::cout \u003c\u003c *ptr \u003c\u003c std::endl;就可以打印出来ptr所指向的值（使用std::cout \u003c\u003c ptr \u003c\u003c std::endl;可以打印出来ptr存储的地址） ","date":"2022-08-27","objectID":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/:1:2","tags":["C++语法"],"title":"C++的指针","uri":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/"},{"categories":["C/C++"],"content":"左值与右值 一个小案例： int main() { // 定义一个数组 char str1[] = {\"Hello, world\"}; char* str2 = \"Hello, world\"; str2 = str1; // str1 = str2; // 这一行如果不注释会报错 return 0; } 上面这个小demo中，str2可以赋值为str1，但是str1并不可以被str2赋值，换言之指针变量的值允许改变而数组变量的值不可以改变，虽然在使用的时候str1和str2区别不大，但在赋值上他俩截然不同，这就是左值与右值。 ","date":"2022-08-27","objectID":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/:2:0","tags":["C++语法"],"title":"C++的指针","uri":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/"},{"categories":["C/C++"],"content":"概念 这里不深究原理，简单从工程的角度上来解读一下左值与右值 左值即可以放到赋值运算符=左边的值，包括设定好的变量、指针等（左值也可以放到=右边） 右值即只能放到赋值运算符=右边的值，它一般是一个数据的本身，不能取到本身的地址，包括字面值常量、数值常量等（右值只能放到=右边） ","date":"2022-08-27","objectID":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/:2:1","tags":["C++语法"],"title":"C++的指针","uri":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/"},{"categories":["C/C++"],"content":"具体分析 左值最常见的情况如函数和数据成员的名字 右值是没有标识符、不可以取地址的表达式，一般也称为临时对象 比如a = b + c，可以通过\u0026a来取a的地址但不可以\u0026(b + c)来取(b + c)的地址，这里的a就是左值，而(b + c)就是右值 ","date":"2022-08-27","objectID":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/:2:2","tags":["C++语法"],"title":"C++的指针","uri":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/"},{"categories":["C/C++"],"content":"C中的指针 这里先简单引入一下C中的指针以及其特点 ","date":"2022-08-27","objectID":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/:3:0","tags":["C++语法"],"title":"C++的指针","uri":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/"},{"categories":["C/C++"],"content":"一般类型的指针T* 这里的T指的是任何一种类型，比如int*指的就是int类型的指针，它指向一个相应类型的对象，存储的内容就是其地址 这个类型也包括函数类型，当对应的类型是函数时，它也就被称为函数指针 ","date":"2022-08-27","objectID":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/:3:1","tags":["C++语法"],"title":"C++的指针","uri":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/"},{"categories":["C/C++"],"content":"指针数组 指针数组首先是一个数组，其里面存储的变量是指针，一般的数组定义时如int a[]，对于指针类型也一样，定义一组指针数组形如T* a[] ","date":"2022-08-27","objectID":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/:3:2","tags":["C++语法"],"title":"C++的指针","uri":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/"},{"categories":["C/C++"],"content":"数组指针 数组指针与指针数组是相反的概念，数组指针首先是一个指针，只是这个指针指向的类型是数组，比如T(*b)[] 其实可以理解为：[]的优先级比*高 ","date":"2022-08-27","objectID":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/:3:3","tags":["C++语法"],"title":"C++的指针","uri":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/"},{"categories":["C/C++"],"content":"const与指针 const与指针真的爱恨纠缠，const和pointer的前后顺序不同就会导致其表达的意思不同，总体上分为两类： const pointer：常量指针，形式为const T* ptr，常量指针表示的是这个指针指向的是一个常量，即指向的对象本身不可以修改，但指针可以更换地址（也即可以更换指向的对象） pointer to const：指针常量，形式为T* const ptr，指针常量表示的是这个指针是一个常量，即指针所存储的地址不可以改变（指向的对象不可以变更），但指向的对象本身可以更改其值 已经在上面的介绍中透露出来了一种速记方式，即按照const与*出现的顺序来判断，const在前就先念常量，*在前就先念指针，同时按照顺序去理解，常量指针——类似于「字符串指针」、「数组指针」即它指向的是常量；而指针常量——则直接按照顺序读即可「指针是常量」。 这里个人推荐尽可能避免使用指针常量，因为它本身确实有些反人类，在代码中会很容易降低可读性，除非必须使用，否则应当避免 ","date":"2022-08-27","objectID":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/:3:4","tags":["C++语法"],"title":"C++的指针","uri":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/"},{"categories":["C/C++"],"content":"指向指针的指针 即一个指针，它存储的地址所对应的对象还是一个地址，形如T** ptr int a = 123; int* b = \u0026a; int** c = \u0026b; ","date":"2022-08-27","objectID":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/:3:5","tags":["C++语法"],"title":"C++的指针","uri":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/"},{"categories":["C/C++"],"content":"野指针与悬空指针 野指针是未初始化的指针，这种指针内存储的地址值是未定义的，会存在两种情况： 访问的地址是无效的：会报错，进程会终止 访问的地址是有效的：但并不知道访问的是哪里的地址，造成程序混乱 解决办法：只要定义一个指针就要对其进行初始化，比如直接赋值为nullptr，在具体使用时再对其赋实际的地址 悬空指针是指针所指的对象已被释放掉的指针，对其访问也会存在与野指针相似的两种情况 解决办法：当析构对象的时候，将指向其的指针设置为nullptr，当然这样子并不一定总是可靠，最好还是通过RAII的方式来管理指针，当析构函数执行时自动执行设置为nullptr的行为，比如使用智能指针 ⚠️：这里给到的提示就是当用指针进行间接访问时，一定要非常非常小心，确保其地址有意义再去使用 ❗️：另外，历史代码中一般使用NULL来表示空指针，但这个本质上是0，是一个数字，仍然存在着一定的问题，因此在C++11中推出了nullptr表示空指针，nullptr无任何实际含义，只表示指针为空，现代C++程序应尽可能使用nullptr ","date":"2022-08-27","objectID":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/:3:6","tags":["C++语法"],"title":"C++的指针","uri":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/"},{"categories":["C/C++"],"content":"C++的资源管理方式——RAII ","date":"2022-08-27","objectID":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/:4:0","tags":["C++语法"],"title":"C++的指针","uri":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/"},{"categories":["C/C++"],"content":"RAII(Resource Acquisition Is Initialization): C++所特有的资源管理方式（部分语言如D、Rust也采纳了RAII），主流语言中唯一一个依赖RAII来做资源管理的 RAII依托于栈和析构函数，来对所有的资源——包括堆内存进行管理。通过使用RAII，使得C++不需要类似于JAVA的垃圾回收机制也可以有效的管理内存分配释放问题。 RAII比较成熟的代表：智能指针（unique_ptr、shared_ptr） ","date":"2022-08-27","objectID":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/:4:1","tags":["C++语法"],"title":"C++的指针","uri":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/"},{"categories":["C/C++"],"content":"内存泄漏 什么是内存泄漏： 程序中通过动态分配（new）的堆内存由于某种原因导致程序未释放或无法释放相应资源而导致的内存资源浪费的情况称为内存泄漏，内存泄漏会导致程序运行期间可用内存的减少，严重者可以导致程序的运行速度减缓甚至崩溃 发生原因和排查方法： 内存泄漏主要发生在堆内存分配方式中，即“配置了内存后，所有指向该内存的指针都遗失了”，没有垃圾回收机制时这块内存就再也无法归还给系统 内存泄漏属于程序运行的问题，无法在编译期间排查，只能通过代码检查以及运行期间内存检测工具进行诊断和判别 解决办法：通过RAII对内存进行管理，一个类构造的时候进行内存申请，在析构的时候进行内存释放，由于一个变量有其作用域，当离开作用域范围时会自动调用析构函数，也就会自动进行内存释放了（典型的做法是使用智能指针来对其进行管理） ","date":"2022-08-27","objectID":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/:4:2","tags":["C++语法"],"title":"C++的指针","uri":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/"},{"categories":["C/C++"],"content":"智能指针 ","date":"2022-08-27","objectID":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/:5:0","tags":["C++语法"],"title":"C++的指针","uri":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/"},{"categories":["C/C++"],"content":"比普通指针更安全的解决方案 之前介绍了普通指针可能会出现的问题，对于这些问题，现代C++一般有两种典型方案： 使用更安全的指针——智能指针 不使用指针，用更安全的方式——使用引用的方式 ","date":"2022-08-27","objectID":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/:5:1","tags":["C++语法"],"title":"C++的指针","uri":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/"},{"categories":["C/C++"],"content":"C++中的智能指针 C++目前一共推出了共四种智能指针，分别是unique_ptr、shared_ptr、weak_ptr以及已经在C++11中被弃用（deprecated）的auto_ptr（在C++17中已经正式被删除） ","date":"2022-08-27","objectID":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/:5:2","tags":["C++语法"],"title":"C++的指针","uri":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/"},{"categories":["C/C++"],"content":"auto_ptr 首先来看一下auto_ptr，它是最早的智能指针，可以比较容易的看出来智能指针的作用与思想，后续的智能指针本质上都是将auto_ptr进行完善与延伸。 基本特性：首先auto_ptr使用方法跟指针一样，内部也相当于存储着一个地址，但对于new expression获得的对象不需要像普通的new的对象一样delete去销毁对象而是在auto_ptr对象销毁时，它所管理的对象也会被自动delete掉，这里还是比较抽象的，举一个简单的例子：在一个函数片段中如果需要new一个对象，那么使用普通指针和智能指针的表现如下： // 普通指针 if (xxx) { test_class* ptr = new test_class(); ... delete ptr; } // 智能指针 if (xxx) { auto_ptr\u003ctest_class\u003e ptr2 (new test_class()); ... } 可以看出来，当使用普通指针的时候，在离开作用域之前需要先delete，而使用智能指针则不用，这是因为智能指针离开作用域时会被销毁，而智能指针被销毁时会自动delete掉它的对象。 所有权转移：如果将auto_ptr传递给另外的智能指针，原来的指针就不再拥有这个对象了，在拷贝/赋值的过程中，会剥夺指针对原对象的内存都控制权，控制权转交给新对象，再将原对象的指针置为nullptr，为了更好展示这个特点以及其可能存在的隐患，看一下下面这个例子 #include \u003ciostream\u003e #include \u003cstring\u003e #include \u003cmemory\u003e using namespace std; class Test { public: explicit Test(string str) : str(std::move(str)) { printf(\"构造成功\\n\"); } ~Test() { printf(\"析构成功\\n\"); } public: void print() { cout \u003c\u003c str \u003c\u003c endl; } private: string str; }; int main() { auto_ptr\u003cTest\u003e strs[3] = { auto_ptr\u003cTest\u003e(new Test(\"C\")), auto_ptr\u003cTest\u003e(new Test(\"C++\")), auto_ptr\u003cTest\u003e(new Test(\"Java\")) }; cout \u003c\u003c \"------first loop------\" \u003c\u003c endl; for (auto\u0026 str_ptr : strs) { str_ptr-\u003eprint(); } strs[1]-\u003eprint(); cout \u003c\u003c \"------second loop------\" \u003c\u003c endl; for (auto str_ptr : strs) { str_ptr-\u003eprint(); } strs[1]-\u003eprint(); printf(\"运行结束\\n\"); return 0; } 运行结果如下： 构造成功 构造成功 构造成功 ------first loop------ C C++ Java C++ ------second loop------ C 析构成功 C++ 析构成功 Java 析构成功 进程已结束,退出代码139 (interrupted by signal 11: SIGSEGV) 可以看到，first loop可以打印出C++，而second loop并没有能够打印出C++，这个就是因为所有权的转移，第一个循环中使用的是引用的方式，因此并没有发生所有权的转移，因此循环结束再次访问没有问题，而第二个循环使用的是值拷贝的方式，这就导致了每一次使用都会使得之前的auto_ptr损失掉自己的所有权，而每一轮循环又会因为这个问题导致new的对象被直接释放掉，进而在第二次循环结束的时候再去访问这个指针，导致了crash被信号中断了，这就意味着auto_ptr其实并不安全。 ","date":"2022-08-27","objectID":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/:5:3","tags":["C++语法"],"title":"C++的指针","uri":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/"},{"categories":["C/C++"],"content":"unique_ptr 在刚刚的auto_ptr中，智能指针与对象有着强耦合关系，如果出现了拷贝智能指针就很有可能会出现之前所讲述的问题，并不想释放掉这个元素但在使用过程中很可能在没有察觉的过程中就完成了释放，导致后续程序错误。为了改进auto_ptr也就提出了unique_ptr。 unique_ptr的所有权是专属所有权，所以unique_ptr管理的内存，智能被一个对象所持有，同时不支持拷贝和赋值 移动语义：unique_ptr禁止了拷贝语义，但有时也需要能够转移所有权，于是提供了移动语义，也即可以使用std::move()语句进行转移所有权。接下来具体看一下，首先同样是之前的例子，将auto_ptr更换为unique_ptr： #include \u003ciostream\u003e #include \u003cstring\u003e #include \u003cmemory\u003e using namespace std; class Test { public: explicit Test(string str) : str(std::move(str)) { printf(\"构造成功\\n\"); } ~Test() { printf(\"析构成功\\n\"); } public: void print() { cout \u003c\u003c str \u003c\u003c endl; } private: string str; }; int main() { unique_ptr\u003cTest\u003e strs[3] = { unique_ptr\u003cTest\u003e(new Test(\"C\")), unique_ptr\u003cTest\u003e(new Test(\"C++\")), unique_ptr\u003cTest\u003e(new Test(\"Java\")) }; cout \u003c\u003c \"------first loop------\" \u003c\u003c endl; for (auto\u0026 str_ptr : strs) { str_ptr-\u003eprint(); } strs[1]-\u003eprint(); cout \u003c\u003c \"------second loop------\" \u003c\u003c endl; for (auto str_ptr : strs) { str_ptr-\u003eprint(); } strs[1]-\u003eprint(); printf(\"运行结束\\n\"); return 0; } 如果这个时候进行编译，会发现程序编译会报错，报错内容在for (auto str_ptr : strs)，报错信息为：Call to implicitly-deleted copy constructor of 'unique_ptr\u003cTest\u003e'，也就是说unique_ptr不支持通过拷贝来构造，通过这种方式就不可以继续使用之前的方式来进行访问了，如果确定要移动走所有权，那么就要显示的使用std::move()进行转移，代码如下： #include \u003ciostream\u003e #include \u003cstring\u003e #include \u003cmemory\u003e using namespace std; class Test { public: explicit Test(string str) : str(std::move(str)) { printf(\"构造成功\\n\"); } ~Test() { printf(\"析构成功\\n\"); } public: void print() { cout \u003c\u003c str \u003c\u003c endl; } private: string str; }; int main() { unique_ptr\u003cTest\u003e strs[3] = { unique_ptr\u003cTest\u003e(new Test(\"C\")), unique_ptr\u003cTest\u003e(new Test(\"C++\")), unique_ptr\u003cTest\u003e(new Test(\"Java\")) }; cout \u003c\u003c \"------first loop------\" \u003c\u003c endl; for (auto\u0026 str_ptr : strs) { str_ptr-\u003eprint(); } strs[1]-\u003eprint(); cout \u003c\u003c \"------second loop------\" \u003c\u003c endl; for (auto\u0026 str_ptr : strs) { auto tmp = std::move(str_ptr); tmp-\u003eprint(); } if (strs[1] != nullptr) { strs[1]-\u003eprint(); } printf(\"运行结束\\n\"); return 0; } 通过明确的移动语义移动走所有权，然后进行使用，析构，当使用明确的移动语义时就可以避免程序员的失误导致对象被释放。另外，unique_ptr也支持了与nullptr进行比较，这一点也是auto_ptr没有的，相比之下也就更安全，另外，在C++11中更加提倡使用工厂模式的工厂函数来生产智能指针，因此在第一段生成unique_ptr的函数那里，将代码更改为： unique_ptr\u003cTest\u003e strs[3] = { std::make_unique\u003cTest\u003e(\"C\"), std::make_unique\u003cTest\u003e(\"C++\"), std::make_unique\u003cTest\u003e(\"Java\") }; 常用的unique_ptr方法： ptr.get()：用于获取原始指针，因为历史的包袱问题，很多时候C++并不能完全使用智能指针，对于需要使用C指针的时候通过get()方法就可以使用普通指针了 ","date":"2022-08-27","objectID":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/:5:4","tags":["C++语法"],"title":"C++的指针","uri":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/"},{"categories":["C/C++"],"content":"shared_ptr与weak_ptr 不论是auto_ptr还是unique_ptr，本质上其实都是一样的，都只允许一个智能指针来访问一个对象，而不允许多个智能指针来访问同一个对象，但如果想像普通指针一样去使用智能指针，那么就必须允许多个智能指针来访问同一个对象，因此也就有了shared_ptr 解决方法：通过「引用计数」机制使得多个智能指针可以访问同一个对象，引用计数就是当有一个智能指针指向该对象时，引用计数加1，当一个智能对象被销毁时引用计数减1，当引用计数减小到0时会释放对象资源然后执行对应的析构函数。（当然引入「引用计数」会存在一定的额外开销，但相比较于它的优势可以忽略不计，除非非常明确不使用shared_ptr会更好，否则使用shared_ptr一定不是一件坏事情） 引用计数的问题——循环引用： 起因：如下图所示，两个类中，A中含有类型B的shared_ptr，B中含有类型A的shared_ptr 这时使用分别new一个类型为A和B的对象A和对象B，并使用ptr A指向对象A，ptrB指向对象B，此时对象A的指针指向对象B，此时对象B的指针指向对象A。当ptrA使用结束时，ptrA释放，对象A的引用计数-1，但因为对象B仍然持有对象A的智能指针，所以引用计数大于0，也就不会析构对象A；接下来ptrB也使用结束，对象B的引用计数-1，但因为之前对象A并没有被析构，因此对象B的引用计数也仍然大于0，因此对象B也没有被析构，这种情况下，ptrA和ptrB都被释放了，但对象A和对象B都没有被析构，同时也没有其他指针指向他们，换言之，已经发生了内存泄漏，因为对象A和对象B不可能再被析构。 解决方法：使用weak_ptr weak_ptr被设计用来和shared_ptr一起使用，它工作在观察者模式，对于它指向的对象是一种弱引用，也就是说它可以获得资源的观测权，像旁观者一样观察资源的使用情况，但是弱引用就代表着它不会增加shared_ptr的引用计数，当被观察的shared_ptr失效之后，相应的weak_ptr也就失效了，如下图所示，虚线代表观察，不增加引用计数 代码示例： 不使用weak_ptr： #include \u003ciostream\u003e #include \u003cmemory\u003e #include \u003cstring\u003e #include \u003cmemory\u003e using namespace std; class B; class A { public: A(shared_ptr\u003cB\u003e ptr = nullptr) : ptr(ptr) { printf(\"A构造完成\\n\"); } ~A() { printf(\"A析构完成\\n\"); } shared_ptr\u003cB\u003e ptr; }; class B { public: B(shared_ptr\u003cA\u003e ptr = nullptr) : ptr(ptr) { printf(\"B构造完成\\n\"); } ~B() { printf(\"B析构完成\\n\"); } shared_ptr\u003cA\u003e ptr; }; int main() { auto ptrA = make_shared\u003cA\u003e(); auto ptrB = make_shared\u003cB\u003e(ptrA); ptrA-\u003eptr = ptrB; } 此时，ptrA和ptrB出现了相互引用，程序结果为： A构造完成 B构造完成 可以看出来并没有发生析构，此时如果将最后一行代码去掉，即ptrA的ptr为nullptr #include \u003ciostream\u003e #include \u003cmemory\u003e #include \u003cstring\u003e #include \u003cmemory\u003e using namespace std; class B; class A { public: A(shared_ptr\u003cB\u003e ptr = nullptr) : ptr(ptr) { printf(\"A构造完成\\n\"); } ~A() { printf(\"A析构完成\\n\"); } shared_ptr\u003cB\u003e ptr; }; class B { public: B(shared_ptr\u003cA\u003e ptr = nullptr) : ptr(ptr) { printf(\"B构造完成\\n\"); } ~B() { printf(\"B析构完成\\n\"); } shared_ptr\u003cA\u003e ptr; }; int main() { auto ptrA = make_shared\u003cA\u003e(); auto ptrB = make_shared\u003cB\u003e(ptrA); // ptrA-\u003eptr = ptrB; } 此时结果为： A构造完成 B构造完成 B析构完成 A析构完成 可以推断出来，只要一方不持有另一方的指针，那么就可以正常析构，而这也就是weak_ptr的基本原理，同时再赋予其观察者的身份，使得其可以正常使用相对应的指针。 使用weak_ptr: #include \u003ciostream\u003e #include \u003cmemory\u003e #include \u003cstring\u003e #include \u003cmemory\u003e using namespace std; class B; class A { public: A(shared_ptr\u003cB\u003e ptr = nullptr) : ptr(ptr) { printf(\"A构造完成\\n\"); } ~A() { printf(\"A析构完成\\n\"); } shared_ptr\u003cB\u003e ptr; }; class B { public: B(shared_ptr\u003cA\u003e ptr = nullptr) : ptr(ptr) { printf(\"B构造完成\\n\"); } ~B() { printf(\"B析构完成\\n\"); } weak_ptr\u003cA\u003e ptr; }; int main() { auto ptrA = make_shared\u003cA\u003e(); auto ptrB = make_shared\u003cB\u003e(ptrA); ptrA-\u003eptr = ptrB; } 这里只需要将B中的ptr指针更改为weak_ptr类型即可以完成实验，实验结果如下： A构造完成 B构造完成 A析构完成 B析构完成 这里有两个地方要注意： 类型B的构造函数其实是运用了隐式转换，另外一方面也可以理解为weak_ptr是通过shared_ptr构造的，它不可以由普通指针构造，要牢记它是一个shared_ptr的观察者 这里实验结果的析构顺序和之前将A的ptr置空的析构顺序是相反的，这里是因为置空时的ptrA被释放时，B中还持有A的智能指针，也就是说引用计数不为0所以一定是先析构B再析构A；而使用weak_ptr时正好相反，B中相当于没持有A的指针而A中持有了B的shared_ptr，所以一定是先析构A再析构B shared_ptr常用函数： ptr.use_count()：返回shared_ptr当前指向对象的引用计数，还是刚刚的例子，我们来看一下使用weak_ptr和不使用weak_ptr在引用计数上的区别： int main() { auto ptrA = make_shared\u003cA\u003e(); auto ptrB = make_shared\u003cB\u003e(ptrA); ptrA-\u003eptr = ptrB; cout \u003c\u003c ptrA.use_count() \u003c\u003c endl; } 不使用weak_ptr执行结果： A构造完成 B构造完成 2 A析构完成 B析构完成 使用weak_ptr执行结果 A构造完成 B构造完成 1 A析构完成 B析构完成 shared_ptr的move语义：对shared_ptr进行std::move()会将这个智能指针的所有内容转移给新指针，同时原指针会被置为nullptr 示例代码如下： int main() { auto ptrA = make_shared\u003cA\u003e(); cout \u003c\u003c ptrA.use_count() \u003c\u003c endl; auto ptr2 = std::move(ptrA); cout \u003c\u003c ptrA.use_count() \u003c\u003c endl; cout \u003c\u003c ptr2.use_count() \u003c\u003c endl; if (ptrA == nullptr) { cout \u003c\u003c \"ptrA已经被置为nullptr\" \u003c\u003c endl; } return 0; } 执行结果如下： A构造完成 1 0 1 ptrA已经被置为nullptr A析构完成 shared_ptr也支持get()方法，使用作用与weak_ptr相同 ","date":"2022-08-27","objectID":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/:5:5","tags":["C++语法"],"title":"C++的指针","uri":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/"},{"categories":["C/C++"],"content":"C++的引用 ","date":"2022-08-27","objectID":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/:6:0","tags":["C++语法"],"title":"C++的指针","uri":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/"},{"categories":["C/C++"],"content":"引用是什么 引用就是一种特殊的指针，是一种不允许修改的指针。 使用指针的坑： 野指针 悬空指针 不知不觉更改了指针的值但却继续使用 使用引用解决的问题： 不存在空引用 必须初始化 一个引用永远指向它初始化的那个对象 ","date":"2022-08-27","objectID":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/:6:1","tags":["C++语法"],"title":"C++的指针","uri":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/"},{"categories":["C/C++"],"content":"引用的基本使用 可以认为引用就是指定变量的别名，在使用时可认为引用即是变量本身 ","date":"2022-08-27","objectID":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/:6:2","tags":["C++语法"],"title":"C++的指针","uri":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/"},{"categories":["C/C++"],"content":"最常用的使用场景 输入到一个函数中，需要更改两个对象的值，比如最简单的交换值swap()程序: void swap(int\u0026 a, int\u0026 b) { int c = a; a = b; b = c; } int main() { int a = 10, b = 20; cout \u003c\u003c \"a: \" \u003c\u003c a \u003c\u003c \", b: \" \u003c\u003c b \u003c\u003c endl; swap(a, b); cout \u003c\u003c \"a: \" \u003c\u003c a \u003c\u003c \", b: \" \u003c\u003c b \u003c\u003c endl; return 0; } 执行结果： a: 10, b: 20 a: 20, b: 10 ","date":"2022-08-27","objectID":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/:6:3","tags":["C++语法"],"title":"C++的指针","uri":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/"},{"categories":["C/C++"],"content":"两个问题的思考 有了指针为什么还需要引用 JAVA只有引用，而C则只有指针，C++则支持指针和引用混合编程 C++之父Bjarne Stroustrup的解释是：为了支持函数运算符重载 有了引用为什么还需要指针 因为这是C++，一定要去兼容C语言，是一种历史遗留问题，像JAVA就可以直接舍弃C语言，因为它并不需要兼容C语言 简单来说，个人认为指针是历史，跑不掉而且在很多场景下更灵活，而引用则更符合人的直觉，使用起来更加顺畅，所有引用的场景确实都可以通过指针实现，但引用是一种更加便捷的工具，都支持不是C++的缺点，反而是优点，而重点则在程序员们要如何去使用这两样工具 ","date":"2022-08-27","objectID":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/:6:4","tags":["C++语法"],"title":"C++的指针","uri":"/posts/c++%E7%9A%84%E6%8C%87%E9%92%88/"},{"categories":["iOS"],"content":"UITableView使用指南，速查手册，快速上手","date":"2022-08-17","objectID":"/posts/ios-uitableview%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/","tags":["iOS"],"title":"iOS-UITableView使用指南","uri":"/posts/ios-uitableview%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":["iOS"],"content":"UITableView使用指南 ","date":"2022-08-17","objectID":"/posts/ios-uitableview%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:0:0","tags":["iOS"],"title":"iOS-UITableView使用指南","uri":"/posts/ios-uitableview%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":["iOS"],"content":"概述 一般遇到大量相同结构的视图进行同一方向排列时，比如一般app的设置页面、通讯录等，使用UITableView是一个非常合适的方案。 ","date":"2022-08-17","objectID":"/posts/ios-uitableview%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:1:0","tags":["iOS"],"title":"iOS-UITableView使用指南","uri":"/posts/ios-uitableview%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":["iOS"],"content":"基本介绍 ","date":"2022-08-17","objectID":"/posts/ios-uitableview%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:2:0","tags":["iOS"],"title":"iOS-UITableView使用指南","uri":"/posts/ios-uitableview%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":["iOS"],"content":"风格样式： 这个属性是UITableView最基本的属性，共有两种 UITableViewStylePlain：默认样式 在 plain 模式下，如果 tableview 有多个 section（分区、分组），组与组之间默认是没有间距的。 同时组头或组尾会有 sticky 效果（粘性效果、悬停效果），即表格滚动时组头与组尾会自动停留，而不是跟随单元格一同移动。 同时plain模式下的tableView可以有一个section索引，作为一个bar在table的右边(例如A ~ Z)。你可以点击一个特定的标签，跳转到目标section。 例如：iOS中「通讯录」就是典型应用 UITableViewStyleGrouped：分组样式 在 grouped 模式下，如果 tableview 有多个 section，组与组之间默认是有间距的。 在表格滚动的同时组头与组尾会随之滚动、不停留，不会有 sticky 效果（粘性效果、悬停效果）。 Group类型默认设置tableView灰色背景色，cell为白色背景色，section外边缘设置浅灰色边框，cell设置浅灰色间隔线 例如：iOS中「设置」就是典型应用 踩坑记录： 在iOS15中，如果使用UITableViewStylePlain样式建立TableView，如果给section添加一个header那么会出现一个现象，就是在这个header上方会出现一个空白区域。这个空白区域是由于在iOS15中UITableView中引入了一个新的属性sectionHeaderTopPadding，这个属性默认是22，如果不需要这块空白，改为0即可，代码如下： let tableView = UITableView() if #available(iOS 15.0, *) { tableView.sectionHeaderTopPadding = 0 } else { // Fallback on earlier versions } ","date":"2022-08-17","objectID":"/posts/ios-uitableview%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:2:1","tags":["iOS"],"title":"iOS-UITableView使用指南","uri":"/posts/ios-uitableview%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":["iOS"],"content":"单元格Cell UITableView的每行数据都是一个UITableViewCell： 每个Cell使用IndexPath来表示位置，换言之UITableView中的数据只有行的概念，没有列的概念 IndexPath又分为section和row，每个section为一组，其中可以包含多个行row。 关于Cell的重用 需要注意的是 TableView 必须使用重用机制 ，当cell滑出屏幕的时候 cell会被系统回收，在下面cell将要显示时会调用之前回收的cell，这样就不必每次都创建销毁，节省内存同时节省时间，如果不使用重用机制，每次都创建新的cell 是非常消耗内存和性能的 // 必须实作的方法：Cell重用，然后设定Cell的内容 func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -\u003e UITableViewCell { // 取得 tableView 目前使用的 cell let cell = tableView.dequeueReusableCell( withIdentifier: \"Cell\", for: indexPath) as UITableViewCell // 设置显示的内容 if let myLabel = cell.textLabel { myLabel.text = \"xxxx\" } return cell } Cell的UI和布局 UITableView中每行数据都是一个UITableViewCell，在这个控件中为了显示更多的信息，iOS已经在其内部设置好了多个子控件以供开发者使用。如果我们查看UITableViewCell的声明文件可以发现在内部有一个UIView控件（contentView，作为其他元素的父控件）两个UILable控件（textLabel、detailTextLabel）、一个UIImage控件（imageView），分别用于容器、显示内容、详情和图片。 如果直接使用UITableViewCell则默认共有四种Style设定： typedef NS_ENUM(NSInteger, UITableViewCellStyle) { UITableViewCellStyleDefault, // 左侧显示textLabel（不显示detailTextLabel），imageView可选（显示在最左边） UITableViewCellStyleValue1, // 左侧显示textLabel、右侧显示detailTextLabel（默认蓝色），imageView可选（显示在最左边） UITableViewCellStyleValue2, // 左侧依次显示textLabel(默认蓝色)和detailTextLabel，imageView可选（显示在最左边） UITableViewCellStyleSubtitle // 左上方显示textLabel，左下方显示detailTextLabel（默认灰色）,imageView可选（显示在最左边） }; Cell的属性 accessoryView 在contentView的右边，还有一个accessoryView，这个View是用来作为功能键使用，在iOS中称为访问器，支持显示不同的图标，点击可以触发不同的事件 这个View的设定是通过设置UITableViewCell中的accesoryType属性完成的： public enum AccessoryType : Int, @unchecked Sendable { case none = 0 // 不显示任何图标 case disclosureIndicator = 1 // 跳转指示图标 case detailDisclosureButton = 2 // 内容详情图标和跳转指示图标 case checkmark = 3 // 勾选图标 @available(iOS 7.0, *) case detailButton = 4 // 内容详情图标 } 默认情况如图所示： Cell的分割线 // 设置分割线端距，这里表示separator离左边和右边均80像素 myTableView.separatorInset = UIEdgeInsets(top: 0, left: 40, bottom: 0, right: 40) myTableView.separatorStyle = .singleLine // 分割线的样式 myTableView.separatorColor = .red // 分割线颜色 隐藏部分Cell的分割线 因为TableView的风格设置是针对整个tableView的，如果设置myTableView.separatorStyle = .singleLine，则所有的cell都会有分割线，如果要隐藏部分cell的话就需要一点点小trick 在要显示cell的时候将cell的分割线inset左右各设为cell宽度的一半 func tableView(_ tableView: UITableView, willDisplay cell: UITableViewCell, forRowAt indexPath: IndexPath) { if indexPath.section == 1 { cell.separatorInset = .init(top: 0, left: cell.bounds.width / 2, bottom: 0, right: cell.bounds.width / 2) } } Cell选中样式 // cell的选中样式 cell.selectionStyle = .default // 默认点击时为灰色 cell.selectionStyle = .none // 设置为none点击时无反应 // 这里要注意一下，其实还有.grey和.blue但效果和.default是相同的 // 在iOS7的时候更改了，然后如果想要设置为其他颜色，则要设置selectedBackgroundView // cell的选中样式为其他颜色 cell.selectionStyle = .default cell.selectedBackgroundView = UIView() cell.selectedBackgroundView?.backgroundColor = .blue UITableView的使用： 在controller中引入UITableView类型的变量，然后设置相应的数据源和代理： tableView.delegate = self tableView.datasource = self 表格分组section的DataSource方法的调用时序： DataSource数据源：需要在Controller引入UITableViewDataSource协议 返回表格视图的Section数：numberOfSections func numberOfSections(in tableView: UITableView) -\u003e Int { // 返回section的数量 return 1 } 设置 section中的row行的个数： func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -\u003e Int { // 返回Section中的row行数 return 1 } 返回Section的头部View： func tableView(_ tableView: UITableView, viewForHeaderInSection section: Int) -\u003e UIView? { // 返回对应Section的头部 return UIView() } 返回Section的尾部View： func tableView(_ tableView: UITableView, viewForFooterInSection section: Int) -\u003e UIView? { // 返回对应Section的尾部 return UIView() } UITableViewDelegate：需要在Controller引入UITableViewDelegate协议 返回每个cell对应的行高： func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -\u003e CGFloat { if indexPath.section == 0 { // section0 的cell行高为70 return 70 } else if indexPath.section == 1 { // section1 的cell行高为140 return 140 } // 默认行高 return 106 } 返回Section头部的高度： func tableView(_ tableView: UITableView, heightForHeaderInSection section: Int) -\u003e CGFloat { if section == 0 { return 0.01 } if (isShowUrlCell \u0026\u0026 section == 5) || (!isShowUrlCell \u0026\u0026 section ==","date":"2022-08-17","objectID":"/posts/ios-uitableview%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:2:2","tags":["iOS"],"title":"iOS-UITableView使用指南","uri":"/posts/ios-uitableview%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":["iOS"],"content":"UIStackView使用指南 ","date":"2022-08-17","objectID":"/posts/ios-uistackvie%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:0:0","tags":["iOS"],"title":"iOS-UIStackView使用指南","uri":"/posts/ios-uistackvie%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":["iOS"],"content":"概述 一般遇到两个或以上的控件进行一行或一列布局时，或行列组合成卡片形式的布局时，使用 UIStackView 是最简单有效的方案，例如一些 tab 的展示时，可简单使用 UIStackView + UIScrollView 实现。当然要排列的控件比较多，且需要分页加载的时候，请考虑使用 UICollectionView。 所以这里的 Stack 不是堆栈的意思，也不存在压栈、弹栈的操作，可以理解为“堆叠”。UIStackView实现了U界面×轴和丫轴方向上的堆叠。类比理解，Swiftul 带来的 ZStack 就是Z轴方向上的视图堆叠。 一图概之： 基本要点： 基于 Auto Layout 布局子视图。UIStackView 自身也需要使用 Auto Layout 布局，使用 frame 布局可能效果不一定符合预期。 开发者负责定义 UIStackView 的位置和尺寸（可选），UIStackView 自身管理子视图的内容布局和自身大小，即至少给 UIStackView 添加两个邻边的位置约束。 可动态修改所有属性。 阄割了 UView 基类的一些特性，如设置 backgroundColor UIStackView 是 Apple 基于 Flexbox 思想来实现的布局，虽然是以一个控件 （UlView 子类）呈现，但它做的更多是布局其加入子视图。这种布局思想更接近物理世界的直觉。 Flexbox 在2009 年被W3C 提出，可以很简单、完整地实现各种页面布局，而且还是响应式的，开始被应用于前端领域，目前所有浏览器都已支持。后来通过 React Native 和 Weex等框架，它被带入到客户端开发中，同时支持了 i0s 和 Android。想了解 Flexbax 的详细 CSS布局，可参阅 Flex 布局教程：语法篇-阮一峰的网络日志。 要想更直观地体验把玩 Flexbox 布局，可参阅以下链接： display: flex Flexbox Froggy - A game for learning CSS flexbox Flexy Boxes — CSS flexbox playground and code generation tool 要想在iOS完整体验 Flexbox 布局，可使用 Texture 中的 ASStackLayoutSpec。一些聪明的开发者通过UICollectionViewLayout也实现了简单的 Flexbox 布局，如 UICollectionViewFlexboxLayouto SwiftUl也引入了些 Flexbox 布局，如 HStack、 vStack 和 ZStack，可参阅 Building layouts with UIStackViews 简单体验其为布局带来的便利 ","date":"2022-08-17","objectID":"/posts/ios-uistackvie%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:1:0","tags":["iOS"],"title":"iOS-UIStackView使用指南","uri":"/posts/ios-uistackvie%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":["iOS"],"content":"内容自适应规则 一句话概括：subview content size + spacing。 UIStackView 沿轴方向长度 = 所有排列子视图大小之和 + 子视图之间的间距总和 UIStackView 正交轴方向（垂直于轴方向）长度 = 最大排列子视图的长度 若 isLayoutwarginsReLativeArrangement 为 true，上述的长度还会包含相关的 layoutMargins 上面所说的长度都是拟合大小 （fitting size) 注意: 这里的子视图大小是视图的 content size，内容大小，是指 Auto Layout 约束计算之后的 size，所以直接设置 frame是无效的，必须通过重写 intrinsieContentsize 属性或给子视图的宽高添加 Auto Layout 约束 这里还隐含了一些潜规则： 让 UIStackView 能自适应子视图大小的前提是子视图要有 content size。 最终子视图的 size 也不一定等于 content size，当 UIStackView 自身设置了宽高约束，其会为了填充空间会对子视图进行拉伸或收缩。 自适应子视图大小意味着其不允许子视图溢出其自身。这与 CSS flexbox 的 flex-wrap 表现有别。 另外 UIStackView 的这些布局属性会直接影响其自适应的大小： axis：定义了堆叠的轴方向，是在垂直方向还是水平方向进行堆叠。 distribution：定义了轴方向上的子视图布局。 alignment：定义了轴正交方向上的子视图布局。 spacing：定义了轴方向上的子视图之间的最小间距。 isBaselineRelativeArrangement：定义了视图之间的垂直间距是否从基线测量 isLayoutMarginsRelativeArrangement：定义了是否要基于子视图的 LayoutMargins 来布局 若修改上述属性无法达到你的预期效果，则优先检查 Xcode 控制台是否输出了 Auto Layout 约束冲突的错误日志，从中检查需要修改的属性或补充的约束。 ","date":"2022-08-17","objectID":"/posts/ios-uistackvie%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:2:0","tags":["iOS"],"title":"iOS-UIStackView使用指南","uri":"/posts/ios-uistackvie%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":["iOS"],"content":"NSLayoutConstraint.Axis 默认为horizontal水平方向 ","date":"2022-08-17","objectID":"/posts/ios-uistackvie%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:2:1","tags":["iOS"],"title":"iOS-UIStackView使用指南","uri":"/posts/ios-uistackvie%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":["iOS"],"content":"UIStackView.Distribution 定义沿 UIStackView 轴方向的子视图的大小和位置的布局。 除了 fillEqually 以外的 distribution，UStackView 在沿轴方向计算尺寸时，会使用每个子视图的 intrinsicContentsize 属性。而 fiLLEqually 会相等调整子视图的大小，使其在轴方向的长度是一致的，如果可能，UIStackView 会拉伸所有子视图，以匹配轴方向最大内容大小的视图。 fill 默认情况，UIStackView 调整其子视图的大小,以填充轴方向上的可用空间 当子视图塞不进 UIStackView 时,UIStackView 根据其抗压优先级 (compression resistance priority) 收缩视图 当子视图没有塞满UIStackView时，UIStackView根据其拥抱优先级(hugging priority)拉伸时图 当存在歧义时,UIStackView 根据子视图在 arrangedSubviews 中的索引调整子视图的大小 fillEqually UIStackView 调整其子视图的大小，以填充轴方向上的可用空间。子视图会拉伸调整大小（匹配最大的子视图），以保持轴方向上的大小都相等。 fillPropertionlly UIStackView 调整其子视图的大小，以填充轴方向上的可用空间。视图根据其沿 UIStackView 轴的内在内容大小按比例调整大小。 equalSpacing UIStackView 放置排列子视图，以填充轴方向上的可用空间。 当排列的视图没有填充 UIStackView 时：UIstackview 会均匀地填充视图之间行间距。即此时的 spaicing 只限定了最小的间距。 当子视图塞不进 UIStackView 时，UIStackView 会根据其抗压优先级收缩视图。 equalCentering 对⼦视图中点等距布局，同时保持⼦视图之间的间距。同样，此时的 spaicing 只限定了最⼩的间距。 当⼦视图塞不进 UIStackView 时，UIStackView 收缩间距，直到达到 spaicing 值。若⼦视图仍塞不进UIStackView，则会根据其抗压优先级收缩子视图 当存在歧义时，UIStackView 会根据其在 arrangedsubviews 中的索引收缩子视图 为了保持⼦视图内容⼤⼩，UIStackView 会突破中点等距布局。同样，为保持⼦视图间的最⼩间距， UIStackView 会压缩⼦视图的内容⼤⼩。 ","date":"2022-08-17","objectID":"/posts/ios-uistackvie%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:2:2","tags":["iOS"],"title":"iOS-UIStackView使用指南","uri":"/posts/ios-uistackvie%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":["iOS"],"content":"UIStackView.Alignment 定义垂直于 UIStackView 轴方向的子视图布局。 对于除 fill 之外的所有 alignment，UIStackView 在计算轴正交方向的大小时使用每个子视图的 intrinsiccontentsize 属性。fill 则调整所有子视图的大小，以填充轴正交方向上的可用空间，如果可能，UIStackView 会拉伸所有子视图，以匹配轴正交方向上最大内在大小的视图。 fill 默认。UIStackView 调整其子视图大小，以填充轴正交方向上的可用空间。 center UIStackView 把⼦视图中点沿轴对⻬，即垂直方向居中对⻬。 leading：横轴时也可以用top UIStackView把子视图沿着前边缘对齐 trailing：横轴时也可以用bottom fisrtBaseline 仅横轴有效，UIStackView根据首个基线对齐排列子视图 lastBaseline 仅纵轴有效，UIStackView根据末尾基线对齐排列子视图 ","date":"2022-08-17","objectID":"/posts/ios-uistackvie%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:2:3","tags":["iOS"],"title":"iOS-UIStackView使用指南","uri":"/posts/ios-uistackvie%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":["iOS"],"content":"Spacing间距 固定间距 var spacing: CGFloat { get set } 默认为0.0，此属性定义了在UIStackViewDistribution.fill子视图之间的严格间距，也是UIStackView.Distribution.equalSpacing 和 UIStackView.Distribution.equalCentering 的最小间距 使用负值会重叠子视图，其堆叠层级按子视图的层级索引排列 更进一步，iOS 11.0+ 还增加了设置自定义间距的方法 // Applies custom spacing after the specified view. func setCustomSpacing(_ spacing: CGFloat, after arrangedSubview: UIView) func customSpacing(after arrangedSubview: UIView) -\u003e CGFloat 通过这个方法可以设置子视图之间的间距，如下图所示，只可以设置两个subView之间的间距，而不可以设置一个subView到supperView的边缘的距离 这个时候可以通过给边缘位置添加一个占位视图的方式来进行相关设置，这里简单封装一个占位视图： import UIKit /// 自定义内容尺寸视图 public class SizeView: UIView { public var size: CGSize = .zero required init?(coder: NSCoder) { super.init(coder: coder) commonInit() } override init(frame: CGRect) { super.init(frame: frame) commonInit() } private func commonInit() { isUserInteractionEnabled = false } public override var intrinsicContentSize: CGSize { size } } public extension SizeView { convenience init(size: CGSize, color: UIColor? = nil) { self.init(frame: .zero) self.size = size backgroundColor = color } /// 尽可能大 static func expanded(width: CGFloat = .greatestFiniteMagnitude, height: CGFloat = .greatestFiniteMagnitude, color: UIColor? = nil) -\u003e SizeView { SizeView(size: CGSize(width: width, height: height), color: color) } /// 尽可能小 static func shrinked(width: CGFloat = 0, height: CGFloat = 0, color: UIColor? = nil) -\u003e SizeView { SizeView(size: CGSize(width: width, height: height), color: color) } } 音乐入口代码如下： noMusicStackView.then { let musicIconView = makeMusicIconView() // 使用占位视图添加左侧间距 $0.addArrangedSubview(SizeView.shrinked(width: 12)) $0.addArrangedSubview(musicIconView) // 使用自定义间距 API 设置 sub view 间的间距 $0.setCustomSpacing(6, after: musicIconView) let addLabel = self.addLabel addLabel.font = UI.textFont addLabel.textColor = UI.textColor addLabel.layer.lv.setupShadow(color: UI.textShadow.color, offset: UI.textShadow.offset, radius: UI.textShadow.radius) $0.addArrangedSubview(addLabel) // 使用占位视图添加右侧间距 $0.addArrangedSubview(SizeView.shrinked(width: 12)) } 效果： ","date":"2022-08-17","objectID":"/posts/ios-uistackvie%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:2:4","tags":["iOS"],"title":"iOS-UIStackView使用指南","uri":"/posts/ios-uistackvie%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":["iOS"],"content":"子视图管理 func addArrangedSubview(_ view: UIView) var arrangedSubviews: [UIView] { get } func insertArrangedSubview(_ view: UIView, at stackIndex: Int) func removeArrangedSubview(_ view: UIView) 上述所有方法都会作用于arrangedSubviews数组，调用UIStackView的addArrangedSubview(_:)时，添加的视图除了添加到 arrangedSubviews 中，同时也会添加到基类的 subviews 中，即成为子视图。 由于 UIStackView 内部会确保 arrangedSubviews 是 subviews 的子集，所以即使在调用 addArrangedSubview(_:) 前调用了基类的 addSubview(_:)，也不会有什么影响，也不会改变其在 arrangedSubviews 中的顺序。但必须要调用 addArrangedSubview(_:) 来添加管理的子视图，否则设置 UIStackView 的各个属性将无法作用于添加的子视图。 移除视图的时候要注意，removeArrangedSubview(_:) 只是从 arrangedSubviews 中移除子视图，即移除的子视图不受 UIStackView 管理，但其还在基类的 subviews 中，即还在视图层级中。所以要直接从层级中移除子视图，可直接使用基类的 removeFromSuperview() 方法。 ","date":"2022-08-17","objectID":"/posts/ios-uistackvie%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:3:0","tags":["iOS"],"title":"iOS-UIStackView使用指南","uri":"/posts/ios-uistackvie%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":["iOS"],"content":"布局管理 UIStackView 会动态响应以下操作，并自动更新布局： 添加、删除或插入到 arrangedSubviews。 修改 UIStackView 定义的所有属性。 修改子视图的 isHidden 属性。其效果跟 UIView 对子视图的效果不一致，当值为 true 时 UIStackView 会重新计算布局（跟移除视图效果一致），还甚至默认添加了动画（轴方向收缩效果），而 UIView 对子视图 isHidden 为 true 时不会有布局更新，更不会有动画。 处理第 1 点管理 arrangedSubviews 的几个方法，第 2、3 点涉及的属性都可以添加动画。另外要控制子视图 isHidden 的时长，可以放到 animate(withDuration:animations:) 中控制。 ","date":"2022-08-17","objectID":"/posts/ios-uistackvie%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:3:1","tags":["iOS"],"title":"iOS-UIStackView使用指南","uri":"/posts/ios-uistackvie%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":["算法模版"],"content":"字符串处理 ","date":"2022-06-12","objectID":"/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95/:1:0","tags":["数据结构与算法","算法模版"],"title":"字符串算法","uri":"/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95/"},{"categories":["算法模版"],"content":"KMP 讲解视频：最浅显易懂的 KMP 算法讲解 vector\u003cint\u003e strStr(string\u0026 str, string\u0026 pattern) { int m = str.length(); int n = pattern.length(); // 构造next数组，next数组是根据模版字符串创建的，默认为-1，即没有前缀能与现在构成的后缀进行匹配 vector\u003cint\u003e ne(n, -1); // 从下标1开始构造，因为下标0一定没有前缀 // i代表的是后缀，j代表的是前缀 for (int i = 1, j = -1; i \u003c n; ++i) { // 找到第一个pattern[i] == pattern[j + 1]的下标j while (j \u003e= 0 \u0026\u0026 pattern[i] != pattern[j + 1]) j = ne[j]; // 如果相同即说明前后缀相匹配 if (pattern[i] == pattern[j + 1]) ++j; // 得到j ne[i] = j; } // ans存储所有匹配上的首字符下标 vector\u003cint\u003e ans; // i是普通字符串下标，j是模版字符串下标，因为需要回退，j初始化为-1 for (int i = 0, j = -1; i \u003c m; ++i) { while (j \u003e= 0 \u0026\u0026 str[i] != pattern[j + 1]) j = ne[j]; // str[i] == pattern[j + 1]匹配上了，j加1 if (j + 1 \u003c n \u0026\u0026 str[i] == pattern[j + 1]) ++j; // j + 1 == n代表匹配完成，首字符下标为i - n + 1 if (j + 1 == n) ans.push_back(i - n + 1); } return ans; } ","date":"2022-06-12","objectID":"/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95/:1:1","tags":["数据结构与算法","算法模版"],"title":"字符串算法","uri":"/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95/"},{"categories":["算法模版"],"content":"字典树Trie 字典树Trie是一种高效地存储和查找字符串集合的数据结构，由“结点”和“带有字符的边〞构成。 典型应用是用于统计和排序大量的字符串（但不仅限于字符串），经常被搜索引擎系统用于文本词频统计。 它的优点是：最大限度地减少无谓的字符串比较，查询效率比哈希表高。 基本性质 结点本身不保存完整单词 从根结点到某一结点，路径上经过的字符连接起来即为该结点对应的单词 每个结点出发的所有边代表的字符都不相同 结点用于存储单词的额外信息（例如频次） 内部实现 字符集数组法（简单） 每个结点保存一个长度固定为字符集大小（例如26）的数组，以字符为下标，保存指向的结点空间复杂度为O(结点数*字符集大小)，查询的时间复杂度为O(单词长度)适用于较小字符集，或者单词短、分布稠密的字典 字符集映射法（优化） 把每个结点上的字符集数组改为一个映射（词频统计：hashmap，排序：ordered map) 空间复杂度为O(文本字符总数)，查询的时间复杂度为O(单词长度)，但常数稍大一些适用性更广 核心思想——空间换时间 无论是保存树的结构、字符集数组还是字符集映射，都需要额外的空间 利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的 分组思想：前缀相同的字符串在同一子树中 模版 一般实现 class Trie { public: Trie() { root = new Node(); } void insert(string word) { Node* cur = root; for (char ch : word) { if (cur-\u003emp.find(ch) == cur-\u003emp.end()) { cur-\u003emp[ch] = new Node(); } cur = cur-\u003emp[ch]; } ++cur-\u003ecount; } bool search(string word) { Node* cur = root; for (char ch : word) { if (cur-\u003emp.find(ch) == cur-\u003emp.end()) return false; cur = cur-\u003emp[ch]; } return cur-\u003ecount \u003e 0; } bool startsWith(string prefix) { Node* cur = root; for (char ch : prefix) { if (cur-\u003emp.find(ch) == cur-\u003emp.end()) return false; cur = cur-\u003emp[ch]; } return true; } private: struct Node { int count; unordered_map\u003cchar, Node*\u003e mp; Node() { count = 0; } }; Node* root; }; 重构实现（更精简） struct Trie { public: /** Initialize your data structure here. */ Trie() { root = new Node(); } /** Inserts a word into the trie. */ void insert(string word) { find(word, true, true); } /** Returns if the word is in the trie. */ bool search(string word) { return find(word, true, false); } /** Returns if there is any word in the trie that starts with the given prefix. */ bool startsWith(string prefix) { return find(prefix, false, false); } private: struct Node { int count; unordered_map\u003cchar, Node*\u003e child; Node() : count(0) {} }; Node* root; bool find(const string\u0026 s, bool exact_match, bool insert_if_not_exist) { Node* curr = root; for (char c : s) { if (curr-\u003echild.find(c) == curr-\u003echild.end()) { if (!insert_if_not_exist) return false; curr-\u003echild[c] = new Node(); } curr = curr-\u003echild[c]; } if (insert_if_not_exist) curr-\u003ecount++; return exact_match ? curr-\u003ecount \u003e 0 : true; } }; ","date":"2022-06-12","objectID":"/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95/:1:2","tags":["数据结构与算法","算法模版"],"title":"字符串算法","uri":"/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95/"},{"categories":["算法模版"],"content":"一道有意思的Trie应用题 最大异或对 在给定的N个整数 A1，A2……An中选出两个进行 xor（异或）运算，得到的结果最大是多少？ 输入格式 第一行输入一个整数 N。 第二行输入N个整数 A1A1～An。 输出格式 输出一个整数表示答案。 数据范围 32位整数，N \u003c= 1e5 #include \u003ciostream\u003e #include \u003ccstring\u003e #include \u003calgorithm\u003e #include \u003cvector\u003e using namespace std; struct Node { Node* child[2]; int number; Node() { number = -1; memset(child, 0, sizeof child); } }; Node* root; void insert(int x) { Node* cur = root; for (int i = 31; i \u003e= 0; --i) { if (x \u0026 (1 \u003c\u003c i)) { if (!cur-\u003echild[1]) { cur-\u003echild[1] = new Node(); } cur = cur-\u003echild[1]; } else { if (!cur-\u003echild[0]) { cur-\u003echild[0] = new Node(); } cur = cur-\u003echild[0]; } } cur-\u003enumber = x; } int cmp(int x) { Node* cur = root; for (int i = 31; i \u003e= 0; --i) { if (x \u0026 (1 \u003c\u003c i)) { cur = cur-\u003echild[0] ? cur-\u003echild[0] : cur-\u003echild[1]; } else { cur = cur-\u003echild[1] ? cur-\u003echild[1] : cur-\u003echild[0]; } } return x ^ cur-\u003enumber; } int main() { int n; cin \u003e\u003e n; int nums[n]; root = new Node(); for (int i = 0; i \u003c n; ++i) { int x; cin \u003e\u003e x; nums[i] = x; insert(x); } int ans = -1; for (int i = 0; i \u003c n; ++i) { ans = max(ans, cmp(nums[i])); } printf(\"%d\\n\", ans); return 0; } ","date":"2022-06-12","objectID":"/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95/:1:3","tags":["数据结构与算法","算法模版"],"title":"字符串算法","uri":"/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95/"},{"categories":["算法模版"],"content":"高精度算法 关于高精度：高精度就是计算结果位数非常多，一般的数字整型无法正常显示，java和Python无需考虑，语法自带即可完成高精度处理 ","date":"2022-06-12","objectID":"/posts/%E9%AB%98%E7%B2%BE%E5%BA%A6%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/:0:0","tags":["数据结构与算法","算法模版"],"title":"高精度算法模版","uri":"/posts/%E9%AB%98%E7%B2%BE%E5%BA%A6%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"},{"categories":["算法模版"],"content":"高精度加法 高精度加法就是用数组来模拟人的加法过程，先加个位，然后十位、百位、千位，每一位都要考虑上一位的进位，由于最后可能还存在一位进位，因此用大端模式存储（即数字的高位在数组的高位，数字的低位在数组的低位，即nums[0]是个位）可以利用数组的push_back()而无需搬移整个数组来在最前面加一位。 vector\u003cint\u003e add(vector\u003cint\u003e\u0026 A, vector\u003cint\u003e\u0026 B) { if (A.size() \u003c B.size()) return add(B, A); vector\u003cint\u003e ans; // i是位数，由低到高分别是个位-\u003e最高位，t是进位 int t = 0; for (int i = 0; i \u003c A.size(); ++i) { int cur = A[i] + (i \u003c B.size() ? B[i] : 0) + t; ans.push_back(cur % 10); t = cur / 10; } if (t) ans.push_back(t); return ans; } ","date":"2022-06-12","objectID":"/posts/%E9%AB%98%E7%B2%BE%E5%BA%A6%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/:0:1","tags":["数据结构与算法","算法模版"],"title":"高精度算法模版","uri":"/posts/%E9%AB%98%E7%B2%BE%E5%BA%A6%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"},{"categories":["算法模版"],"content":"高精度减法 与高精度加法类似，也是从低位减起，不够减需要向高位借位，因此一定要用大的减小的，小的减大的则反过来减然后补负号 用cmp来判断A和B的大小，sub用来做减法，要求大的减小的 // 判断A大于等于B bool cmp(vector\u003cint\u003e\u0026 A, vector\u003cint\u003e\u0026 B) { if (A.size() != B.size()) return A.size() \u003e B.size(); for (int i = A.size() - 1; i \u003e= 0; --i) { if (A[i] \u003e B[i]) return true; else if (A[i] \u003c B[i]) return false; else continue; } return true; } vector\u003cint\u003e sub(vector\u003cint\u003e\u0026 A, vector\u003cint\u003e\u0026 B) { vector\u003cint\u003e ans; // 这里就已经保证了A是大于等于B的 for (int i = 0, t = 0; i \u003c A.size(); ++i) { int cur = A[i] - (i \u003c B.size() ? B[i] : 0) - t; if (cur \u003e= 0) { t = 0; } else { cur += 10; t = 1; } ans.push_back(cur); } while (ans.size() \u003e 1 \u0026\u0026 ans.back() == 0) ans.pop_back(); return ans; } ","date":"2022-06-12","objectID":"/posts/%E9%AB%98%E7%B2%BE%E5%BA%A6%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/:0:2","tags":["数据结构与算法","算法模版"],"title":"高精度算法模版","uri":"/posts/%E9%AB%98%E7%B2%BE%E5%BA%A6%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"},{"categories":["算法模版"],"content":"高精度乘法 和加法非常像，对于高精度数字A和普通数字B，A * B的结果是A中每一位与B相乘的结果相加，注意进位即可 vector\u003cint\u003e mul(vector\u003cint\u003e\u0026 A, int b) { if (b == 0) return {0}; vector\u003cint\u003e ans; for (int i = 0, t = 0; i \u003c A.size() || t; ++i) { if (i \u003c A.size()) t += A[i] * b; ans.push_back(t % 10); t /= 10; } return ans; } ","date":"2022-06-12","objectID":"/posts/%E9%AB%98%E7%B2%BE%E5%BA%A6%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/:0:3","tags":["数据结构与算法","算法模版"],"title":"高精度算法模版","uri":"/posts/%E9%AB%98%E7%B2%BE%E5%BA%A6%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"},{"categories":["算法模版"],"content":"高精度除法 模拟除法，与上述三种的不同在于，除法要先从高位开始除，不够除就是零，✖️10加上下一位继续除 vector\u003cint\u003e div(vector\u003cint\u003e\u0026 A, int b, int\u0026 r) { // A 除 b，r是余数 if (b == 0) return {}; r = 0; vector\u003cint\u003e ans; // 这里依旧是高位表示的是高位 for (int i = A.size() - 1; i \u003e= 0; --i) { r = r * 10 + A[i]; ans.push_back(r / b); r = r % b; } reverse(ans.begin(), ans.end()); while (ans.size() \u003e 1 \u0026\u0026 ans.back() == 0) ans.pop_back(); return ans; } ","date":"2022-06-12","objectID":"/posts/%E9%AB%98%E7%B2%BE%E5%BA%A6%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/:0:4","tags":["数据结构与算法","算法模版"],"title":"高精度算法模版","uri":"/posts/%E9%AB%98%E7%B2%BE%E5%BA%A6%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"},{"categories":["算法模版"],"content":"二分算法 二分的本质是边界，整个区间可以一分为二，左半边满足某性质，右半边不满足某性质，二分就是用来寻找这个边界的方法。 ","date":"2022-06-12","objectID":"/posts/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/:0:0","tags":["数据结构与算法","算法模版"],"title":"二分算法模版","uri":"/posts/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"},{"categories":["算法模版"],"content":"整数二分 做法： 情况一：找到mid = (l + r + 1) / 2 if (check(mid)): true 边界点在 [mid, r]这个范围内，更新方式：l = mid false 边界点在[l, mid - 1]这个范围内，更新方式r = mid - 1 情况二：找到mid = (l + r) / 2 if (check(mid)): true 边界点在 [l, mid]这个范围内，更新方式：r = mid false 边界点在[mid + 1, r]这个范围内，更新方式l = mid + 1 拿到题目： 先写check函数，如果true的时候是l = mid则补上+1，如果true的时候是r = mid则不加一 模版 // 普通二分查找int int binarySearch(const vector\u003cint\u003e\u0026 nums, int target) { int left = 0, right = (int)nums.size() - 1; while (left \u003c= right) { int mid = left + (right - left) / 2; if (nums[mid] == target) return mid; else if (nums[mid] \u003c target) left = mid + 1; else right = mid - 1; } return -1; } // 更通用的二分模板 // LeetCode34 在排序数组中查找元素的第一个和最后一个位置 class Solution { public: vector\u003cint\u003e searchRange(vector\u003cint\u003e\u0026 nums, int target) { vector\u003cint\u003e ans; // 开始位置（lower_bound）：查询第一个\u003e=target的数 // 范围 [0 .. n-1 ] + [n表示不存在] int left = 0, right = nums.size(); while (left \u003c right) { int mid = (left + right) / 2; if (nums[mid] \u003e= target) right = mid; else left = mid + 1; } ans.push_back(right); //第一个\u003e=target的数的下标（不存在为n） // 结束位置：查询最后一个\u003c=target的数 // 范围 [-1表示不存在] + [0 .. n-1 ] left = -1, right = nums.size() - 1; while (left \u003c right) { int mid = (left + right + 1) / 2; if (nums[mid] \u003c= target) left = mid; else right = mid - 1; } ans.push_back(right); //最后一个\u003c=target的数（不存在为-1） // target出现在[ans[0], ans[1]] if (ans[0] \u003e ans[1]) ans = {-1, -1}; return ans; } }; ","date":"2022-06-12","objectID":"/posts/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/:0:1","tags":["数据结构与算法","算法模版"],"title":"二分算法模版","uri":"/posts/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"},{"categories":["算法模版"],"content":"浮点数二分 跟整数二分思路一致，但不用区分是否+1，没有边界问题 // 实数二分模板 // ans = realSqrt(x) // 如果要求4位小数，就多算2~4位，到1e-6或1e-8，保证精确 double realSqrt(double x, double eps = 1e-6) { double left = 0, right = max(x, 1.0); while (right - left \u003e eps) { double mid = (left + right) / 2; if (mid * mid \u003c= x) { left = mid; } else { right = mid; } } return right; } ","date":"2022-06-12","objectID":"/posts/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/:0:2","tags":["数据结构与算法","算法模版"],"title":"二分算法模版","uri":"/posts/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"},{"categories":["算法模版"],"content":"排序算法 ","date":"2022-06-12","objectID":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/:0:0","tags":["数据结构与算法","算法模版"],"title":"排序算法模版","uri":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"},{"categories":["算法模版"],"content":"快速排序（O(nlogn)) 思想：分治 做法： 确定分界点：nums[l]或nums[r]或nums[(l + r) / 2]或随机 调整范围，使得分界点左边的数小于分界点的数值，分界点右边的数大于分界点的数值 递归处理左右两段 void quickSort(vector\u003cint\u003e\u0026 nums, int l, int r) { if (l \u003e= r) return; int x = nums[(l + r) \u003e\u003e 1]; int i = l, j = r; while (i \u003c= j) { while (nums[i] \u003c x) ++i; while (nums[j] \u003e x) --j; if (i \u003e= j) break; swap(nums[i++], nums[j--]); } quickSort(nums, l, j); quickSort(nums, j + 1, r); } ","date":"2022-06-12","objectID":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/:0:1","tags":["数据结构与算法","算法模版"],"title":"排序算法模版","uri":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"},{"categories":["算法模版"],"content":"归并排序(O(nlogn)) 思想：分治 做法： 确定分界点：mid = (l + r) / 2 递归排序左右两端 归并：将左右两段合二为一 void mergeSort(vector\u003cint\u003e\u0026 nums, int l, int r) { if (l \u003e= r) return; int mid = (l + r) \u003e\u003e 1; mergeSort(nums, l, mid); mergeSort(nums, mid + 1, r); // 使用数组，速度快非常多，大概是使用vector的两倍 int n = r - l + 1; int temp[n]; int i = l, j = mid + 1, idx = 0; while (i \u003c= mid \u0026\u0026 j \u003c= r) { temp[idx++] = nums[i] \u003c nums[j] ? nums[i++] : nums[j++]; } while (i \u003c= mid) temp[idx++] = nums[i++]; while (j \u003c= r) temp[idx++] = nums[j++]; for (int i = 0; i \u003c n; ++i) { nums[l + i] = temp[i]; } } ","date":"2022-06-12","objectID":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/:0:2","tags":["数据结构与算法","算法模版"],"title":"排序算法模版","uri":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"},{"categories":["算法模版"],"content":"堆排序(O(nlogn)) 思想：利用小根堆完成排序 做法： 将数组里的所有数扔到堆里 将堆按序输出 #include \u003ciostream\u003e #include \u003cvector\u003e #include \u003cqueue\u003e using namespace std; void HeapSort(vector\u003cint\u003e\u0026 nums) { priority_queue\u003cint, vector\u003cint\u003e, greater\u003cint\u003e\u003e q(nums.begin(), nums.end()); for (int i = 0; i \u003c nums.size(); ++i) { nums[i] = q.top(); q.pop(); } } int main() { vector\u003cint\u003e nums({3, 5, 2, 5, 7, 4, 9, 0}); HeapSort(nums); for (int i : nums) cout \u003c\u003c i \u003c\u003c \" \"; cout \u003c\u003c endl; return 0; } ","date":"2022-06-12","objectID":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/:0:3","tags":["数据结构与算法","算法模版"],"title":"排序算法模版","uri":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"},{"categories":["算法模版"],"content":"计数排序(O(n + k)) 思想：遍历 做法： 确定范围 去数每个数的数量 重构数组 #include \u003calgorithm\u003e #include \u003ciostream\u003e #include \u003cvector\u003e using namespace std; void countSort(vector\u003cint\u003e\u0026 nums) { int maxVal = -1; for (int num : nums) { maxVal = max(maxVal, num); } vector\u003cint\u003e count(maxVal + 1); for (int num : nums) { ++count[num]; } int index = 0; //原数组修改坐标 for (int val = 0; val \u003c count.size(); ++val) { while (count[val] \u003e 0) { --count[val]; nums[index++] = val; } } } int main() { vector\u003cint\u003e test = {4, 5, 2, 1, 4, 2, 3, 4, 4, 0, 8}; for (auto a : test) { cout \u003c\u003c a \u003c\u003c ' '; } cout \u003c\u003c endl; countSort(test); for (auto a : test) { cout \u003c\u003c a \u003c\u003c ' '; } cout \u003c\u003c endl; } ","date":"2022-06-12","objectID":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/:0:4","tags":["数据结构与算法","算法模版"],"title":"排序算法模版","uri":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"},{"categories":["算法模版"],"content":"冒泡排序(O(n^2)) 思想：两遍遍历 做法： 第一层遍历决定开始的位置 每二层遍历将最大值放到数组的最右边 #include \u003ciostream\u003e #include \u003cvector\u003e using namespace std; void BubbleSort(vector\u003cint\u003e\u0026 nums) { int n = nums.size(); if (n \u003c= 1) return; for (int i = 1; i \u003c n; ++i) { bool check = false; for (int j = 1; j \u003c n - i + 1; ++j) { if (nums[j] \u003c nums[j - 1]) { std::swap(nums[j], nums[j - 1]); check = true; } } if (!check) break; } } int main() { vector\u003cint\u003e nums({3, 5, 2, 5, 7, 4, 9, 0}); BubbleSort(nums); for (int i : nums) cout \u003c\u003c i \u003c\u003c \" \"; cout \u003c\u003c endl; return 0; } ","date":"2022-06-12","objectID":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/:0:5","tags":["数据结构与算法","算法模版"],"title":"排序算法模版","uri":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"},{"categories":["算法模版"],"content":"插入排序 思想：将数组分为已排序和未排序两部分，每次将未排序中的第一个数插入到已排序的部分中，未排序的数量为0时排序完成 做法： 数组的首数字为已排序部分，其余部分为未排序部分 两层遍历，将未排序的第一个数字与已排序的部分逐个比较直到插入到合适的位置中 #include \u003ciostream\u003e #include \u003cvector\u003e using namespace std; void InsertSort(vector\u003cint\u003e\u0026 nums) { int n = nums.size(); if (n \u003c= 1) return; for (int i = 1; i \u003c n; ++i) { for (int j = i; j \u003e 0 \u0026\u0026 nums[j] \u003c nums[j - 1]; --j) { swap(nums[j], nums[j - 1]); } } } int main() { vector\u003cint\u003e nums({3, 5, 2, 5, 7, 4, 9, 0}); InsertSort(nums); for (int i : nums) cout \u003c\u003c i \u003c\u003c \" \"; cout \u003c\u003c endl; return 0; } ","date":"2022-06-12","objectID":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/:0:6","tags":["数据结构与算法","算法模版"],"title":"排序算法模版","uri":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"},{"categories":["算法模版"],"content":"选择排序 思想：将将数组分为已排序和未排序两部分，每次将未排序中的最小的元素放到已排序部分的末尾 做法： 已排序部分为无，整个数组都是未排序部分 两层遍历，每次选择一个最小的值放到已排序的末尾 #include \u003ciostream\u003e #include \u003cvector\u003e using namespace std; void SelectSort(vector\u003cint\u003e\u0026 nums) { int n = nums.size(); if (n \u003c= 1) return; for (int i = 0; i \u003c n; ++i) { int idx = i; for (int j = i; j \u003c n; ++j) { if (nums[j] \u003c nums[idx]) { idx = j; } } swap(nums[i], nums[idx]); } } int main() { vector\u003cint\u003e nums({3, 5, 2, 5, 7, 4, 9, 0}); SelectSort(nums); for (int i : nums) cout \u003c\u003c i \u003c\u003c \" \"; cout \u003c\u003c endl; return 0; } ","date":"2022-06-12","objectID":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/:0:7","tags":["数据结构与算法","算法模版"],"title":"排序算法模版","uri":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"},{"categories":["C/C++"],"content":"优先队列——priority_queue ","date":"2022-06-11","objectID":"/posts/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/:0:0","tags":["C/C++"],"title":"优先队列","uri":"/posts/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"categories":["C/C++"],"content":"介绍 普通的队列是一种先进先出的数据结构，元素在队列尾追加，而从队列头删除； 在优先队列中，元素被赋予优先级。当访问元素时，具有最高优先级的元素最先删除。优先队列具有最高级先出 （first in, largest out）的行为特征。 ","date":"2022-06-11","objectID":"/posts/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/:1:0","tags":["C/C++"],"title":"优先队列","uri":"/posts/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"categories":["C/C++"],"content":"使用 首先要包含头文件****, 他和queue不同的就在于我们可以自定义其中数据的优先级, 让优先级高的排在队列前面,优先出队。 ⚠️：优先队列具有队列的所有特性，包括队列的基本操作，只是在这基础上添加了内部的一个排序，它本质是一个堆实现的。 ","date":"2022-06-11","objectID":"/posts/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/:2:0","tags":["C/C++"],"title":"优先队列","uri":"/posts/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"categories":["C/C++"],"content":"基本操作 和队列基本操作相同: top 访问队头元素 empty 队列是否为空 size 返回队列内元素个数 push 插入元素到队尾 (并排序) emplace 原地构造一个元素并插入队列 pop 弹出队头元素 swap 交换内容 ","date":"2022-06-11","objectID":"/posts/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/:2:1","tags":["C/C++"],"title":"优先队列","uri":"/posts/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"categories":["C/C++"],"content":"定义（初始化） priority_queue\u003cType, Container, Functional\u003e Type 就是数据类型，Container 就是容器类型（Container必须是用数组实现的容器，比如vector,deque等等，但不能用 list。STL里面默认用的是vector），Functional 就是比较的方式。 当需要用自定义的数据类型时才需要传入这三个参数，使用基本数据类型时，只需要传入数据类型，默认是大顶堆。 一般情况如下： //升序队列，小顶堆 priority_queue \u003cint,vector\u003cint\u003e,greater\u003cint\u003e \u003e q; //降序队列，大顶堆 priority_queue \u003cint,vector\u003cint\u003e,less\u003cint\u003e \u003eq; //greater和less是std实现的两个仿函数（就是使一个类的使用看上去像一个函数。 //其实现就是类中实现一个operator()，这个类就有了类似函数的行为，就是一个仿函数类了） ","date":"2022-06-11","objectID":"/posts/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/:2:2","tags":["C/C++"],"title":"优先队列","uri":"/posts/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"categories":["C/C++"],"content":"例子🌰 ","date":"2022-06-11","objectID":"/posts/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/:3:0","tags":["C/C++"],"title":"优先队列","uri":"/posts/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"categories":["C/C++"],"content":"默认情况 #include\u003ciostream\u003e #include \u003cqueue\u003e using namespace std; int main() { //对于基础类型 默认是大顶堆 priority_queue\u003cint\u003e a; //等同于 priority_queue\u003cint, vector\u003cint\u003e, less\u003cint\u003e \u003e a; // 这里一定要有空格，不然成了右移运算符↓↓ priority_queue\u003cint, vector\u003cint\u003e, greater\u003cint\u003e \u003e c; //这样就是小顶堆 priority_queue\u003cstring\u003e b; for (int i = 0; i \u003c 5; i++) { a.push(i); c.push(i); } while (!a.empty()) { cout \u003c\u003c a.top() \u003c\u003c ' '; a.pop(); } cout \u003c\u003c endl; while (!c.empty()) { cout \u003c\u003c c.top() \u003c\u003c ' '; c.pop(); } cout \u003c\u003c endl; b.push(\"abc\"); b.push(\"abcd\"); b.push(\"cbd\"); while (!b.empty()) { cout \u003c\u003c b.top() \u003c\u003c ' '; b.pop(); } cout \u003c\u003c endl; return 0; } 运行结果： 4 3 2 1 0 0 1 2 3 4 cbd abcd abc 请按任意键继续. . . ","date":"2022-06-11","objectID":"/posts/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/:3:1","tags":["C/C++"],"title":"优先队列","uri":"/posts/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"categories":["C/C++"],"content":"用pair做优先队列的元素 使用pair默认比较规则 pair默认比较规则：先比较第一个元素，第一个相等比较第二个。 #include \u003ciostream\u003e #include \u003cqueue\u003e #include \u003cvector\u003e using namespace std; int main() { priority_queue\u003cpair\u003cint, int\u003e \u003e a; pair\u003cint, int\u003e b(1, 2); pair\u003cint, int\u003e c(1, 3); pair\u003cint, int\u003e d(2, 5); a.push(d); a.push(c); a.push(b); while (!a.empty()) { cout \u003c\u003c a.top().first \u003c\u003c ' ' \u003c\u003c a.top().second \u003c\u003c '\\n'; a.pop(); } } 运行结果： 2 5 1 3 1 2 请按任意键继续. . . 自定义pair比较规则 可参考博客： 定义比较类，重构operator() // 优先队列中使用 pair , 自定义排序 #define pii pair\u003cint,int\u003e struct cmp { bool operator() (const pii p1,const pii p2) { // 大于号是小顶堆，小于号是大顶堆 return p1.first \u003e p2.first; // first 小的先弹出 } }; priority_queue\u003cpii,vector\u003cpii\u003e,cmp\u003e Q; 定义比较函数 // 编写比较规则cmp，要求x.first/x.second \u003c y.first/y.second // ⚠️：这里比较规则与实际编写的是反向的 auto cmp = [\u0026](const pair\u003cint, int\u003e\u0026 x, const pair\u003cint, int\u003e\u0026 y) { return arr[x.first] * arr[y.second] \u003e arr[x.second] * arr[y.first]; }; priority_queue\u003cpair\u003cint, int\u003e, vector\u003cpair\u003cint, int\u003e\u003e, decltype(cmp)\u003e q(cmp); ","date":"2022-06-11","objectID":"/posts/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/:3:2","tags":["C/C++"],"title":"优先队列","uri":"/posts/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"categories":["C/C++"],"content":"用自定义类型做优先队列元素的例子 #include \u003ciostream\u003e #include \u003cqueue\u003e using namespace std; //方法1 struct tmp1 //运算符重载\u003c { int x; tmp1(int a) {x = a;} bool operator\u003c(const tmp1\u0026 a) const { return x \u003c a.x; //大顶堆 } }; //方法2 struct tmp2 //重写仿函数 { bool operator() (tmp1 a, tmp1 b) { return a.x \u003c b.x; //大顶堆 } }; int main() { tmp1 a(1); tmp1 b(2); tmp1 c(3); priority_queue\u003ctmp1\u003e d; d.push(b); d.push(c); d.push(a); while (!d.empty()) { cout \u003c\u003c d.top().x \u003c\u003c '\\n'; d.pop(); } cout \u003c\u003c endl; priority_queue\u003ctmp1, vector\u003ctmp1\u003e, tmp2\u003e f; f.push(b); f.push(c); f.push(a); while (!f.empty()) { cout \u003c\u003c f.top().x \u003c\u003c '\\n'; f.pop(); } } 运行结果： 3 2 1 3 2 1 请按任意键继续. . . ","date":"2022-06-11","objectID":"/posts/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/:3:3","tags":["C/C++"],"title":"优先队列","uri":"/posts/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"categories":["C/C++"],"content":" 处理判断字符类 isalpha：判断字符是否为字母 返回值：是字母返回非零，不是字母返回零 使用 cout\u003c\u003cisalpha('a'); //返回非零 cout\u003c\u003cisalpha('2'); //返回0 isalnum：判断是否为字母或数字 cout\u003c\u003cisalnum('a'); //输出非零 cout\u003c\u003cisalnum('2'); // 非零 cout\u003c\u003cisalnum('.'); // 零 islower：判断是否是小写字母 cout\u003c\u003cislower('a'); //非零 cout\u003c\u003cislower('2'); //输出0 cout\u003c\u003cislower('A'); //输出0 isupper：判断是否是大写字母 cout\u003c\u003cisupper('a'); //返回0 cout\u003c\u003cisupper('2'); //返回0 cout\u003c\u003cisupper('A'); //返回非零 tolower：把字符转化为小写 string str= \"THIS IS A STRING\"; for (int i=0; i \u003cstr.size(); i++) str[i] = tolower(str[i]); toupper：把字符转化为大写 string str= \"hahahahaha\"; for (int i=0; i \u003cstr.size(); i++) str[i] = toupper(str[i]); ","date":"2022-06-11","objectID":"/posts/%E5%B8%B8%E7%94%A8c++%E5%87%BD%E6%95%B0/:0:0","tags":["C/C++"],"title":"常用C++函数","uri":"/posts/%E5%B8%B8%E7%94%A8c++%E5%87%BD%E6%95%B0/"},{"categories":["C/C++"],"content":"常用C函数 ","date":"2022-06-10","objectID":"/posts/%E5%B8%B8%E7%94%A8c%E5%87%BD%E6%95%B0/:0:0","tags":["C/C++"],"title":"常用C函数","uri":"/posts/%E5%B8%B8%E7%94%A8c%E5%87%BD%E6%95%B0/"},{"categories":["C/C++"],"content":"文件类函数： fopenh函数（打开文件） 描述：C 库函数 FILE *fopen(const char filename, const char mode)使用给定的模式 mode 打开 filename 所指向的文件。 声明：FILE *fopen(const char *filename, const char *mode) 参数 filename – 这是 C 字符串，包含了要打开的文件名称。 mode – 这是 C 字符串，包含了文件访问模式，模式如下 模式： “r” 打开一个用于读取的文件。该文件必须存在。 “w” 创建一个用于写入的空文件。如果文件名称与已存在的文件相同，则会删除已有文件的内容，文件被视为一个新的空文件。 “a” 追加到一个文件。写操作向文件末尾追加数据。如果文件不存在，则创建文件。 “r+” 打开一个用于更新的文件，可读取也可写入。该文件必须存在。 “w+” 创建一个用于读写的空文件。 “a+” 打开一个用于读取和追加的文件。 返回值：该函数返回一个 FILE 指针。否则返回 NULL，且设置全局变量 errno 来标识错误。 stat函数（检查文件属性） 头文件：#include\u003csys/stat.h\u003e 、#include\u003cuninstd.h\u003e 声明：int stat(const char * file_name, struct stat *buf); 描述：stat()用来将参数file_name 所指的文件状态, 复制到参数buf 所指的结构中 stat结构体说明： struct stat { dev_t st_dev; //device 文件的设备编号 ino_t st_ino; //inode 文件的i-node mode_t st_mode; //protection 文件的类型和存取的权限 nlink_t st_nlink; //number of hard links 连到该文件的硬连接数目, 刚建立的文件值为1. uid_t st_uid; //user ID of owner 文件所有者的用户识别码 gid_t st_gid; //group ID of owner 文件所有者的组识别码 dev_t st_rdev; //device type 若此文件为装置设备文件, 则为其设备编号 off_t st_size; //total size, in bytes 文件大小, 以字节计算 unsigned long st_blksize; //blocksize for filesystem I/O 文件系统的I/O 缓冲区大小. unsigned long st_blocks; //number of blocks allocated 占用文件区块的个数, 每一区块大小为512 个字节. time_t st_atime; //time of lastaccess 文件最近一次被存取或被执行的时间, 一般只有在用mknod、 utime、read、write 与tructate 时改变. time_t st_mtime; //time of last modification 文件最后一次被修改的时间, 一般只有在用mknod、utime 和write时才会改变 time_t st_ctime; //time of last change i-node 最近一次被更改的时间, 此参数会在文件所有者、组、权限被更改时更新 }; stat结构体中的st_mode种类： S_IFMT 0170000 文件类型的位遮罩 S_IFSOCK 0140000 scoket S_IFLNK 0120000 符号连接 S_IFREG 0100000 一般文件 S_IFBLK 0060000 区块装置 S_IFDIR 0040000 目录 S_IFCHR 0020000 字符装置 S_IFIFO 0010000 先进先出 S_ISUID 04000 文件的 (set user-id on execution)位 S_ISGID 02000 文件的 (set group-id on execution)位 S_ISVTX 01000 文件的sticky 位 S_IRUSR (S_IREAD) 00400 文件所有者具可读取权限 S_IWUSR (S_IWRITE)00200 文件所有者具可写入权限 S_IXUSR (S_IEXEC) 00100 文件所有者具可执行权限 S_IRGRP 00040 用户组具可读取权限 S_IWGRP 00020 用户组具可写入权限 S_IXGRP 00010 用户组具可执行权限 S_IROTH 00004 其他用户具可读取权限 S_IWOTH 00002 其他用户具可写入权限 S_IXOTH 00001 其他用户具可执行权限上述的文件类型在 POSIX 中定义了检查这些类型的宏定义 S_ISLNK (st_mode) 判断是否为符号连接 S_ISREG (st_mode) 是否为一般文件 S_ISDIR (st_mode) 是否为目录 S_ISCHR (st_mode) 是否为字符装置文件 S_ISBLK (s3e) 是否为先进先出 S_ISSOCK (st_mode) 是否为socket 若一目录具有sticky 位 (S_ISVTX), 则表示在此目录下的文件只能 被该文件所有者、此目录所有者或root 来删除或改名. 返回值：执行成功则返回0，失败返回-1，错误代码存于errno ","date":"2022-06-10","objectID":"/posts/%E5%B8%B8%E7%94%A8c%E5%87%BD%E6%95%B0/:0:1","tags":["C/C++"],"title":"常用C函数","uri":"/posts/%E5%B8%B8%E7%94%A8c%E5%87%BD%E6%95%B0/"},{"categories":["C/C++"],"content":"字符串类函数： strspn函数（检索第一个不在范围内的字符） 描述：检索字符串 str1 中第一个不在字符串 str2 中出现的字符下标 声明：size_t strspn(const char *str1, const char *str2) 参数： str1 – 要被检索的 C 字符串 str2 – 该字符串包含了要在 str1 中进行匹配的字符列表 返回值：返回 str1 中第一个不在字符串 str2 中出现的字符下标 strcasecmp函数（忽略大小写比较两个字符串） 头文件：#include \u003cstrings.h\u003e 描述：忽略大小比较两个字符串是否相同 声明： int strcasecmp (const char *s1, const char *s2); 返回值：若参数s1和s2字符串相等则返回0。s1大于s2则返回大于0 的值，s1 小于s2 则返回小于0的值 strcmp函数（比较两个字符串) 描述：把 str1 所指向的字符串和 str2 所指向的字符串进行比较 声明：int strcmp(const char *str1, const char *str2) strncmp函数（比较限定字节数的两个字符串） 描述：把 str1 和 str2 进行比较，最多比较前 n 个字节（换言之其实比较的长度是min(n, strlen(str2))) 声明：int strncmp(const char *str1, const char *str2, size_t n) 参数： str1 – 要进行比较的第一个字符串。 str2 – 要进行比较的第二个字符串。 n – 要比较的最大字符数。 返回值： 如果返回值 \u003c 0，则表示 str1 小于 str2。 如果返回值 \u003e 0，则表示 str1 大于 str2。 如果返回值 = 0，则表示 str1 等于 str2。 ","date":"2022-06-10","objectID":"/posts/%E5%B8%B8%E7%94%A8c%E5%87%BD%E6%95%B0/:0:2","tags":["C/C++"],"title":"常用C函数","uri":"/posts/%E5%B8%B8%E7%94%A8c%E5%87%BD%E6%95%B0/"},{"categories":["C/C++"],"content":"时间类函数： gettimeofday函数（获取当前时间） 描述：在C语言中可以使用函数gettimeofday()函数来得到时间，它的精度可以达到微秒。它把目前的时间用tv 结构体返回，当地时区的信息则放到tz所指的结构中 声明：int gettimeofday(struct timeval*tv,struct timezone *tz) 结构体说明 struct timeval{ long tv_sec;/*秒*/ long tv_usec;/*微妙*/ }； struct timezone{ int tz_minuteswest;/*和greenwich 时间差了多少分钟*/ int tz_dsttime;/*type of DST correction*/ } 参数： 在gettimeofday()函数中tv或者tz都可以为空。如果为空则就不返回其对应的结构体 返回值：函数执行成功后返回0，失败后返回-1，错误代码存于errno中 ","date":"2022-06-10","objectID":"/posts/%E5%B8%B8%E7%94%A8c%E5%87%BD%E6%95%B0/:0:3","tags":["C/C++"],"title":"常用C函数","uri":"/posts/%E5%B8%B8%E7%94%A8c%E5%87%BD%E6%95%B0/"},{"categories":["杂谈"],"content":"第一篇博客 ","date":"2022-06-10","objectID":"/posts/first_post/:0:0","tags":["杂谈"],"title":"First_post","uri":"/posts/first_post/"},{"categories":["杂谈"],"content":"1.1简单介绍 这里是一枚励志成为一名优秀的后端开发工程师的同学 未来会逐步将自己以前写的博客迁移过来 ","date":"2022-06-10","objectID":"/posts/first_post/:0:1","tags":["杂谈"],"title":"First_post","uri":"/posts/first_post/"}]