[{"categories":["iOS"],"content":"UIStackView使用指南 ","date":"2022-08-17","objectID":"/posts/ios-uistackview%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:0:0","tags":["iOS"],"title":"iOS-UIStackView使用指南","uri":"/posts/ios-uistackview%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":["iOS"],"content":"概述 一般遇到两个或以上的控件进行一行或一列布局时，或行列组合成卡片形式的布局时，使用 UIStackView 是最简单有效的方案，例如一些 tab 的展示时，可简单使用 UIStackView + UIScrollView 实现。当然要排列的控件比较多，且需要分页加载的时候，请考虑使用 UICollectionView。 所以这里的 Stack 不是堆栈的意思，也不存在压栈、弹栈的操作，可以理解为“堆叠”。UIStackView实现了U界面×轴和丫轴方向上的堆叠。类比理解，Swiftul 带来的 ZStack 就是Z轴方向上的视图堆叠。 一图概之： 基本要点： 基于 Auto Layout 布局子视图。UIStackView 自身也需要使用 Auto Layout 布局，使用 frame 布局可能效果不一定符合预期。 开发者负责定义 UIStackView 的位置和尺寸（可选），UIStackView 自身管理子视图的内容布局和自身大小，即至少给 UIStackView 添加两个邻边的位置约束。 可动态修改所有属性。 阄割了 UView 基类的一些特性，如设置 backgroundColor UIStackView 是 Apple 基于 Flexbox 思想来实现的布局，虽然是以一个控件 （UlView 子类）呈现，但它做的更多是布局其加入子视图。这种布局思想更接近物理世界的直觉。 Flexbox 在2009 年被W3C 提出，可以很简单、完整地实现各种页面布局，而且还是响应式的，开始被应用于前端领域，目前所有浏览器都已支持。后来通过 React Native 和 Weex等框架，它被带入到客户端开发中，同时支持了 i0s 和 Android。想了解 Flexbax 的详细 CSS布局，可参阅 Flex 布局教程：语法篇-阮一峰的网络日志。 要想更直观地体验把玩 Flexbox 布局，可参阅以下链接： display: flex Flexbox Froggy - A game for learning CSS flexbox Flexy Boxes — CSS flexbox playground and code generation tool 要想在iOS完整体验 Flexbox 布局，可使用 Texture 中的 ASStackLayoutSpec。一些聪明的开发者通过UICollectionViewLayout也实现了简单的 Flexbox 布局，如 UICollectionViewFlexboxLayouto SwiftUl也引入了些 Flexbox 布局，如 HStack、 vStack 和 ZStack，可参阅 Building layouts with UIStackViews 简单体验其为布局带来的便利 ","date":"2022-08-17","objectID":"/posts/ios-uistackview%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:1:0","tags":["iOS"],"title":"iOS-UIStackView使用指南","uri":"/posts/ios-uistackview%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":["iOS"],"content":"内容自适应规则 一句话概括：subview content size + spacing。 UIStackView 沿轴方向长度 = 所有排列子视图大小之和 + 子视图之间的间距总和 UIStackView 正交轴方向（垂直于轴方向）长度 = 最大排列子视图的长度 若 isLayoutwarginsReLativeArrangement 为 true，上述的长度还会包含相关的 layoutMargins 上面所说的长度都是拟合大小 （fitting size) 注意: 这里的子视图大小是视图的 content size，内容大小，是指 Auto Layout 约束计算之后的 size，所以直接设置 frame是无效的，必须通过重写 intrinsieContentsize 属性或给子视图的宽高添加 Auto Layout 约束 这里还隐含了一些潜规则： 让 UIStackView 能自适应子视图大小的前提是子视图要有 content size。 最终子视图的 size 也不一定等于 content size，当 UIStackView 自身设置了宽高约束，其会为了填充空间会对子视图进行拉伸或收缩。 自适应子视图大小意味着其不允许子视图溢出其自身。这与 CSS flexbox 的 flex-wrap 表现有别。 另外 UIStackView 的这些布局属性会直接影响其自适应的大小： axis：定义了堆叠的轴方向，是在垂直方向还是水平方向进行堆叠。 distribution：定义了轴方向上的子视图布局。 alignment：定义了轴正交方向上的子视图布局。 spacing：定义了轴方向上的子视图之间的最小间距。 isBaselineRelativeArrangement：定义了视图之间的垂直间距是否从基线测量 isLayoutMarginsRelativeArrangement：定义了是否要基于子视图的 LayoutMargins 来布局 若修改上述属性无法达到你的预期效果，则优先检查 Xcode 控制台是否输出了 Auto Layout 约束冲突的错误日志，从中检查需要修改的属性或补充的约束。 ","date":"2022-08-17","objectID":"/posts/ios-uistackview%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:2:0","tags":["iOS"],"title":"iOS-UIStackView使用指南","uri":"/posts/ios-uistackview%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":["iOS"],"content":"NSLayoutConstraint.Axis 默认为horizontal水平方向 ","date":"2022-08-17","objectID":"/posts/ios-uistackview%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:2:1","tags":["iOS"],"title":"iOS-UIStackView使用指南","uri":"/posts/ios-uistackview%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":["iOS"],"content":"UIStackView.Distribution 定义沿 UIStackView 轴方向的子视图的大小和位置的布局。 除了 fillEqually 以外的 distribution，UStackView 在沿轴方向计算尺寸时，会使用每个子视图的 intrinsicContentsize 属性。而 fiLLEqually 会相等调整子视图的大小，使其在轴方向的长度是一致的，如果可能，UIStackView 会拉伸所有子视图，以匹配轴方向最大内容大小的视图。 fill 默认情况，UIStackView 调整其子视图的大小,以填充轴方向上的可用空间 当子视图塞不进 UIStackView 时,UIStackView 根据其抗压优先级 (compression resistance priority) 收缩视图 当子视图没有塞满UIStackView时，UIStackView根据其拥抱优先级(hugging priority)拉伸时图 当存在歧义时,UIStackView 根据子视图在 arrangedSubviews 中的索引调整子视图的大小 fillEqually UIStackView 调整其子视图的大小，以填充轴方向上的可用空间。子视图会拉伸调整大小（匹配最大的子视图），以保持轴方向上的大小都相等。 fillPropertionlly UIStackView 调整其子视图的大小，以填充轴方向上的可用空间。视图根据其沿 UIStackView 轴的内在内容大小按比例调整大小。 equalSpacing UIStackView 放置排列子视图，以填充轴方向上的可用空间。 当排列的视图没有填充 UIStackView 时：UIstackview 会均匀地填充视图之间行间距。即此时的 spaicing 只限定了最小的间距。 当子视图塞不进 UIStackView 时，UIStackView 会根据其抗压优先级收缩视图。 equalCentering 对⼦视图中点等距布局，同时保持⼦视图之间的间距。同样，此时的 spaicing 只限定了最⼩的间距。 当⼦视图塞不进 UIStackView 时，UIStackView 收缩间距，直到达到 spaicing 值。若⼦视图仍塞不进UIStackView，则会根据其抗压优先级收缩子视图 当存在歧义时，UIStackView 会根据其在 arrangedsubviews 中的索引收缩子视图 为了保持⼦视图内容⼤⼩，UIStackView 会突破中点等距布局。同样，为保持⼦视图间的最⼩间距， UIStackView 会压缩⼦视图的内容⼤⼩。 ","date":"2022-08-17","objectID":"/posts/ios-uistackview%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:2:2","tags":["iOS"],"title":"iOS-UIStackView使用指南","uri":"/posts/ios-uistackview%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":["iOS"],"content":"UIStackView.Alignment 定义垂直于 UIStackView 轴方向的子视图布局。 对于除 fill 之外的所有 alignment，UIStackView 在计算轴正交方向的大小时使用每个子视图的 intrinsiccontentsize 属性。fill 则调整所有子视图的大小，以填充轴正交方向上的可用空间，如果可能，UIStackView 会拉伸所有子视图，以匹配轴正交方向上最大内在大小的视图。 fill 默认。UIStackView 调整其子视图大小，以填充轴正交方向上的可用空间。 center UIStackView 把⼦视图中点沿轴对⻬，即垂直方向居中对⻬。 leading：横轴时也可以用top UIStackView把子视图沿着前边缘对齐 trailing：横轴时也可以用bottom fisrtBaseline 仅横轴有效，UIStackView根据首个基线对齐排列子视图 lastBaseline 仅纵轴有效，UIStackView根据末尾基线对齐排列子视图 ","date":"2022-08-17","objectID":"/posts/ios-uistackview%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:2:3","tags":["iOS"],"title":"iOS-UIStackView使用指南","uri":"/posts/ios-uistackview%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":["iOS"],"content":"Spacing间距 固定间距 var spacing: CGFloat { get set } 默认为0.0，此属性定义了在UIStackViewDistribution.fill子视图之间的严格间距，也是UIStackView.Distribution.equalSpacing 和 UIStackView.Distribution.equalCentering 的最小间距 使用负值会重叠子视图，其堆叠层级按子视图的层级索引排列 更进一步，iOS 11.0+ 还增加了设置自定义间距的方法 // Applies custom spacing after the specified view. func setCustomSpacing(_ spacing: CGFloat, after arrangedSubview: UIView) func customSpacing(after arrangedSubview: UIView) -\u003e CGFloat 通过这个方法可以设置子视图之间的间距，如下图所示，只可以设置两个subView之间的间距，而不可以设置一个subView到supperView的边缘的距离 这个时候可以通过给边缘位置添加一个占位视图的方式来进行相关设置，这里简单封装一个占位视图： import UIKit /// 自定义内容尺寸视图 public class SizeView: UIView { public var size: CGSize = .zero required init?(coder: NSCoder) { super.init(coder: coder) commonInit() } override init(frame: CGRect) { super.init(frame: frame) commonInit() } private func commonInit() { isUserInteractionEnabled = false } public override var intrinsicContentSize: CGSize { size } } public extension SizeView { convenience init(size: CGSize, color: UIColor? = nil) { self.init(frame: .zero) self.size = size backgroundColor = color } /// 尽可能大 static func expanded(width: CGFloat = .greatestFiniteMagnitude, height: CGFloat = .greatestFiniteMagnitude, color: UIColor? = nil) -\u003e SizeView { SizeView(size: CGSize(width: width, height: height), color: color) } /// 尽可能小 static func shrinked(width: CGFloat = 0, height: CGFloat = 0, color: UIColor? = nil) -\u003e SizeView { SizeView(size: CGSize(width: width, height: height), color: color) } } 音乐入口代码如下： noMusicStackView.then { let musicIconView = makeMusicIconView() // 使用占位视图添加左侧间距 $0.addArrangedSubview(SizeView.shrinked(width: 12)) $0.addArrangedSubview(musicIconView) // 使用自定义间距 API 设置 sub view 间的间距 $0.setCustomSpacing(6, after: musicIconView) let addLabel = self.addLabel addLabel.font = UI.textFont addLabel.textColor = UI.textColor addLabel.layer.lv.setupShadow(color: UI.textShadow.color, offset: UI.textShadow.offset, radius: UI.textShadow.radius) $0.addArrangedSubview(addLabel) // 使用占位视图添加右侧间距 $0.addArrangedSubview(SizeView.shrinked(width: 12)) } 效果： ","date":"2022-08-17","objectID":"/posts/ios-uistackview%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:2:4","tags":["iOS"],"title":"iOS-UIStackView使用指南","uri":"/posts/ios-uistackview%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":["iOS"],"content":"子视图管理 func addArrangedSubview(_ view: UIView) var arrangedSubviews: [UIView] { get } func insertArrangedSubview(_ view: UIView, at stackIndex: Int) func removeArrangedSubview(_ view: UIView) 上述所有方法都会作用于arrangedSubviews数组，调用UIStackView的addArrangedSubview(_:)时，添加的视图除了添加到 arrangedSubviews 中，同时也会添加到基类的 subviews 中，即成为子视图。 由于 UIStackView 内部会确保 arrangedSubviews 是 subviews 的子集，所以即使在调用 addArrangedSubview(_:) 前调用了基类的 addSubview(_:)，也不会有什么影响，也不会改变其在 arrangedSubviews 中的顺序。但必须要调用 addArrangedSubview(_:) 来添加管理的子视图，否则设置 UIStackView 的各个属性将无法作用于添加的子视图。 移除视图的时候要注意，removeArrangedSubview(_:) 只是从 arrangedSubviews 中移除子视图，即移除的子视图不受 UIStackView 管理，但其还在基类的 subviews 中，即还在视图层级中。所以要直接从层级中移除子视图，可直接使用基类的 removeFromSuperview() 方法。 ","date":"2022-08-17","objectID":"/posts/ios-uistackview%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:3:0","tags":["iOS"],"title":"iOS-UIStackView使用指南","uri":"/posts/ios-uistackview%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":["iOS"],"content":"布局管理 UIStackView 会动态响应以下操作，并自动更新布局： 添加、删除或插入到 arrangedSubviews。 修改 UIStackView 定义的所有属性。 修改子视图的 isHidden 属性。其效果跟 UIView 对子视图的效果不一致，当值为 true 时 UIStackView 会重新计算布局（跟移除视图效果一致），还甚至默认添加了动画（轴方向收缩效果），而 UIView 对子视图 isHidden 为 true 时不会有布局更新，更不会有动画。 处理第 1 点管理 arrangedSubviews 的几个方法，第 2、3 点涉及的属性都可以添加动画。另外要控制子视图 isHidden 的时长，可以放到 animate(withDuration:animations:) 中控制。 ","date":"2022-08-17","objectID":"/posts/ios-uistackview%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:3:1","tags":["iOS"],"title":"iOS-UIStackView使用指南","uri":"/posts/ios-uistackview%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":["算法模版"],"content":"字符串处理 ","date":"2022-06-12","objectID":"/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95/:1:0","tags":["数据结构与算法","算法模版"],"title":"字符串算法","uri":"/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95/"},{"categories":["算法模版"],"content":"KMP 讲解视频：最浅显易懂的 KMP 算法讲解 vector\u003cint\u003e strStr(string\u0026 str, string\u0026 pattern) { int m = str.length(); int n = pattern.length(); // 构造next数组，next数组是根据模版字符串创建的，默认为-1，即没有前缀能与现在构成的后缀进行匹配 vector\u003cint\u003e ne(n, -1); // 从下标1开始构造，因为下标0一定没有前缀 // i代表的是后缀，j代表的是前缀 for (int i = 1, j = -1; i \u003c n; ++i) { // 找到第一个pattern[i] == pattern[j + 1]的下标j while (j \u003e= 0 \u0026\u0026 pattern[i] != pattern[j + 1]) j = ne[j]; // 如果相同即说明前后缀相匹配 if (pattern[i] == pattern[j + 1]) ++j; // 得到j ne[i] = j; } // ans存储所有匹配上的首字符下标 vector\u003cint\u003e ans; // i是普通字符串下标，j是模版字符串下标，因为需要回退，j初始化为-1 for (int i = 0, j = -1; i \u003c m; ++i) { while (j \u003e= 0 \u0026\u0026 str[i] != pattern[j + 1]) j = ne[j]; // str[i] == pattern[j + 1]匹配上了，j加1 if (j + 1 \u003c n \u0026\u0026 str[i] == pattern[j + 1]) ++j; // j + 1 == n代表匹配完成，首字符下标为i - n + 1 if (j + 1 == n) ans.push_back(i - n + 1); } return ans; } ","date":"2022-06-12","objectID":"/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95/:1:1","tags":["数据结构与算法","算法模版"],"title":"字符串算法","uri":"/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95/"},{"categories":["算法模版"],"content":"字典树Trie 字典树Trie是一种高效地存储和查找字符串集合的数据结构，由“结点”和“带有字符的边〞构成。 典型应用是用于统计和排序大量的字符串（但不仅限于字符串），经常被搜索引擎系统用于文本词频统计。 它的优点是：最大限度地减少无谓的字符串比较，查询效率比哈希表高。 基本性质 结点本身不保存完整单词 从根结点到某一结点，路径上经过的字符连接起来即为该结点对应的单词 每个结点出发的所有边代表的字符都不相同 结点用于存储单词的额外信息（例如频次） 内部实现 字符集数组法（简单） 每个结点保存一个长度固定为字符集大小（例如26）的数组，以字符为下标，保存指向的结点空间复杂度为O(结点数*字符集大小)，查询的时间复杂度为O(单词长度)适用于较小字符集，或者单词短、分布稠密的字典 字符集映射法（优化） 把每个结点上的字符集数组改为一个映射（词频统计：hashmap，排序：ordered map) 空间复杂度为O(文本字符总数)，查询的时间复杂度为O(单词长度)，但常数稍大一些适用性更广 核心思想——空间换时间 无论是保存树的结构、字符集数组还是字符集映射，都需要额外的空间 利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的 分组思想：前缀相同的字符串在同一子树中 模版 一般实现 class Trie { public: Trie() { root = new Node(); } void insert(string word) { Node* cur = root; for (char ch : word) { if (cur-\u003emp.find(ch) == cur-\u003emp.end()) { cur-\u003emp[ch] = new Node(); } cur = cur-\u003emp[ch]; } ++cur-\u003ecount; } bool search(string word) { Node* cur = root; for (char ch : word) { if (cur-\u003emp.find(ch) == cur-\u003emp.end()) return false; cur = cur-\u003emp[ch]; } return cur-\u003ecount \u003e 0; } bool startsWith(string prefix) { Node* cur = root; for (char ch : prefix) { if (cur-\u003emp.find(ch) == cur-\u003emp.end()) return false; cur = cur-\u003emp[ch]; } return true; } private: struct Node { int count; unordered_map\u003cchar, Node*\u003e mp; Node() { count = 0; } }; Node* root; }; 重构实现（更精简） struct Trie { public: /** Initialize your data structure here. */ Trie() { root = new Node(); } /** Inserts a word into the trie. */ void insert(string word) { find(word, true, true); } /** Returns if the word is in the trie. */ bool search(string word) { return find(word, true, false); } /** Returns if there is any word in the trie that starts with the given prefix. */ bool startsWith(string prefix) { return find(prefix, false, false); } private: struct Node { int count; unordered_map\u003cchar, Node*\u003e child; Node() : count(0) {} }; Node* root; bool find(const string\u0026 s, bool exact_match, bool insert_if_not_exist) { Node* curr = root; for (char c : s) { if (curr-\u003echild.find(c) == curr-\u003echild.end()) { if (!insert_if_not_exist) return false; curr-\u003echild[c] = new Node(); } curr = curr-\u003echild[c]; } if (insert_if_not_exist) curr-\u003ecount++; return exact_match ? curr-\u003ecount \u003e 0 : true; } }; ","date":"2022-06-12","objectID":"/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95/:1:2","tags":["数据结构与算法","算法模版"],"title":"字符串算法","uri":"/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95/"},{"categories":["算法模版"],"content":"一道有意思的Trie应用题 最大异或对 在给定的N个整数 A1，A2……An中选出两个进行 xor（异或）运算，得到的结果最大是多少？ 输入格式 第一行输入一个整数 N。 第二行输入N个整数 A1A1～An。 输出格式 输出一个整数表示答案。 数据范围 32位整数，N \u003c= 1e5 #include \u003ciostream\u003e #include \u003ccstring\u003e #include \u003calgorithm\u003e #include \u003cvector\u003e using namespace std; struct Node { Node* child[2]; int number; Node() { number = -1; memset(child, 0, sizeof child); } }; Node* root; void insert(int x) { Node* cur = root; for (int i = 31; i \u003e= 0; --i) { if (x \u0026 (1 \u003c\u003c i)) { if (!cur-\u003echild[1]) { cur-\u003echild[1] = new Node(); } cur = cur-\u003echild[1]; } else { if (!cur-\u003echild[0]) { cur-\u003echild[0] = new Node(); } cur = cur-\u003echild[0]; } } cur-\u003enumber = x; } int cmp(int x) { Node* cur = root; for (int i = 31; i \u003e= 0; --i) { if (x \u0026 (1 \u003c\u003c i)) { cur = cur-\u003echild[0] ? cur-\u003echild[0] : cur-\u003echild[1]; } else { cur = cur-\u003echild[1] ? cur-\u003echild[1] : cur-\u003echild[0]; } } return x ^ cur-\u003enumber; } int main() { int n; cin \u003e\u003e n; int nums[n]; root = new Node(); for (int i = 0; i \u003c n; ++i) { int x; cin \u003e\u003e x; nums[i] = x; insert(x); } int ans = -1; for (int i = 0; i \u003c n; ++i) { ans = max(ans, cmp(nums[i])); } printf(\"%d\\n\", ans); return 0; } ","date":"2022-06-12","objectID":"/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95/:1:3","tags":["数据结构与算法","算法模版"],"title":"字符串算法","uri":"/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95/"},{"categories":["算法模版"],"content":"高精度算法 关于高精度：高精度就是计算结果位数非常多，一般的数字整型无法正常显示，java和Python无需考虑，语法自带即可完成高精度处理 ","date":"2022-06-12","objectID":"/posts/%E9%AB%98%E7%B2%BE%E5%BA%A6%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/:0:0","tags":["数据结构与算法","算法模版"],"title":"高精度算法模版","uri":"/posts/%E9%AB%98%E7%B2%BE%E5%BA%A6%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"},{"categories":["算法模版"],"content":"高精度加法 高精度加法就是用数组来模拟人的加法过程，先加个位，然后十位、百位、千位，每一位都要考虑上一位的进位，由于最后可能还存在一位进位，因此用大端模式存储（即数字的高位在数组的高位，数字的低位在数组的低位，即nums[0]是个位）可以利用数组的push_back()而无需搬移整个数组来在最前面加一位。 vector\u003cint\u003e add(vector\u003cint\u003e\u0026 A, vector\u003cint\u003e\u0026 B) { if (A.size() \u003c B.size()) return add(B, A); vector\u003cint\u003e ans; // i是位数，由低到高分别是个位-\u003e最高位，t是进位 int t = 0; for (int i = 0; i \u003c A.size(); ++i) { int cur = A[i] + (i \u003c B.size() ? B[i] : 0) + t; ans.push_back(cur % 10); t = cur / 10; } if (t) ans.push_back(t); return ans; } ","date":"2022-06-12","objectID":"/posts/%E9%AB%98%E7%B2%BE%E5%BA%A6%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/:0:1","tags":["数据结构与算法","算法模版"],"title":"高精度算法模版","uri":"/posts/%E9%AB%98%E7%B2%BE%E5%BA%A6%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"},{"categories":["算法模版"],"content":"高精度减法 与高精度加法类似，也是从低位减起，不够减需要向高位借位，因此一定要用大的减小的，小的减大的则反过来减然后补负号 用cmp来判断A和B的大小，sub用来做减法，要求大的减小的 // 判断A大于等于B bool cmp(vector\u003cint\u003e\u0026 A, vector\u003cint\u003e\u0026 B) { if (A.size() != B.size()) return A.size() \u003e B.size(); for (int i = A.size() - 1; i \u003e= 0; --i) { if (A[i] \u003e B[i]) return true; else if (A[i] \u003c B[i]) return false; else continue; } return true; } vector\u003cint\u003e sub(vector\u003cint\u003e\u0026 A, vector\u003cint\u003e\u0026 B) { vector\u003cint\u003e ans; // 这里就已经保证了A是大于等于B的 for (int i = 0, t = 0; i \u003c A.size(); ++i) { int cur = A[i] - (i \u003c B.size() ? B[i] : 0) - t; if (cur \u003e= 0) { t = 0; } else { cur += 10; t = 1; } ans.push_back(cur); } while (ans.size() \u003e 1 \u0026\u0026 ans.back() == 0) ans.pop_back(); return ans; } ","date":"2022-06-12","objectID":"/posts/%E9%AB%98%E7%B2%BE%E5%BA%A6%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/:0:2","tags":["数据结构与算法","算法模版"],"title":"高精度算法模版","uri":"/posts/%E9%AB%98%E7%B2%BE%E5%BA%A6%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"},{"categories":["算法模版"],"content":"高精度乘法 和加法非常像，对于高精度数字A和普通数字B，A * B的结果是A中每一位与B相乘的结果相加，注意进位即可 vector\u003cint\u003e mul(vector\u003cint\u003e\u0026 A, int b) { if (b == 0) return {0}; vector\u003cint\u003e ans; for (int i = 0, t = 0; i \u003c A.size() || t; ++i) { if (i \u003c A.size()) t += A[i] * b; ans.push_back(t % 10); t /= 10; } return ans; } ","date":"2022-06-12","objectID":"/posts/%E9%AB%98%E7%B2%BE%E5%BA%A6%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/:0:3","tags":["数据结构与算法","算法模版"],"title":"高精度算法模版","uri":"/posts/%E9%AB%98%E7%B2%BE%E5%BA%A6%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"},{"categories":["算法模版"],"content":"高精度除法 模拟除法，与上述三种的不同在于，除法要先从高位开始除，不够除就是零，✖️10加上下一位继续除 vector\u003cint\u003e div(vector\u003cint\u003e\u0026 A, int b, int\u0026 r) { // A 除 b，r是余数 if (b == 0) return {}; r = 0; vector\u003cint\u003e ans; // 这里依旧是高位表示的是高位 for (int i = A.size() - 1; i \u003e= 0; --i) { r = r * 10 + A[i]; ans.push_back(r / b); r = r % b; } reverse(ans.begin(), ans.end()); while (ans.size() \u003e 1 \u0026\u0026 ans.back() == 0) ans.pop_back(); return ans; } ","date":"2022-06-12","objectID":"/posts/%E9%AB%98%E7%B2%BE%E5%BA%A6%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/:0:4","tags":["数据结构与算法","算法模版"],"title":"高精度算法模版","uri":"/posts/%E9%AB%98%E7%B2%BE%E5%BA%A6%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"},{"categories":["算法模版"],"content":"二分算法 二分的本质是边界，整个区间可以一分为二，左半边满足某性质，右半边不满足某性质，二分就是用来寻找这个边界的方法。 ","date":"2022-06-12","objectID":"/posts/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/:0:0","tags":["数据结构与算法","算法模版"],"title":"二分算法模版","uri":"/posts/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"},{"categories":["算法模版"],"content":"整数二分 做法： 情况一：找到mid = (l + r + 1) / 2 if (check(mid)): true 边界点在 [mid, r]这个范围内，更新方式：l = mid false 边界点在[l, mid - 1]这个范围内，更新方式r = mid - 1 情况二：找到mid = (l + r) / 2 if (check(mid)): true 边界点在 [l, mid]这个范围内，更新方式：r = mid false 边界点在[mid + 1, r]这个范围内，更新方式l = mid + 1 拿到题目： 先写check函数，如果true的时候是l = mid则补上+1，如果true的时候是r = mid则不加一 模版 // 普通二分查找int int binarySearch(const vector\u003cint\u003e\u0026 nums, int target) { int left = 0, right = (int)nums.size() - 1; while (left \u003c= right) { int mid = left + (right - left) / 2; if (nums[mid] == target) return mid; else if (nums[mid] \u003c target) left = mid + 1; else right = mid - 1; } return -1; } // 更通用的二分模板 // LeetCode34 在排序数组中查找元素的第一个和最后一个位置 class Solution { public: vector\u003cint\u003e searchRange(vector\u003cint\u003e\u0026 nums, int target) { vector\u003cint\u003e ans; // 开始位置（lower_bound）：查询第一个\u003e=target的数 // 范围 [0 .. n-1 ] + [n表示不存在] int left = 0, right = nums.size(); while (left \u003c right) { int mid = (left + right) / 2; if (nums[mid] \u003e= target) right = mid; else left = mid + 1; } ans.push_back(right); //第一个\u003e=target的数的下标（不存在为n） // 结束位置：查询最后一个\u003c=target的数 // 范围 [-1表示不存在] + [0 .. n-1 ] left = -1, right = nums.size() - 1; while (left \u003c right) { int mid = (left + right + 1) / 2; if (nums[mid] \u003c= target) left = mid; else right = mid - 1; } ans.push_back(right); //最后一个\u003c=target的数（不存在为-1） // target出现在[ans[0], ans[1]] if (ans[0] \u003e ans[1]) ans = {-1, -1}; return ans; } }; ","date":"2022-06-12","objectID":"/posts/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/:0:1","tags":["数据结构与算法","算法模版"],"title":"二分算法模版","uri":"/posts/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"},{"categories":["算法模版"],"content":"浮点数二分 跟整数二分思路一致，但不用区分是否+1，没有边界问题 // 实数二分模板 // ans = realSqrt(x) // 如果要求4位小数，就多算2~4位，到1e-6或1e-8，保证精确 double realSqrt(double x, double eps = 1e-6) { double left = 0, right = max(x, 1.0); while (right - left \u003e eps) { double mid = (left + right) / 2; if (mid * mid \u003c= x) { left = mid; } else { right = mid; } } return right; } ","date":"2022-06-12","objectID":"/posts/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/:0:2","tags":["数据结构与算法","算法模版"],"title":"二分算法模版","uri":"/posts/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"},{"categories":["算法模版"],"content":"排序算法 ","date":"2022-06-12","objectID":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/:0:0","tags":["数据结构与算法","算法模版"],"title":"排序算法模版","uri":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"},{"categories":["算法模版"],"content":"快速排序（O(nlogn)) 思想：分治 做法： 确定分界点：nums[l]或nums[r]或nums[(l + r) / 2]或随机 调整范围，使得分界点左边的数小于分界点的数值，分界点右边的数大于分界点的数值 递归处理左右两段 void quickSort(vector\u003cint\u003e\u0026 nums, int l, int r) { if (l \u003e= r) return; int x = nums[(l + r) \u003e\u003e 1]; int i = l, j = r; while (i \u003c= j) { while (nums[i] \u003c x) ++i; while (nums[j] \u003e x) --j; if (i \u003e= j) break; swap(nums[i++], nums[j--]); } quickSort(nums, l, j); quickSort(nums, j + 1, r); } ","date":"2022-06-12","objectID":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/:0:1","tags":["数据结构与算法","算法模版"],"title":"排序算法模版","uri":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"},{"categories":["算法模版"],"content":"归并排序(O(nlogn)) 思想：分治 做法： 确定分界点：mid = (l + r) / 2 递归排序左右两端 归并：将左右两段合二为一 void mergeSort(vector\u003cint\u003e\u0026 nums, int l, int r) { if (l \u003e= r) return; int mid = (l + r) \u003e\u003e 1; mergeSort(nums, l, mid); mergeSort(nums, mid + 1, r); // 使用数组，速度快非常多，大概是使用vector的两倍 int n = r - l + 1; int temp[n]; int i = l, j = mid + 1, idx = 0; while (i \u003c= mid \u0026\u0026 j \u003c= r) { temp[idx++] = nums[i] \u003c nums[j] ? nums[i++] : nums[j++]; } while (i \u003c= mid) temp[idx++] = nums[i++]; while (j \u003c= r) temp[idx++] = nums[j++]; for (int i = 0; i \u003c n; ++i) { nums[l + i] = temp[i]; } } ","date":"2022-06-12","objectID":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/:0:2","tags":["数据结构与算法","算法模版"],"title":"排序算法模版","uri":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"},{"categories":["算法模版"],"content":"堆排序(O(nlogn)) 思想：利用小根堆完成排序 做法： 将数组里的所有数扔到堆里 将堆按序输出 #include \u003ciostream\u003e #include \u003cvector\u003e #include \u003cqueue\u003e using namespace std; void HeapSort(vector\u003cint\u003e\u0026 nums) { priority_queue\u003cint, vector\u003cint\u003e, greater\u003cint\u003e\u003e q(nums.begin(), nums.end()); for (int i = 0; i \u003c nums.size(); ++i) { nums[i] = q.top(); q.pop(); } } int main() { vector\u003cint\u003e nums({3, 5, 2, 5, 7, 4, 9, 0}); HeapSort(nums); for (int i : nums) cout \u003c\u003c i \u003c\u003c \" \"; cout \u003c\u003c endl; return 0; } ","date":"2022-06-12","objectID":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/:0:3","tags":["数据结构与算法","算法模版"],"title":"排序算法模版","uri":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"},{"categories":["算法模版"],"content":"计数排序(O(n + k)) 思想：遍历 做法： 确定范围 去数每个数的数量 重构数组 #include \u003calgorithm\u003e #include \u003ciostream\u003e #include \u003cvector\u003e using namespace std; void countSort(vector\u003cint\u003e\u0026 nums) { int maxVal = -1; for (int num : nums) { maxVal = max(maxVal, num); } vector\u003cint\u003e count(maxVal + 1); for (int num : nums) { ++count[num]; } int index = 0; //原数组修改坐标 for (int val = 0; val \u003c count.size(); ++val) { while (count[val] \u003e 0) { --count[val]; nums[index++] = val; } } } int main() { vector\u003cint\u003e test = {4, 5, 2, 1, 4, 2, 3, 4, 4, 0, 8}; for (auto a : test) { cout \u003c\u003c a \u003c\u003c ' '; } cout \u003c\u003c endl; countSort(test); for (auto a : test) { cout \u003c\u003c a \u003c\u003c ' '; } cout \u003c\u003c endl; } ","date":"2022-06-12","objectID":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/:0:4","tags":["数据结构与算法","算法模版"],"title":"排序算法模版","uri":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"},{"categories":["算法模版"],"content":"冒泡排序(O(n^2)) 思想：两遍遍历 做法： 第一层遍历决定开始的位置 每二层遍历将最大值放到数组的最右边 #include \u003ciostream\u003e #include \u003cvector\u003e using namespace std; void BubbleSort(vector\u003cint\u003e\u0026 nums) { int n = nums.size(); if (n \u003c= 1) return; for (int i = 1; i \u003c n; ++i) { bool check = false; for (int j = 1; j \u003c n - i + 1; ++j) { if (nums[j] \u003c nums[j - 1]) { std::swap(nums[j], nums[j - 1]); check = true; } } if (!check) break; } } int main() { vector\u003cint\u003e nums({3, 5, 2, 5, 7, 4, 9, 0}); BubbleSort(nums); for (int i : nums) cout \u003c\u003c i \u003c\u003c \" \"; cout \u003c\u003c endl; return 0; } ","date":"2022-06-12","objectID":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/:0:5","tags":["数据结构与算法","算法模版"],"title":"排序算法模版","uri":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"},{"categories":["算法模版"],"content":"插入排序 思想：将数组分为已排序和未排序两部分，每次将未排序中的第一个数插入到已排序的部分中，未排序的数量为0时排序完成 做法： 数组的首数字为已排序部分，其余部分为未排序部分 两层遍历，将未排序的第一个数字与已排序的部分逐个比较直到插入到合适的位置中 #include \u003ciostream\u003e #include \u003cvector\u003e using namespace std; void InsertSort(vector\u003cint\u003e\u0026 nums) { int n = nums.size(); if (n \u003c= 1) return; for (int i = 1; i \u003c n; ++i) { for (int j = i; j \u003e 0 \u0026\u0026 nums[j] \u003c nums[j - 1]; --j) { swap(nums[j], nums[j - 1]); } } } int main() { vector\u003cint\u003e nums({3, 5, 2, 5, 7, 4, 9, 0}); InsertSort(nums); for (int i : nums) cout \u003c\u003c i \u003c\u003c \" \"; cout \u003c\u003c endl; return 0; } ","date":"2022-06-12","objectID":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/:0:6","tags":["数据结构与算法","算法模版"],"title":"排序算法模版","uri":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"},{"categories":["算法模版"],"content":"选择排序 思想：将将数组分为已排序和未排序两部分，每次将未排序中的最小的元素放到已排序部分的末尾 做法： 已排序部分为无，整个数组都是未排序部分 两层遍历，每次选择一个最小的值放到已排序的末尾 #include \u003ciostream\u003e #include \u003cvector\u003e using namespace std; void SelectSort(vector\u003cint\u003e\u0026 nums) { int n = nums.size(); if (n \u003c= 1) return; for (int i = 0; i \u003c n; ++i) { int idx = i; for (int j = i; j \u003c n; ++j) { if (nums[j] \u003c nums[idx]) { idx = j; } } swap(nums[i], nums[idx]); } } int main() { vector\u003cint\u003e nums({3, 5, 2, 5, 7, 4, 9, 0}); SelectSort(nums); for (int i : nums) cout \u003c\u003c i \u003c\u003c \" \"; cout \u003c\u003c endl; return 0; } ","date":"2022-06-12","objectID":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/:0:7","tags":["数据结构与算法","算法模版"],"title":"排序算法模版","uri":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"},{"categories":["C/C++"],"content":"优先队列——priority_queue ","date":"2022-06-11","objectID":"/posts/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/:0:0","tags":["C/C++"],"title":"优先队列","uri":"/posts/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"categories":["C/C++"],"content":"介绍 普通的队列是一种先进先出的数据结构，元素在队列尾追加，而从队列头删除； 在优先队列中，元素被赋予优先级。当访问元素时，具有最高优先级的元素最先删除。优先队列具有最高级先出 （first in, largest out）的行为特征。 ","date":"2022-06-11","objectID":"/posts/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/:1:0","tags":["C/C++"],"title":"优先队列","uri":"/posts/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"categories":["C/C++"],"content":"使用 首先要包含头文件****, 他和queue不同的就在于我们可以自定义其中数据的优先级, 让优先级高的排在队列前面,优先出队。 ⚠️：优先队列具有队列的所有特性，包括队列的基本操作，只是在这基础上添加了内部的一个排序，它本质是一个堆实现的。 ","date":"2022-06-11","objectID":"/posts/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/:2:0","tags":["C/C++"],"title":"优先队列","uri":"/posts/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"categories":["C/C++"],"content":"基本操作 和队列基本操作相同: top 访问队头元素 empty 队列是否为空 size 返回队列内元素个数 push 插入元素到队尾 (并排序) emplace 原地构造一个元素并插入队列 pop 弹出队头元素 swap 交换内容 ","date":"2022-06-11","objectID":"/posts/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/:2:1","tags":["C/C++"],"title":"优先队列","uri":"/posts/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"categories":["C/C++"],"content":"定义（初始化） priority_queue\u003cType, Container, Functional\u003e Type 就是数据类型，Container 就是容器类型（Container必须是用数组实现的容器，比如vector,deque等等，但不能用 list。STL里面默认用的是vector），Functional 就是比较的方式。 当需要用自定义的数据类型时才需要传入这三个参数，使用基本数据类型时，只需要传入数据类型，默认是大顶堆。 一般情况如下： //升序队列，小顶堆 priority_queue \u003cint,vector\u003cint\u003e,greater\u003cint\u003e \u003e q; //降序队列，大顶堆 priority_queue \u003cint,vector\u003cint\u003e,less\u003cint\u003e \u003eq; //greater和less是std实现的两个仿函数（就是使一个类的使用看上去像一个函数。 //其实现就是类中实现一个operator()，这个类就有了类似函数的行为，就是一个仿函数类了） ","date":"2022-06-11","objectID":"/posts/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/:2:2","tags":["C/C++"],"title":"优先队列","uri":"/posts/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"categories":["C/C++"],"content":"例子🌰 ","date":"2022-06-11","objectID":"/posts/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/:3:0","tags":["C/C++"],"title":"优先队列","uri":"/posts/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"categories":["C/C++"],"content":"默认情况 #include\u003ciostream\u003e #include \u003cqueue\u003e using namespace std; int main() { //对于基础类型 默认是大顶堆 priority_queue\u003cint\u003e a; //等同于 priority_queue\u003cint, vector\u003cint\u003e, less\u003cint\u003e \u003e a; // 这里一定要有空格，不然成了右移运算符↓↓ priority_queue\u003cint, vector\u003cint\u003e, greater\u003cint\u003e \u003e c; //这样就是小顶堆 priority_queue\u003cstring\u003e b; for (int i = 0; i \u003c 5; i++) { a.push(i); c.push(i); } while (!a.empty()) { cout \u003c\u003c a.top() \u003c\u003c ' '; a.pop(); } cout \u003c\u003c endl; while (!c.empty()) { cout \u003c\u003c c.top() \u003c\u003c ' '; c.pop(); } cout \u003c\u003c endl; b.push(\"abc\"); b.push(\"abcd\"); b.push(\"cbd\"); while (!b.empty()) { cout \u003c\u003c b.top() \u003c\u003c ' '; b.pop(); } cout \u003c\u003c endl; return 0; } 运行结果： 4 3 2 1 0 0 1 2 3 4 cbd abcd abc 请按任意键继续. . . ","date":"2022-06-11","objectID":"/posts/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/:3:1","tags":["C/C++"],"title":"优先队列","uri":"/posts/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"categories":["C/C++"],"content":"用pair做优先队列的元素 使用pair默认比较规则 pair默认比较规则：先比较第一个元素，第一个相等比较第二个。 #include \u003ciostream\u003e #include \u003cqueue\u003e #include \u003cvector\u003e using namespace std; int main() { priority_queue\u003cpair\u003cint, int\u003e \u003e a; pair\u003cint, int\u003e b(1, 2); pair\u003cint, int\u003e c(1, 3); pair\u003cint, int\u003e d(2, 5); a.push(d); a.push(c); a.push(b); while (!a.empty()) { cout \u003c\u003c a.top().first \u003c\u003c ' ' \u003c\u003c a.top().second \u003c\u003c '\\n'; a.pop(); } } 运行结果： 2 5 1 3 1 2 请按任意键继续. . . 自定义pair比较规则 可参考博客： 定义比较类，重构operator() // 优先队列中使用 pair , 自定义排序 #define pii pair\u003cint,int\u003e struct cmp { bool operator() (const pii p1,const pii p2) { // 大于号是小顶堆，小于号是大顶堆 return p1.first \u003e p2.first; // first 小的先弹出 } }; priority_queue\u003cpii,vector\u003cpii\u003e,cmp\u003e Q; 定义比较函数 // 编写比较规则cmp，要求x.first/x.second \u003c y.first/y.second // ⚠️：这里比较规则与实际编写的是反向的 auto cmp = [\u0026](const pair\u003cint, int\u003e\u0026 x, const pair\u003cint, int\u003e\u0026 y) { return arr[x.first] * arr[y.second] \u003e arr[x.second] * arr[y.first]; }; priority_queue\u003cpair\u003cint, int\u003e, vector\u003cpair\u003cint, int\u003e\u003e, decltype(cmp)\u003e q(cmp); ","date":"2022-06-11","objectID":"/posts/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/:3:2","tags":["C/C++"],"title":"优先队列","uri":"/posts/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"categories":["C/C++"],"content":"用自定义类型做优先队列元素的例子 #include \u003ciostream\u003e #include \u003cqueue\u003e using namespace std; //方法1 struct tmp1 //运算符重载\u003c { int x; tmp1(int a) {x = a;} bool operator\u003c(const tmp1\u0026 a) const { return x \u003c a.x; //大顶堆 } }; //方法2 struct tmp2 //重写仿函数 { bool operator() (tmp1 a, tmp1 b) { return a.x \u003c b.x; //大顶堆 } }; int main() { tmp1 a(1); tmp1 b(2); tmp1 c(3); priority_queue\u003ctmp1\u003e d; d.push(b); d.push(c); d.push(a); while (!d.empty()) { cout \u003c\u003c d.top().x \u003c\u003c '\\n'; d.pop(); } cout \u003c\u003c endl; priority_queue\u003ctmp1, vector\u003ctmp1\u003e, tmp2\u003e f; f.push(b); f.push(c); f.push(a); while (!f.empty()) { cout \u003c\u003c f.top().x \u003c\u003c '\\n'; f.pop(); } } 运行结果： 3 2 1 3 2 1 请按任意键继续. . . ","date":"2022-06-11","objectID":"/posts/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/:3:3","tags":["C/C++"],"title":"优先队列","uri":"/posts/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"categories":["C/C++"],"content":" 处理判断字符类 isalpha：判断字符是否为字母 返回值：是字母返回非零，不是字母返回零 使用 cout\u003c\u003cisalpha('a'); //返回非零 cout\u003c\u003cisalpha('2'); //返回0 isalnum：判断是否为字母或数字 cout\u003c\u003cisalnum('a'); //输出非零 cout\u003c\u003cisalnum('2'); // 非零 cout\u003c\u003cisalnum('.'); // 零 islower：判断是否是小写字母 cout\u003c\u003cislower('a'); //非零 cout\u003c\u003cislower('2'); //输出0 cout\u003c\u003cislower('A'); //输出0 isupper：判断是否是大写字母 cout\u003c\u003cisupper('a'); //返回0 cout\u003c\u003cisupper('2'); //返回0 cout\u003c\u003cisupper('A'); //返回非零 tolower：把字符转化为小写 string str= \"THIS IS A STRING\"; for (int i=0; i \u003cstr.size(); i++) str[i] = tolower(str[i]); toupper：把字符转化为大写 string str= \"hahahahaha\"; for (int i=0; i \u003cstr.size(); i++) str[i] = toupper(str[i]); ","date":"2022-06-11","objectID":"/posts/%E5%B8%B8%E7%94%A8c++%E5%87%BD%E6%95%B0/:0:0","tags":["C/C++"],"title":"常用C++函数","uri":"/posts/%E5%B8%B8%E7%94%A8c++%E5%87%BD%E6%95%B0/"},{"categories":["C/C++"],"content":"常用C函数 ","date":"2022-06-10","objectID":"/posts/%E5%B8%B8%E7%94%A8c%E5%87%BD%E6%95%B0/:0:0","tags":["C/C++"],"title":"常用C函数","uri":"/posts/%E5%B8%B8%E7%94%A8c%E5%87%BD%E6%95%B0/"},{"categories":["C/C++"],"content":"文件类函数： fopenh函数（打开文件） 描述：C 库函数 FILE *fopen(const char filename, const char mode)使用给定的模式 mode 打开 filename 所指向的文件。 声明：FILE *fopen(const char *filename, const char *mode) 参数 filename – 这是 C 字符串，包含了要打开的文件名称。 mode – 这是 C 字符串，包含了文件访问模式，模式如下 模式： “r” 打开一个用于读取的文件。该文件必须存在。 “w” 创建一个用于写入的空文件。如果文件名称与已存在的文件相同，则会删除已有文件的内容，文件被视为一个新的空文件。 “a” 追加到一个文件。写操作向文件末尾追加数据。如果文件不存在，则创建文件。 “r+” 打开一个用于更新的文件，可读取也可写入。该文件必须存在。 “w+” 创建一个用于读写的空文件。 “a+” 打开一个用于读取和追加的文件。 返回值：该函数返回一个 FILE 指针。否则返回 NULL，且设置全局变量 errno 来标识错误。 stat函数（检查文件属性） 头文件：#include\u003csys/stat.h\u003e 、#include\u003cuninstd.h\u003e 声明：int stat(const char * file_name, struct stat *buf); 描述：stat()用来将参数file_name 所指的文件状态, 复制到参数buf 所指的结构中 stat结构体说明： struct stat { dev_t st_dev; //device 文件的设备编号 ino_t st_ino; //inode 文件的i-node mode_t st_mode; //protection 文件的类型和存取的权限 nlink_t st_nlink; //number of hard links 连到该文件的硬连接数目, 刚建立的文件值为1. uid_t st_uid; //user ID of owner 文件所有者的用户识别码 gid_t st_gid; //group ID of owner 文件所有者的组识别码 dev_t st_rdev; //device type 若此文件为装置设备文件, 则为其设备编号 off_t st_size; //total size, in bytes 文件大小, 以字节计算 unsigned long st_blksize; //blocksize for filesystem I/O 文件系统的I/O 缓冲区大小. unsigned long st_blocks; //number of blocks allocated 占用文件区块的个数, 每一区块大小为512 个字节. time_t st_atime; //time of lastaccess 文件最近一次被存取或被执行的时间, 一般只有在用mknod、 utime、read、write 与tructate 时改变. time_t st_mtime; //time of last modification 文件最后一次被修改的时间, 一般只有在用mknod、utime 和write时才会改变 time_t st_ctime; //time of last change i-node 最近一次被更改的时间, 此参数会在文件所有者、组、权限被更改时更新 }; stat结构体中的st_mode种类： S_IFMT 0170000 文件类型的位遮罩 S_IFSOCK 0140000 scoket S_IFLNK 0120000 符号连接 S_IFREG 0100000 一般文件 S_IFBLK 0060000 区块装置 S_IFDIR 0040000 目录 S_IFCHR 0020000 字符装置 S_IFIFO 0010000 先进先出 S_ISUID 04000 文件的 (set user-id on execution)位 S_ISGID 02000 文件的 (set group-id on execution)位 S_ISVTX 01000 文件的sticky 位 S_IRUSR (S_IREAD) 00400 文件所有者具可读取权限 S_IWUSR (S_IWRITE)00200 文件所有者具可写入权限 S_IXUSR (S_IEXEC) 00100 文件所有者具可执行权限 S_IRGRP 00040 用户组具可读取权限 S_IWGRP 00020 用户组具可写入权限 S_IXGRP 00010 用户组具可执行权限 S_IROTH 00004 其他用户具可读取权限 S_IWOTH 00002 其他用户具可写入权限 S_IXOTH 00001 其他用户具可执行权限上述的文件类型在 POSIX 中定义了检查这些类型的宏定义 S_ISLNK (st_mode) 判断是否为符号连接 S_ISREG (st_mode) 是否为一般文件 S_ISDIR (st_mode) 是否为目录 S_ISCHR (st_mode) 是否为字符装置文件 S_ISBLK (s3e) 是否为先进先出 S_ISSOCK (st_mode) 是否为socket 若一目录具有sticky 位 (S_ISVTX), 则表示在此目录下的文件只能 被该文件所有者、此目录所有者或root 来删除或改名. 返回值：执行成功则返回0，失败返回-1，错误代码存于errno ","date":"2022-06-10","objectID":"/posts/%E5%B8%B8%E7%94%A8c%E5%87%BD%E6%95%B0/:0:1","tags":["C/C++"],"title":"常用C函数","uri":"/posts/%E5%B8%B8%E7%94%A8c%E5%87%BD%E6%95%B0/"},{"categories":["C/C++"],"content":"字符串类函数： strspn函数（检索第一个不在范围内的字符） 描述：检索字符串 str1 中第一个不在字符串 str2 中出现的字符下标 声明：size_t strspn(const char *str1, const char *str2) 参数： str1 – 要被检索的 C 字符串 str2 – 该字符串包含了要在 str1 中进行匹配的字符列表 返回值：返回 str1 中第一个不在字符串 str2 中出现的字符下标 strcasecmp函数（忽略大小写比较两个字符串） 头文件：#include \u003cstrings.h\u003e 描述：忽略大小比较两个字符串是否相同 声明： int strcasecmp (const char *s1, const char *s2); 返回值：若参数s1和s2字符串相等则返回0。s1大于s2则返回大于0 的值，s1 小于s2 则返回小于0的值 strcmp函数（比较两个字符串) 描述：把 str1 所指向的字符串和 str2 所指向的字符串进行比较 声明：int strcmp(const char *str1, const char *str2) strncmp函数（比较限定字节数的两个字符串） 描述：把 str1 和 str2 进行比较，最多比较前 n 个字节（换言之其实比较的长度是min(n, strlen(str2))) 声明：int strncmp(const char *str1, const char *str2, size_t n) 参数： str1 – 要进行比较的第一个字符串。 str2 – 要进行比较的第二个字符串。 n – 要比较的最大字符数。 返回值： 如果返回值 \u003c 0，则表示 str1 小于 str2。 如果返回值 \u003e 0，则表示 str1 大于 str2。 如果返回值 = 0，则表示 str1 等于 str2。 ","date":"2022-06-10","objectID":"/posts/%E5%B8%B8%E7%94%A8c%E5%87%BD%E6%95%B0/:0:2","tags":["C/C++"],"title":"常用C函数","uri":"/posts/%E5%B8%B8%E7%94%A8c%E5%87%BD%E6%95%B0/"},{"categories":["C/C++"],"content":"时间类函数： gettimeofday函数（获取当前时间） 描述：在C语言中可以使用函数gettimeofday()函数来得到时间，它的精度可以达到微秒。它把目前的时间用tv 结构体返回，当地时区的信息则放到tz所指的结构中 声明：int gettimeofday(struct timeval*tv,struct timezone *tz) 结构体说明 struct timeval{ long tv_sec;/*秒*/ long tv_usec;/*微妙*/ }； struct timezone{ int tz_minuteswest;/*和greenwich 时间差了多少分钟*/ int tz_dsttime;/*type of DST correction*/ } 参数： 在gettimeofday()函数中tv或者tz都可以为空。如果为空则就不返回其对应的结构体 返回值：函数执行成功后返回0，失败后返回-1，错误代码存于errno中 ","date":"2022-06-10","objectID":"/posts/%E5%B8%B8%E7%94%A8c%E5%87%BD%E6%95%B0/:0:3","tags":["C/C++"],"title":"常用C函数","uri":"/posts/%E5%B8%B8%E7%94%A8c%E5%87%BD%E6%95%B0/"},{"categories":["杂谈"],"content":"第一篇博客 ","date":"2022-06-10","objectID":"/posts/first_post/:0:0","tags":["杂谈"],"title":"First_post","uri":"/posts/first_post/"},{"categories":["杂谈"],"content":"1.1简单介绍 这里是一枚励志成为一名优秀的后端开发工程师的同学 未来会逐步将自己以前写的博客迁移过来 ","date":"2022-06-10","objectID":"/posts/first_post/:0:1","tags":["杂谈"],"title":"First_post","uri":"/posts/first_post/"}]