[{"categories":["C/C++"],"content":"优先队列——priority_queue ","date":"2022-06-11","objectID":"/posts/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/:0:0","tags":["C/C++"],"title":"优先队列","uri":"/posts/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"categories":["C/C++"],"content":"介绍 普通的队列是一种先进先出的数据结构，元素在队列尾追加，而从队列头删除； 在优先队列中，元素被赋予优先级。当访问元素时，具有最高优先级的元素最先删除。优先队列具有最高级先出 （first in, largest out）的行为特征。 ","date":"2022-06-11","objectID":"/posts/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/:1:0","tags":["C/C++"],"title":"优先队列","uri":"/posts/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"categories":["C/C++"],"content":"使用 首先要包含头文件****, 他和queue不同的就在于我们可以自定义其中数据的优先级, 让优先级高的排在队列前面,优先出队。 ⚠️：优先队列具有队列的所有特性，包括队列的基本操作，只是在这基础上添加了内部的一个排序，它本质是一个堆实现的。 ","date":"2022-06-11","objectID":"/posts/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/:2:0","tags":["C/C++"],"title":"优先队列","uri":"/posts/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"categories":["C/C++"],"content":"基本操作 和队列基本操作相同: top 访问队头元素 empty 队列是否为空 size 返回队列内元素个数 push 插入元素到队尾 (并排序) emplace 原地构造一个元素并插入队列 pop 弹出队头元素 swap 交换内容 ","date":"2022-06-11","objectID":"/posts/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/:2:1","tags":["C/C++"],"title":"优先队列","uri":"/posts/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"categories":["C/C++"],"content":"定义（初始化） priority_queue\u003cType, Container, Functional\u003e Type 就是数据类型，Container 就是容器类型（Container必须是用数组实现的容器，比如vector,deque等等，但不能用 list。STL里面默认用的是vector），Functional 就是比较的方式。 当需要用自定义的数据类型时才需要传入这三个参数，使用基本数据类型时，只需要传入数据类型，默认是大顶堆。 一般情况如下： //升序队列，小顶堆 priority_queue \u003cint,vector\u003cint\u003e,greater\u003cint\u003e \u003e q; //降序队列，大顶堆 priority_queue \u003cint,vector\u003cint\u003e,less\u003cint\u003e \u003eq; //greater和less是std实现的两个仿函数（就是使一个类的使用看上去像一个函数。 //其实现就是类中实现一个operator()，这个类就有了类似函数的行为，就是一个仿函数类了） ","date":"2022-06-11","objectID":"/posts/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/:2:2","tags":["C/C++"],"title":"优先队列","uri":"/posts/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"categories":["C/C++"],"content":"例子🌰 ","date":"2022-06-11","objectID":"/posts/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/:3:0","tags":["C/C++"],"title":"优先队列","uri":"/posts/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"categories":["C/C++"],"content":"默认情况 #include\u003ciostream\u003e#include \u003cqueue\u003eusing namespace std; int main() { //对于基础类型 默认是大顶堆 priority_queue\u003cint\u003e a; //等同于 priority_queue\u003cint, vector\u003cint\u003e, less\u003cint\u003e \u003e a; // 这里一定要有空格，不然成了右移运算符↓↓ priority_queue\u003cint, vector\u003cint\u003e, greater\u003cint\u003e \u003e c; //这样就是小顶堆 priority_queue\u003cstring\u003e b; for (int i = 0; i \u003c 5; i++) { a.push(i); c.push(i); } while (!a.empty()) { cout \u003c\u003c a.top() \u003c\u003c ' '; a.pop(); } cout \u003c\u003c endl; while (!c.empty()) { cout \u003c\u003c c.top() \u003c\u003c ' '; c.pop(); } cout \u003c\u003c endl; b.push(\"abc\"); b.push(\"abcd\"); b.push(\"cbd\"); while (!b.empty()) { cout \u003c\u003c b.top() \u003c\u003c ' '; b.pop(); } cout \u003c\u003c endl; return 0; } 运行结果： 4 3 2 1 0 0 1 2 3 4 cbd abcd abc 请按任意键继续. . . ","date":"2022-06-11","objectID":"/posts/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/:3:1","tags":["C/C++"],"title":"优先队列","uri":"/posts/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"categories":["C/C++"],"content":"用pair做优先队列的元素 使用pair默认比较规则 pair默认比较规则：先比较第一个元素，第一个相等比较第二个。 #include \u003ciostream\u003e#include \u003cqueue\u003e#include \u003cvector\u003eusing namespace std; int main() { priority_queue\u003cpair\u003cint, int\u003e \u003e a; pair\u003cint, int\u003e b(1, 2); pair\u003cint, int\u003e c(1, 3); pair\u003cint, int\u003e d(2, 5); a.push(d); a.push(c); a.push(b); while (!a.empty()) { cout \u003c\u003c a.top().first \u003c\u003c ' ' \u003c\u003c a.top().second \u003c\u003c '\\n'; a.pop(); } } 运行结果： 2 5 1 3 1 2 请按任意键继续. . . 自定义pair比较规则 可参考博客： 定义比较类，重构operator() // 优先队列中使用 pair , 自定义排序 #define pii pair\u003cint,int\u003e struct cmp { bool operator() (const pii p1,const pii p2) { // 大于号是小顶堆，小于号是大顶堆 return p1.first \u003e p2.first; // first 小的先弹出 } }; priority_queue\u003cpii,vector\u003cpii\u003e,cmp\u003e Q; 定义比较函数 // 编写比较规则cmp，要求x.first/x.second \u003c y.first/y.second // ⚠️：这里比较规则与实际编写的是反向的 auto cmp = [\u0026](const pair\u003cint, int\u003e\u0026 x, const pair\u003cint, int\u003e\u0026 y) { return arr[x.first] * arr[y.second] \u003e arr[x.second] * arr[y.first]; }; priority_queue\u003cpair\u003cint, int\u003e, vector\u003cpair\u003cint, int\u003e\u003e, decltype(cmp)\u003e q(cmp); ","date":"2022-06-11","objectID":"/posts/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/:3:2","tags":["C/C++"],"title":"优先队列","uri":"/posts/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"categories":["C/C++"],"content":"用自定义类型做优先队列元素的例子 #include \u003ciostream\u003e#include \u003cqueue\u003eusing namespace std; //方法1 struct tmp1 //运算符重载\u003c { int x; tmp1(int a) {x = a;} bool operator\u003c(const tmp1\u0026 a) const { return x \u003c a.x; //大顶堆 } }; //方法2 struct tmp2 //重写仿函数 { bool operator() (tmp1 a, tmp1 b) { return a.x \u003c b.x; //大顶堆 } }; int main() { tmp1 a(1); tmp1 b(2); tmp1 c(3); priority_queue\u003ctmp1\u003e d; d.push(b); d.push(c); d.push(a); while (!d.empty()) { cout \u003c\u003c d.top().x \u003c\u003c '\\n'; d.pop(); } cout \u003c\u003c endl; priority_queue\u003ctmp1, vector\u003ctmp1\u003e, tmp2\u003e f; f.push(b); f.push(c); f.push(a); while (!f.empty()) { cout \u003c\u003c f.top().x \u003c\u003c '\\n'; f.pop(); } } 运行结果： 3 2 1 3 2 1 请按任意键继续. . . ","date":"2022-06-11","objectID":"/posts/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/:3:3","tags":["C/C++"],"title":"优先队列","uri":"/posts/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"categories":["C/C++"],"content":" 处理判断字符类 isalpha：判断字符是否为字母 返回值：是字母返回非零，不是字母返回零 使用 cout\u003c\u003cisalpha('a'); //返回非零 cout\u003c\u003cisalpha('2'); //返回0 isalnum：判断是否为字母或数字 cout\u003c\u003cisalnum('a'); //输出非零 cout\u003c\u003cisalnum('2'); // 非零 cout\u003c\u003cisalnum('.'); // 零 islower：判断是否是小写字母 cout\u003c\u003cislower('a'); //非零 cout\u003c\u003cislower('2'); //输出0 cout\u003c\u003cislower('A'); //输出0 isupper：判断是否是大写字母 cout\u003c\u003cisupper('a'); //返回0 cout\u003c\u003cisupper('2'); //返回0 cout\u003c\u003cisupper('A'); //返回非零 tolower：把字符转化为小写 string str= \"THIS IS A STRING\"; for (int i=0; i \u003cstr.size(); i++) str[i] = tolower(str[i]); toupper：把字符转化为大写 string str= \"hahahahaha\"; for (int i=0; i \u003cstr.size(); i++) str[i] = toupper(str[i]); ","date":"2022-06-11","objectID":"/posts/%E5%B8%B8%E7%94%A8c++%E5%87%BD%E6%95%B0/:0:0","tags":["C/C++"],"title":"常用C++函数","uri":"/posts/%E5%B8%B8%E7%94%A8c++%E5%87%BD%E6%95%B0/"},{"categories":["C/C++"],"content":"常用C函数 ","date":"2022-06-10","objectID":"/posts/%E5%B8%B8%E7%94%A8c%E5%87%BD%E6%95%B0/:0:0","tags":["C/C++"],"title":"常用C函数","uri":"/posts/%E5%B8%B8%E7%94%A8c%E5%87%BD%E6%95%B0/"},{"categories":["C/C++"],"content":"文件类函数： fopenh函数（打开文件） 描述：C 库函数 FILE *fopen(const char filename, const char mode)使用给定的模式 mode 打开 filename 所指向的文件。 声明：FILE *fopen(const char *filename, const char *mode) 参数 filename – 这是 C 字符串，包含了要打开的文件名称。 mode – 这是 C 字符串，包含了文件访问模式，模式如下 模式： “r” 打开一个用于读取的文件。该文件必须存在。 “w” 创建一个用于写入的空文件。如果文件名称与已存在的文件相同，则会删除已有文件的内容，文件被视为一个新的空文件。 “a” 追加到一个文件。写操作向文件末尾追加数据。如果文件不存在，则创建文件。 “r+” 打开一个用于更新的文件，可读取也可写入。该文件必须存在。 “w+” 创建一个用于读写的空文件。 “a+” 打开一个用于读取和追加的文件。 返回值：该函数返回一个 FILE 指针。否则返回 NULL，且设置全局变量 errno 来标识错误。 stat函数（检查文件属性） 头文件：#include\u003csys/stat.h\u003e 、#include\u003cuninstd.h\u003e 声明：int stat(const char * file_name, struct stat *buf); 描述：stat()用来将参数file_name 所指的文件状态, 复制到参数buf 所指的结构中 stat结构体说明： struct stat { dev_t st_dev; //device 文件的设备编号 ino_t st_ino; //inode 文件的i-node mode_t st_mode; //protection 文件的类型和存取的权限 nlink_t st_nlink; //number of hard links 连到该文件的硬连接数目, 刚建立的文件值为1. uid_t st_uid; //user ID of owner 文件所有者的用户识别码 gid_t st_gid; //group ID of owner 文件所有者的组识别码 dev_t st_rdev; //device type 若此文件为装置设备文件, 则为其设备编号 off_t st_size; //total size, in bytes 文件大小, 以字节计算 unsigned long st_blksize; //blocksize for filesystem I/O 文件系统的I/O 缓冲区大小. unsigned long st_blocks; //number of blocks allocated 占用文件区块的个数, 每一区块大小为512 个字节. time_t st_atime; //time of lastaccess 文件最近一次被存取或被执行的时间, 一般只有在用mknod、 utime、read、write 与tructate 时改变. time_t st_mtime; //time of last modification 文件最后一次被修改的时间, 一般只有在用mknod、utime 和write时才会改变 time_t st_ctime; //time of last change i-node 最近一次被更改的时间, 此参数会在文件所有者、组、权限被更改时更新 }; stat结构体中的st_mode种类： S_IFMT 0170000 文件类型的位遮罩 S_IFSOCK 0140000 scoket S_IFLNK 0120000 符号连接 S_IFREG 0100000 一般文件 S_IFBLK 0060000 区块装置 S_IFDIR 0040000 目录 S_IFCHR 0020000 字符装置 S_IFIFO 0010000 先进先出 S_ISUID 04000 文件的 (set user-id on execution)位 S_ISGID 02000 文件的 (set group-id on execution)位 S_ISVTX 01000 文件的sticky 位 S_IRUSR (S_IREAD) 00400 文件所有者具可读取权限 S_IWUSR (S_IWRITE)00200 文件所有者具可写入权限 S_IXUSR (S_IEXEC) 00100 文件所有者具可执行权限 S_IRGRP 00040 用户组具可读取权限 S_IWGRP 00020 用户组具可写入权限 S_IXGRP 00010 用户组具可执行权限 S_IROTH 00004 其他用户具可读取权限 S_IWOTH 00002 其他用户具可写入权限 S_IXOTH 00001 其他用户具可执行权限上述的文件类型在 POSIX 中定义了检查这些类型的宏定义 S_ISLNK (st_mode) 判断是否为符号连接 S_ISREG (st_mode) 是否为一般文件 S_ISDIR (st_mode) 是否为目录 S_ISCHR (st_mode) 是否为字符装置文件 S_ISBLK (s3e) 是否为先进先出 S_ISSOCK (st_mode) 是否为socket 若一目录具有sticky 位 (S_ISVTX), 则表示在此目录下的文件只能 被该文件所有者、此目录所有者或root 来删除或改名. 返回值：执行成功则返回0，失败返回-1，错误代码存于errno ","date":"2022-06-10","objectID":"/posts/%E5%B8%B8%E7%94%A8c%E5%87%BD%E6%95%B0/:0:1","tags":["C/C++"],"title":"常用C函数","uri":"/posts/%E5%B8%B8%E7%94%A8c%E5%87%BD%E6%95%B0/"},{"categories":["C/C++"],"content":"字符串类函数： strspn函数（检索第一个不在范围内的字符） 描述：检索字符串 str1 中第一个不在字符串 str2 中出现的字符下标 声明：size_t strspn(const char *str1, const char *str2) 参数： str1 – 要被检索的 C 字符串 str2 – 该字符串包含了要在 str1 中进行匹配的字符列表 返回值：返回 str1 中第一个不在字符串 str2 中出现的字符下标 strcasecmp函数（忽略大小写比较两个字符串） 头文件：#include \u003cstrings.h\u003e 描述：忽略大小比较两个字符串是否相同 声明： int strcasecmp (const char *s1, const char *s2); 返回值：若参数s1和s2字符串相等则返回0。s1大于s2则返回大于0 的值，s1 小于s2 则返回小于0的值 strcmp函数（比较两个字符串) 描述：把 str1 所指向的字符串和 str2 所指向的字符串进行比较 声明：int strcmp(const char *str1, const char *str2) strncmp函数（比较限定字节数的两个字符串） 描述：把 str1 和 str2 进行比较，最多比较前 n 个字节（换言之其实比较的长度是min(n, strlen(str2))) 声明：int strncmp(const char *str1, const char *str2, size_t n) 参数： str1 – 要进行比较的第一个字符串。 str2 – 要进行比较的第二个字符串。 n – 要比较的最大字符数。 返回值： 如果返回值 \u003c 0，则表示 str1 小于 str2。 如果返回值 \u003e 0，则表示 str1 大于 str2。 如果返回值 = 0，则表示 str1 等于 str2。 ","date":"2022-06-10","objectID":"/posts/%E5%B8%B8%E7%94%A8c%E5%87%BD%E6%95%B0/:0:2","tags":["C/C++"],"title":"常用C函数","uri":"/posts/%E5%B8%B8%E7%94%A8c%E5%87%BD%E6%95%B0/"},{"categories":["C/C++"],"content":"时间类函数： gettimeofday函数（获取当前时间） 描述：在C语言中可以使用函数gettimeofday()函数来得到时间，它的精度可以达到微秒。它把目前的时间用tv 结构体返回，当地时区的信息则放到tz所指的结构中 声明：int gettimeofday(struct timeval*tv,struct timezone *tz) 结构体说明 struct timeval{ long tv_sec;/*秒*/ long tv_usec;/*微妙*/ }； struct timezone{ int tz_minuteswest;/*和greenwich 时间差了多少分钟*/ int tz_dsttime;/*type of DST correction*/ } 参数： 在gettimeofday()函数中tv或者tz都可以为空。如果为空则就不返回其对应的结构体 返回值：函数执行成功后返回0，失败后返回-1，错误代码存于errno中 ","date":"2022-06-10","objectID":"/posts/%E5%B8%B8%E7%94%A8c%E5%87%BD%E6%95%B0/:0:3","tags":["C/C++"],"title":"常用C函数","uri":"/posts/%E5%B8%B8%E7%94%A8c%E5%87%BD%E6%95%B0/"},{"categories":["杂谈"],"content":"第一篇博客 ","date":"2022-06-10","objectID":"/posts/first_post/:0:0","tags":["杂谈"],"title":"First_post","uri":"/posts/first_post/"},{"categories":["杂谈"],"content":"1.1简单介绍 这里是一枚励志成为一名优秀的后端开发工程师的同学 未来会逐步将自己以前写的博客迁移过来 ","date":"2022-06-10","objectID":"/posts/first_post/:0:1","tags":["杂谈"],"title":"First_post","uri":"/posts/first_post/"}]